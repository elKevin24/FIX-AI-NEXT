// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  TECHNICIAN
  RECEPTIONIST
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_FOR_PARTS
  RESOLVED
  CLOSED
  CANCELLED
}

model Tenant {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique // For subdomain/url routing: tenant1.example.com
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users     User[]
  tickets   Ticket[]
  customers Customer[]
  parts     Part[]
  auditLogs AuditLog[]

  @@map("tenants")
}

model User {
  id       String   @id @default(uuid())
  email    String   @unique
  password String // Hashed
  name     String?
  role     UserRole @default(TECHNICIAN)

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  assignedTickets Ticket[]
  auditLogs       AuditLog[]
  ticketNotes     TicketNote[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Customer {
  id      String  @id @default(uuid())
  name    String
  email   String?
  phone   String?
  address String?

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  tickets Ticket[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("customers")
}

model Ticket {
  id          String       @id @default(uuid())
  title       String
  description String
  status      TicketStatus @default(OPEN)
  priority    String? // Low, Medium, High

  // Device Details (v2)
  deviceType    String?  @default("PC")
  deviceModel   String?
  serialNumber  String?
  accessories   String? // JSON or text
  checkInNotes  String? // Physical condition
  cancellationReason String? // Only if status is CANCELLED

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  customerId String
  customer   Customer @relation(fields: [customerId], references: [id])

  assignedToId String?
  assignedTo   User?   @relation(fields: [assignedToId], references: [id])

  partsUsed PartUsage[]
  notes     TicketNote[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("tickets")
}

model Part {
  id       String  @id @default(uuid())
  name     String
  sku      String?
  quantity Int     @default(0)
  cost     Decimal @db.Decimal(10, 2)
  price    Decimal @db.Decimal(10, 2)

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  usages PartUsage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("parts")
}

model PartUsage {
  id       String @id @default(uuid())
  quantity Int

  ticketId String
  ticket   Ticket @relation(fields: [ticketId], references: [id])

  partId String
  part   Part   @relation(fields: [partId], references: [id])

  createdAt DateTime @default(now())

  @@map("part_usages")
}

model AuditLog {
  id      String  @id @default(uuid())
  action  String
  details String? // JSON string or text

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  createdAt DateTime @default(now())

  @@map("audit_logs")
}

model TicketNote {
  id         String  @id @default(uuid())
  content    String // Note content (can be multiline)
  isInternal Boolean @default(true) // Internal notes vs customer-visible

  ticketId String
  ticket   Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("ticket_notes")
}
