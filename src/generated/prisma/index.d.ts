
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketAttachment
 * 
 */
export type TicketAttachment = $Result.DefaultSelection<Prisma.$TicketAttachmentPayload>
/**
 * Model Part
 * 
 */
export type Part = $Result.DefaultSelection<Prisma.$PartPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseItem
 * 
 */
export type PurchaseItem = $Result.DefaultSelection<Prisma.$PurchaseItemPayload>
/**
 * Model PartUsage
 * 
 */
export type PartUsage = $Result.DefaultSelection<Prisma.$PartUsagePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model TicketNote
 * 
 */
export type TicketNote = $Result.DefaultSelection<Prisma.$TicketNotePayload>
/**
 * Model ServiceTemplate
 * 
 */
export type ServiceTemplate = $Result.DefaultSelection<Prisma.$ServiceTemplatePayload>
/**
 * Model TemplateDefaultPart
 * 
 */
export type TemplateDefaultPart = $Result.DefaultSelection<Prisma.$TemplateDefaultPartPayload>
/**
 * Model TicketService
 * 
 */
export type TicketService = $Result.DefaultSelection<Prisma.$TicketServicePayload>
/**
 * Model TechnicianSpecialization
 * 
 */
export type TechnicianSpecialization = $Result.DefaultSelection<Prisma.$TechnicianSpecializationPayload>
/**
 * Model TechnicianUnavailability
 * 
 */
export type TechnicianUnavailability = $Result.DefaultSelection<Prisma.$TechnicianUnavailabilityPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model CashRegister
 * 
 */
export type CashRegister = $Result.DefaultSelection<Prisma.$CashRegisterPayload>
/**
 * Model CashTransaction
 * 
 */
export type CashTransaction = $Result.DefaultSelection<Prisma.$CashTransactionPayload>
/**
 * Model TenantSettings
 * 
 */
export type TenantSettings = $Result.DefaultSelection<Prisma.$TenantSettingsPayload>
/**
 * Model InvoiceHistory
 * 
 */
export type InvoiceHistory = $Result.DefaultSelection<Prisma.$InvoiceHistoryPayload>
/**
 * Model POSSale
 * 
 */
export type POSSale = $Result.DefaultSelection<Prisma.$POSSalePayload>
/**
 * Model POSSaleItem
 * 
 */
export type POSSaleItem = $Result.DefaultSelection<Prisma.$POSSaleItemPayload>
/**
 * Model POSSalePayment
 * 
 */
export type POSSalePayment = $Result.DefaultSelection<Prisma.$POSSalePaymentPayload>
/**
 * Model POSQuotation
 * 
 */
export type POSQuotation = $Result.DefaultSelection<Prisma.$POSQuotationPayload>
/**
 * Model POSQuotationItem
 * 
 */
export type POSQuotationItem = $Result.DefaultSelection<Prisma.$POSQuotationItemPayload>
/**
 * Model CreditNote
 * 
 */
export type CreditNote = $Result.DefaultSelection<Prisma.$CreditNotePayload>
/**
 * Model CreditNoteItem
 * 
 */
export type CreditNoteItem = $Result.DefaultSelection<Prisma.$CreditNoteItemPayload>
/**
 * Model SessionLog
 * 
 */
export type SessionLog = $Result.DefaultSelection<Prisma.$SessionLogPayload>
/**
 * Model UserPresence
 * 
 */
export type UserPresence = $Result.DefaultSelection<Prisma.$UserPresencePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  VIEWER: 'VIEWER',
  TECHNICIAN: 'TECHNICIAN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  WAITING_FOR_PARTS: 'WAITING_FOR_PARTS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
  CANCELLED: 'CANCELLED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const ServiceCategory: {
  MAINTENANCE: 'MAINTENANCE',
  REPAIR: 'REPAIR',
  UPGRADE: 'UPGRADE',
  DIAGNOSTIC: 'DIAGNOSTIC',
  INSTALLATION: 'INSTALLATION',
  CONSULTATION: 'CONSULTATION'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const TicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const TechnicianStatus: {
  AVAILABLE: 'AVAILABLE',
  UNAVAILABLE: 'UNAVAILABLE',
  ON_VACATION: 'ON_VACATION',
  ON_LEAVE: 'ON_LEAVE',
  IN_TRAINING: 'IN_TRAINING',
  SICK_LEAVE: 'SICK_LEAVE'
};

export type TechnicianStatus = (typeof TechnicianStatus)[keyof typeof TechnicianStatus]


export const Specialization: {
  LAPTOPS: 'LAPTOPS',
  DESKTOPS: 'DESKTOPS',
  PRINTERS: 'PRINTERS',
  NETWORKING: 'NETWORKING',
  MOBILE_DEVICES: 'MOBILE_DEVICES',
  SERVERS: 'SERVERS',
  PERIPHERALS: 'PERIPHERALS',
  SOFTWARE: 'SOFTWARE',
  GENERAL: 'GENERAL'
};

export type Specialization = (typeof Specialization)[keyof typeof Specialization]


export const PurchaseStatus: {
  PENDING: 'PENDING',
  RECEIVED: 'RECEIVED',
  CANCELLED: 'CANCELLED'
};

export type PurchaseStatus = (typeof PurchaseStatus)[keyof typeof PurchaseStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CARD: 'CARD',
  TRANSFER: 'TRANSFER',
  CHECK: 'CHECK',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  OVERDUE: 'OVERDUE'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const POSSaleStatus: {
  COMPLETED: 'COMPLETED',
  VOIDED: 'VOIDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED',
  FULLY_REFUNDED: 'FULLY_REFUNDED'
};

export type POSSaleStatus = (typeof POSSaleStatus)[keyof typeof POSSaleStatus]


export const QuotationStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED',
  CONVERTED: 'CONVERTED',
  CANCELLED: 'CANCELLED'
};

export type QuotationStatus = (typeof QuotationStatus)[keyof typeof QuotationStatus]


export const CreditNoteStatus: {
  PENDING: 'PENDING',
  PROCESSED: 'PROCESSED',
  CANCELLED: 'CANCELLED'
};

export type CreditNoteStatus = (typeof CreditNoteStatus)[keyof typeof CreditNoteStatus]


export const AuditAction: {
  LOGIN_SUCCESS: 'LOGIN_SUCCESS',
  LOGIN_FAILED: 'LOGIN_FAILED',
  LOGOUT: 'LOGOUT',
  USER_CREATED: 'USER_CREATED',
  USER_UPDATED: 'USER_UPDATED',
  USER_DEACTIVATED: 'USER_DEACTIVATED',
  USER_REACTIVATED: 'USER_REACTIVATED',
  ROLE_CHANGED: 'ROLE_CHANGED',
  PASSWORD_CHANGED: 'PASSWORD_CHANGED',
  PASSWORD_RESET_REQUESTED: 'PASSWORD_RESET_REQUESTED',
  PASSWORD_RESET: 'PASSWORD_RESET',
  SESSION_EXPIRED: 'SESSION_EXPIRED',
  TICKET_CREATED: 'TICKET_CREATED',
  TICKET_UPDATED: 'TICKET_UPDATED',
  TICKET_DELETED: 'TICKET_DELETED',
  TICKET_STATUS_CHANGED: 'TICKET_STATUS_CHANGED',
  TICKET_ASSIGNED: 'TICKET_ASSIGNED',
  CONFIG_CHANGED: 'CONFIG_CHANGED',
  TENANT_CONFIG_CHANGED: 'TENANT_CONFIG_CHANGED',
  EXPORT_DATA: 'EXPORT_DATA',
  DATA_EXPORTED: 'DATA_EXPORTED',
  MODULE_ACCESSED: 'MODULE_ACCESSED'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const AuditModule: {
  AUTH: 'AUTH',
  USERS: 'USERS',
  TICKETS: 'TICKETS',
  SETTINGS: 'SETTINGS',
  REPORTS: 'REPORTS',
  DASHBOARD: 'DASHBOARD',
  INVENTORY: 'INVENTORY',
  POS: 'POS',
  BILLING: 'BILLING'
};

export type AuditModule = (typeof AuditModule)[keyof typeof AuditModule]


export const SessionStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  LOGGED_OUT: 'LOGGED_OUT'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const PresenceStatus: {
  ONLINE: 'ONLINE',
  AWAY: 'AWAY',
  BUSY: 'BUSY',
  OFFLINE: 'OFFLINE'
};

export type PresenceStatus = (typeof PresenceStatus)[keyof typeof PresenceStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type ServiceCategory = $Enums.ServiceCategory

export const ServiceCategory: typeof $Enums.ServiceCategory

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type TechnicianStatus = $Enums.TechnicianStatus

export const TechnicianStatus: typeof $Enums.TechnicianStatus

export type Specialization = $Enums.Specialization

export const Specialization: typeof $Enums.Specialization

export type PurchaseStatus = $Enums.PurchaseStatus

export const PurchaseStatus: typeof $Enums.PurchaseStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type POSSaleStatus = $Enums.POSSaleStatus

export const POSSaleStatus: typeof $Enums.POSSaleStatus

export type QuotationStatus = $Enums.QuotationStatus

export const QuotationStatus: typeof $Enums.QuotationStatus

export type CreditNoteStatus = $Enums.CreditNoteStatus

export const CreditNoteStatus: typeof $Enums.CreditNoteStatus

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type AuditModule = $Enums.AuditModule

export const AuditModule: typeof $Enums.AuditModule

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type PresenceStatus = $Enums.PresenceStatus

export const PresenceStatus: typeof $Enums.PresenceStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketAttachment`: Exposes CRUD operations for the **TicketAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketAttachments
    * const ticketAttachments = await prisma.ticketAttachment.findMany()
    * ```
    */
  get ticketAttachment(): Prisma.TicketAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.part`: Exposes CRUD operations for the **Part** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parts
    * const parts = await prisma.part.findMany()
    * ```
    */
  get part(): Prisma.PartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseItem`: Exposes CRUD operations for the **PurchaseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseItems
    * const purchaseItems = await prisma.purchaseItem.findMany()
    * ```
    */
  get purchaseItem(): Prisma.PurchaseItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partUsage`: Exposes CRUD operations for the **PartUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PartUsages
    * const partUsages = await prisma.partUsage.findMany()
    * ```
    */
  get partUsage(): Prisma.PartUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketNote`: Exposes CRUD operations for the **TicketNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketNotes
    * const ticketNotes = await prisma.ticketNote.findMany()
    * ```
    */
  get ticketNote(): Prisma.TicketNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceTemplate`: Exposes CRUD operations for the **ServiceTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTemplates
    * const serviceTemplates = await prisma.serviceTemplate.findMany()
    * ```
    */
  get serviceTemplate(): Prisma.ServiceTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templateDefaultPart`: Exposes CRUD operations for the **TemplateDefaultPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateDefaultParts
    * const templateDefaultParts = await prisma.templateDefaultPart.findMany()
    * ```
    */
  get templateDefaultPart(): Prisma.TemplateDefaultPartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketService`: Exposes CRUD operations for the **TicketService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketServices
    * const ticketServices = await prisma.ticketService.findMany()
    * ```
    */
  get ticketService(): Prisma.TicketServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.technicianSpecialization`: Exposes CRUD operations for the **TechnicianSpecialization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicianSpecializations
    * const technicianSpecializations = await prisma.technicianSpecialization.findMany()
    * ```
    */
  get technicianSpecialization(): Prisma.TechnicianSpecializationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.technicianUnavailability`: Exposes CRUD operations for the **TechnicianUnavailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicianUnavailabilities
    * const technicianUnavailabilities = await prisma.technicianUnavailability.findMany()
    * ```
    */
  get technicianUnavailability(): Prisma.TechnicianUnavailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashRegister`: Exposes CRUD operations for the **CashRegister** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashRegisters
    * const cashRegisters = await prisma.cashRegister.findMany()
    * ```
    */
  get cashRegister(): Prisma.CashRegisterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashTransaction`: Exposes CRUD operations for the **CashTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashTransactions
    * const cashTransactions = await prisma.cashTransaction.findMany()
    * ```
    */
  get cashTransaction(): Prisma.CashTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantSettings`: Exposes CRUD operations for the **TenantSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantSettings
    * const tenantSettings = await prisma.tenantSettings.findMany()
    * ```
    */
  get tenantSettings(): Prisma.TenantSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceHistory`: Exposes CRUD operations for the **InvoiceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceHistories
    * const invoiceHistories = await prisma.invoiceHistory.findMany()
    * ```
    */
  get invoiceHistory(): Prisma.InvoiceHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOSSale`: Exposes CRUD operations for the **POSSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSSales
    * const pOSSales = await prisma.pOSSale.findMany()
    * ```
    */
  get pOSSale(): Prisma.POSSaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOSSaleItem`: Exposes CRUD operations for the **POSSaleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSSaleItems
    * const pOSSaleItems = await prisma.pOSSaleItem.findMany()
    * ```
    */
  get pOSSaleItem(): Prisma.POSSaleItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOSSalePayment`: Exposes CRUD operations for the **POSSalePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSSalePayments
    * const pOSSalePayments = await prisma.pOSSalePayment.findMany()
    * ```
    */
  get pOSSalePayment(): Prisma.POSSalePaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOSQuotation`: Exposes CRUD operations for the **POSQuotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSQuotations
    * const pOSQuotations = await prisma.pOSQuotation.findMany()
    * ```
    */
  get pOSQuotation(): Prisma.POSQuotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOSQuotationItem`: Exposes CRUD operations for the **POSQuotationItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POSQuotationItems
    * const pOSQuotationItems = await prisma.pOSQuotationItem.findMany()
    * ```
    */
  get pOSQuotationItem(): Prisma.POSQuotationItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditNote`: Exposes CRUD operations for the **CreditNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditNotes
    * const creditNotes = await prisma.creditNote.findMany()
    * ```
    */
  get creditNote(): Prisma.CreditNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditNoteItem`: Exposes CRUD operations for the **CreditNoteItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditNoteItems
    * const creditNoteItems = await prisma.creditNoteItem.findMany()
    * ```
    */
  get creditNoteItem(): Prisma.CreditNoteItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionLog`: Exposes CRUD operations for the **SessionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionLogs
    * const sessionLogs = await prisma.sessionLog.findMany()
    * ```
    */
  get sessionLog(): Prisma.SessionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPresence`: Exposes CRUD operations for the **UserPresence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPresences
    * const userPresences = await prisma.userPresence.findMany()
    * ```
    */
  get userPresence(): Prisma.UserPresenceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Customer: 'Customer',
    Ticket: 'Ticket',
    TicketAttachment: 'TicketAttachment',
    Part: 'Part',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseItem: 'PurchaseItem',
    PartUsage: 'PartUsage',
    AuditLog: 'AuditLog',
    TicketNote: 'TicketNote',
    ServiceTemplate: 'ServiceTemplate',
    TemplateDefaultPart: 'TemplateDefaultPart',
    TicketService: 'TicketService',
    TechnicianSpecialization: 'TechnicianSpecialization',
    TechnicianUnavailability: 'TechnicianUnavailability',
    Notification: 'Notification',
    Invoice: 'Invoice',
    Payment: 'Payment',
    CashRegister: 'CashRegister',
    CashTransaction: 'CashTransaction',
    TenantSettings: 'TenantSettings',
    InvoiceHistory: 'InvoiceHistory',
    POSSale: 'POSSale',
    POSSaleItem: 'POSSaleItem',
    POSSalePayment: 'POSSalePayment',
    POSQuotation: 'POSQuotation',
    POSQuotationItem: 'POSQuotationItem',
    CreditNote: 'CreditNote',
    CreditNoteItem: 'CreditNoteItem',
    SessionLog: 'SessionLog',
    UserPresence: 'UserPresence'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "customer" | "ticket" | "ticketAttachment" | "part" | "purchaseOrder" | "purchaseItem" | "partUsage" | "auditLog" | "ticketNote" | "serviceTemplate" | "templateDefaultPart" | "ticketService" | "technicianSpecialization" | "technicianUnavailability" | "notification" | "invoice" | "payment" | "cashRegister" | "cashTransaction" | "tenantSettings" | "invoiceHistory" | "pOSSale" | "pOSSaleItem" | "pOSSalePayment" | "pOSQuotation" | "pOSQuotationItem" | "creditNote" | "creditNoteItem" | "sessionLog" | "userPresence"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketAttachment: {
        payload: Prisma.$TicketAttachmentPayload<ExtArgs>
        fields: Prisma.TicketAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findFirst: {
            args: Prisma.TicketAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          findMany: {
            args: Prisma.TicketAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          create: {
            args: Prisma.TicketAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          createMany: {
            args: Prisma.TicketAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          delete: {
            args: Prisma.TicketAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          update: {
            args: Prisma.TicketAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.TicketAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.TicketAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketAttachmentPayload>
          }
          aggregate: {
            args: Prisma.TicketAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketAttachment>
          }
          groupBy: {
            args: Prisma.TicketAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Part: {
        payload: Prisma.$PartPayload<ExtArgs>
        fields: Prisma.PartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          findFirst: {
            args: Prisma.PartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          findMany: {
            args: Prisma.PartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>[]
          }
          create: {
            args: Prisma.PartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          createMany: {
            args: Prisma.PartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>[]
          }
          delete: {
            args: Prisma.PartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          update: {
            args: Prisma.PartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          deleteMany: {
            args: Prisma.PartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>[]
          }
          upsert: {
            args: Prisma.PartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartPayload>
          }
          aggregate: {
            args: Prisma.PartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePart>
          }
          groupBy: {
            args: Prisma.PartGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartCountArgs<ExtArgs>
            result: $Utils.Optional<PartCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseItem: {
        payload: Prisma.$PurchaseItemPayload<ExtArgs>
        fields: Prisma.PurchaseItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          update: {
            args: Prisma.PurchaseItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseItem>
          }
          groupBy: {
            args: Prisma.PurchaseItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseItemCountAggregateOutputType> | number
          }
        }
      }
      PartUsage: {
        payload: Prisma.$PartUsagePayload<ExtArgs>
        fields: Prisma.PartUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>
          }
          findFirst: {
            args: Prisma.PartUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>
          }
          findMany: {
            args: Prisma.PartUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>[]
          }
          create: {
            args: Prisma.PartUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>
          }
          createMany: {
            args: Prisma.PartUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>[]
          }
          delete: {
            args: Prisma.PartUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>
          }
          update: {
            args: Prisma.PartUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>
          }
          deleteMany: {
            args: Prisma.PartUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>[]
          }
          upsert: {
            args: Prisma.PartUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartUsagePayload>
          }
          aggregate: {
            args: Prisma.PartUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartUsage>
          }
          groupBy: {
            args: Prisma.PartUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartUsageCountArgs<ExtArgs>
            result: $Utils.Optional<PartUsageCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      TicketNote: {
        payload: Prisma.$TicketNotePayload<ExtArgs>
        fields: Prisma.TicketNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          findFirst: {
            args: Prisma.TicketNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          findMany: {
            args: Prisma.TicketNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>[]
          }
          create: {
            args: Prisma.TicketNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          createMany: {
            args: Prisma.TicketNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>[]
          }
          delete: {
            args: Prisma.TicketNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          update: {
            args: Prisma.TicketNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          deleteMany: {
            args: Prisma.TicketNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>[]
          }
          upsert: {
            args: Prisma.TicketNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketNotePayload>
          }
          aggregate: {
            args: Prisma.TicketNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketNote>
          }
          groupBy: {
            args: Prisma.TicketNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketNoteCountArgs<ExtArgs>
            result: $Utils.Optional<TicketNoteCountAggregateOutputType> | number
          }
        }
      }
      ServiceTemplate: {
        payload: Prisma.$ServiceTemplatePayload<ExtArgs>
        fields: Prisma.ServiceTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>
          }
          findFirst: {
            args: Prisma.ServiceTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>
          }
          findMany: {
            args: Prisma.ServiceTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>[]
          }
          create: {
            args: Prisma.ServiceTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>
          }
          createMany: {
            args: Prisma.ServiceTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>[]
          }
          delete: {
            args: Prisma.ServiceTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>
          }
          update: {
            args: Prisma.ServiceTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ServiceTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ServiceTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTemplatePayload>
          }
          aggregate: {
            args: Prisma.ServiceTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceTemplate>
          }
          groupBy: {
            args: Prisma.ServiceTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceTemplateCountAggregateOutputType> | number
          }
        }
      }
      TemplateDefaultPart: {
        payload: Prisma.$TemplateDefaultPartPayload<ExtArgs>
        fields: Prisma.TemplateDefaultPartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateDefaultPartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateDefaultPartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>
          }
          findFirst: {
            args: Prisma.TemplateDefaultPartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateDefaultPartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>
          }
          findMany: {
            args: Prisma.TemplateDefaultPartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>[]
          }
          create: {
            args: Prisma.TemplateDefaultPartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>
          }
          createMany: {
            args: Prisma.TemplateDefaultPartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateDefaultPartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>[]
          }
          delete: {
            args: Prisma.TemplateDefaultPartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>
          }
          update: {
            args: Prisma.TemplateDefaultPartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>
          }
          deleteMany: {
            args: Prisma.TemplateDefaultPartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateDefaultPartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateDefaultPartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>[]
          }
          upsert: {
            args: Prisma.TemplateDefaultPartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateDefaultPartPayload>
          }
          aggregate: {
            args: Prisma.TemplateDefaultPartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateDefaultPart>
          }
          groupBy: {
            args: Prisma.TemplateDefaultPartGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateDefaultPartGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateDefaultPartCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateDefaultPartCountAggregateOutputType> | number
          }
        }
      }
      TicketService: {
        payload: Prisma.$TicketServicePayload<ExtArgs>
        fields: Prisma.TicketServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>
          }
          findFirst: {
            args: Prisma.TicketServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>
          }
          findMany: {
            args: Prisma.TicketServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>[]
          }
          create: {
            args: Prisma.TicketServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>
          }
          createMany: {
            args: Prisma.TicketServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>[]
          }
          delete: {
            args: Prisma.TicketServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>
          }
          update: {
            args: Prisma.TicketServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>
          }
          deleteMany: {
            args: Prisma.TicketServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>[]
          }
          upsert: {
            args: Prisma.TicketServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketServicePayload>
          }
          aggregate: {
            args: Prisma.TicketServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketService>
          }
          groupBy: {
            args: Prisma.TicketServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketServiceCountArgs<ExtArgs>
            result: $Utils.Optional<TicketServiceCountAggregateOutputType> | number
          }
        }
      }
      TechnicianSpecialization: {
        payload: Prisma.$TechnicianSpecializationPayload<ExtArgs>
        fields: Prisma.TechnicianSpecializationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicianSpecializationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicianSpecializationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>
          }
          findFirst: {
            args: Prisma.TechnicianSpecializationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicianSpecializationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>
          }
          findMany: {
            args: Prisma.TechnicianSpecializationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>[]
          }
          create: {
            args: Prisma.TechnicianSpecializationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>
          }
          createMany: {
            args: Prisma.TechnicianSpecializationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicianSpecializationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>[]
          }
          delete: {
            args: Prisma.TechnicianSpecializationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>
          }
          update: {
            args: Prisma.TechnicianSpecializationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>
          }
          deleteMany: {
            args: Prisma.TechnicianSpecializationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicianSpecializationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechnicianSpecializationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>[]
          }
          upsert: {
            args: Prisma.TechnicianSpecializationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianSpecializationPayload>
          }
          aggregate: {
            args: Prisma.TechnicianSpecializationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicianSpecialization>
          }
          groupBy: {
            args: Prisma.TechnicianSpecializationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicianSpecializationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicianSpecializationCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicianSpecializationCountAggregateOutputType> | number
          }
        }
      }
      TechnicianUnavailability: {
        payload: Prisma.$TechnicianUnavailabilityPayload<ExtArgs>
        fields: Prisma.TechnicianUnavailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicianUnavailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicianUnavailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>
          }
          findFirst: {
            args: Prisma.TechnicianUnavailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicianUnavailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>
          }
          findMany: {
            args: Prisma.TechnicianUnavailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>[]
          }
          create: {
            args: Prisma.TechnicianUnavailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>
          }
          createMany: {
            args: Prisma.TechnicianUnavailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicianUnavailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>[]
          }
          delete: {
            args: Prisma.TechnicianUnavailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>
          }
          update: {
            args: Prisma.TechnicianUnavailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>
          }
          deleteMany: {
            args: Prisma.TechnicianUnavailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicianUnavailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechnicianUnavailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>[]
          }
          upsert: {
            args: Prisma.TechnicianUnavailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicianUnavailabilityPayload>
          }
          aggregate: {
            args: Prisma.TechnicianUnavailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicianUnavailability>
          }
          groupBy: {
            args: Prisma.TechnicianUnavailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicianUnavailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicianUnavailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicianUnavailabilityCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      CashRegister: {
        payload: Prisma.$CashRegisterPayload<ExtArgs>
        fields: Prisma.CashRegisterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashRegisterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashRegisterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          findFirst: {
            args: Prisma.CashRegisterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashRegisterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          findMany: {
            args: Prisma.CashRegisterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>[]
          }
          create: {
            args: Prisma.CashRegisterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          createMany: {
            args: Prisma.CashRegisterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashRegisterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>[]
          }
          delete: {
            args: Prisma.CashRegisterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          update: {
            args: Prisma.CashRegisterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          deleteMany: {
            args: Prisma.CashRegisterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashRegisterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashRegisterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>[]
          }
          upsert: {
            args: Prisma.CashRegisterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashRegisterPayload>
          }
          aggregate: {
            args: Prisma.CashRegisterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashRegister>
          }
          groupBy: {
            args: Prisma.CashRegisterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashRegisterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashRegisterCountArgs<ExtArgs>
            result: $Utils.Optional<CashRegisterCountAggregateOutputType> | number
          }
        }
      }
      CashTransaction: {
        payload: Prisma.$CashTransactionPayload<ExtArgs>
        fields: Prisma.CashTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          findFirst: {
            args: Prisma.CashTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          findMany: {
            args: Prisma.CashTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          create: {
            args: Prisma.CashTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          createMany: {
            args: Prisma.CashTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          delete: {
            args: Prisma.CashTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          update: {
            args: Prisma.CashTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CashTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          upsert: {
            args: Prisma.CashTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          aggregate: {
            args: Prisma.CashTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashTransaction>
          }
          groupBy: {
            args: Prisma.CashTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CashTransactionCountAggregateOutputType> | number
          }
        }
      }
      TenantSettings: {
        payload: Prisma.$TenantSettingsPayload<ExtArgs>
        fields: Prisma.TenantSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          findFirst: {
            args: Prisma.TenantSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          findMany: {
            args: Prisma.TenantSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>[]
          }
          create: {
            args: Prisma.TenantSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          createMany: {
            args: Prisma.TenantSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>[]
          }
          delete: {
            args: Prisma.TenantSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          update: {
            args: Prisma.TenantSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          deleteMany: {
            args: Prisma.TenantSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>[]
          }
          upsert: {
            args: Prisma.TenantSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSettingsPayload>
          }
          aggregate: {
            args: Prisma.TenantSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantSettings>
          }
          groupBy: {
            args: Prisma.TenantSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<TenantSettingsCountAggregateOutputType> | number
          }
        }
      }
      InvoiceHistory: {
        payload: Prisma.$InvoiceHistoryPayload<ExtArgs>
        fields: Prisma.InvoiceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>
          }
          findFirst: {
            args: Prisma.InvoiceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>
          }
          findMany: {
            args: Prisma.InvoiceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>[]
          }
          create: {
            args: Prisma.InvoiceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>
          }
          createMany: {
            args: Prisma.InvoiceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>[]
          }
          delete: {
            args: Prisma.InvoiceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>
          }
          update: {
            args: Prisma.InvoiceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceHistoryPayload>
          }
          aggregate: {
            args: Prisma.InvoiceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceHistory>
          }
          groupBy: {
            args: Prisma.InvoiceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceHistoryCountAggregateOutputType> | number
          }
        }
      }
      POSSale: {
        payload: Prisma.$POSSalePayload<ExtArgs>
        fields: Prisma.POSSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          findFirst: {
            args: Prisma.POSSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          findMany: {
            args: Prisma.POSSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>[]
          }
          create: {
            args: Prisma.POSSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          createMany: {
            args: Prisma.POSSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POSSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>[]
          }
          delete: {
            args: Prisma.POSSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          update: {
            args: Prisma.POSSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          deleteMany: {
            args: Prisma.POSSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.POSSaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>[]
          }
          upsert: {
            args: Prisma.POSSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePayload>
          }
          aggregate: {
            args: Prisma.POSSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSSale>
          }
          groupBy: {
            args: Prisma.POSSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.POSSaleCountArgs<ExtArgs>
            result: $Utils.Optional<POSSaleCountAggregateOutputType> | number
          }
        }
      }
      POSSaleItem: {
        payload: Prisma.$POSSaleItemPayload<ExtArgs>
        fields: Prisma.POSSaleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSSaleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSSaleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>
          }
          findFirst: {
            args: Prisma.POSSaleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSSaleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>
          }
          findMany: {
            args: Prisma.POSSaleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>[]
          }
          create: {
            args: Prisma.POSSaleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>
          }
          createMany: {
            args: Prisma.POSSaleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POSSaleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>[]
          }
          delete: {
            args: Prisma.POSSaleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>
          }
          update: {
            args: Prisma.POSSaleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>
          }
          deleteMany: {
            args: Prisma.POSSaleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSSaleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.POSSaleItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>[]
          }
          upsert: {
            args: Prisma.POSSaleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSaleItemPayload>
          }
          aggregate: {
            args: Prisma.POSSaleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSSaleItem>
          }
          groupBy: {
            args: Prisma.POSSaleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSSaleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.POSSaleItemCountArgs<ExtArgs>
            result: $Utils.Optional<POSSaleItemCountAggregateOutputType> | number
          }
        }
      }
      POSSalePayment: {
        payload: Prisma.$POSSalePaymentPayload<ExtArgs>
        fields: Prisma.POSSalePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSSalePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSSalePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>
          }
          findFirst: {
            args: Prisma.POSSalePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSSalePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>
          }
          findMany: {
            args: Prisma.POSSalePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>[]
          }
          create: {
            args: Prisma.POSSalePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>
          }
          createMany: {
            args: Prisma.POSSalePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POSSalePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>[]
          }
          delete: {
            args: Prisma.POSSalePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>
          }
          update: {
            args: Prisma.POSSalePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>
          }
          deleteMany: {
            args: Prisma.POSSalePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSSalePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.POSSalePaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>[]
          }
          upsert: {
            args: Prisma.POSSalePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSSalePaymentPayload>
          }
          aggregate: {
            args: Prisma.POSSalePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSSalePayment>
          }
          groupBy: {
            args: Prisma.POSSalePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSSalePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.POSSalePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<POSSalePaymentCountAggregateOutputType> | number
          }
        }
      }
      POSQuotation: {
        payload: Prisma.$POSQuotationPayload<ExtArgs>
        fields: Prisma.POSQuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSQuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSQuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>
          }
          findFirst: {
            args: Prisma.POSQuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSQuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>
          }
          findMany: {
            args: Prisma.POSQuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>[]
          }
          create: {
            args: Prisma.POSQuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>
          }
          createMany: {
            args: Prisma.POSQuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POSQuotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>[]
          }
          delete: {
            args: Prisma.POSQuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>
          }
          update: {
            args: Prisma.POSQuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>
          }
          deleteMany: {
            args: Prisma.POSQuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSQuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.POSQuotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>[]
          }
          upsert: {
            args: Prisma.POSQuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationPayload>
          }
          aggregate: {
            args: Prisma.POSQuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSQuotation>
          }
          groupBy: {
            args: Prisma.POSQuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSQuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.POSQuotationCountArgs<ExtArgs>
            result: $Utils.Optional<POSQuotationCountAggregateOutputType> | number
          }
        }
      }
      POSQuotationItem: {
        payload: Prisma.$POSQuotationItemPayload<ExtArgs>
        fields: Prisma.POSQuotationItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POSQuotationItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POSQuotationItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>
          }
          findFirst: {
            args: Prisma.POSQuotationItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POSQuotationItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>
          }
          findMany: {
            args: Prisma.POSQuotationItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>[]
          }
          create: {
            args: Prisma.POSQuotationItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>
          }
          createMany: {
            args: Prisma.POSQuotationItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POSQuotationItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>[]
          }
          delete: {
            args: Prisma.POSQuotationItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>
          }
          update: {
            args: Prisma.POSQuotationItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>
          }
          deleteMany: {
            args: Prisma.POSQuotationItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POSQuotationItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.POSQuotationItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>[]
          }
          upsert: {
            args: Prisma.POSQuotationItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POSQuotationItemPayload>
          }
          aggregate: {
            args: Prisma.POSQuotationItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOSQuotationItem>
          }
          groupBy: {
            args: Prisma.POSQuotationItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<POSQuotationItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.POSQuotationItemCountArgs<ExtArgs>
            result: $Utils.Optional<POSQuotationItemCountAggregateOutputType> | number
          }
        }
      }
      CreditNote: {
        payload: Prisma.$CreditNotePayload<ExtArgs>
        fields: Prisma.CreditNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>
          }
          findFirst: {
            args: Prisma.CreditNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>
          }
          findMany: {
            args: Prisma.CreditNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>[]
          }
          create: {
            args: Prisma.CreditNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>
          }
          createMany: {
            args: Prisma.CreditNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>[]
          }
          delete: {
            args: Prisma.CreditNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>
          }
          update: {
            args: Prisma.CreditNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>
          }
          deleteMany: {
            args: Prisma.CreditNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>[]
          }
          upsert: {
            args: Prisma.CreditNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNotePayload>
          }
          aggregate: {
            args: Prisma.CreditNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditNote>
          }
          groupBy: {
            args: Prisma.CreditNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditNoteCountArgs<ExtArgs>
            result: $Utils.Optional<CreditNoteCountAggregateOutputType> | number
          }
        }
      }
      CreditNoteItem: {
        payload: Prisma.$CreditNoteItemPayload<ExtArgs>
        fields: Prisma.CreditNoteItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditNoteItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditNoteItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>
          }
          findFirst: {
            args: Prisma.CreditNoteItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditNoteItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>
          }
          findMany: {
            args: Prisma.CreditNoteItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>[]
          }
          create: {
            args: Prisma.CreditNoteItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>
          }
          createMany: {
            args: Prisma.CreditNoteItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditNoteItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>[]
          }
          delete: {
            args: Prisma.CreditNoteItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>
          }
          update: {
            args: Prisma.CreditNoteItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>
          }
          deleteMany: {
            args: Prisma.CreditNoteItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditNoteItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditNoteItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>[]
          }
          upsert: {
            args: Prisma.CreditNoteItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteItemPayload>
          }
          aggregate: {
            args: Prisma.CreditNoteItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditNoteItem>
          }
          groupBy: {
            args: Prisma.CreditNoteItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditNoteItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditNoteItemCountArgs<ExtArgs>
            result: $Utils.Optional<CreditNoteItemCountAggregateOutputType> | number
          }
        }
      }
      SessionLog: {
        payload: Prisma.$SessionLogPayload<ExtArgs>
        fields: Prisma.SessionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          findFirst: {
            args: Prisma.SessionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          findMany: {
            args: Prisma.SessionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>[]
          }
          create: {
            args: Prisma.SessionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          createMany: {
            args: Prisma.SessionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>[]
          }
          delete: {
            args: Prisma.SessionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          update: {
            args: Prisma.SessionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          deleteMany: {
            args: Prisma.SessionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>[]
          }
          upsert: {
            args: Prisma.SessionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLogPayload>
          }
          aggregate: {
            args: Prisma.SessionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionLog>
          }
          groupBy: {
            args: Prisma.SessionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionLogCountArgs<ExtArgs>
            result: $Utils.Optional<SessionLogCountAggregateOutputType> | number
          }
        }
      }
      UserPresence: {
        payload: Prisma.$UserPresencePayload<ExtArgs>
        fields: Prisma.UserPresenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPresenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPresenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          findFirst: {
            args: Prisma.UserPresenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPresenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          findMany: {
            args: Prisma.UserPresenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>[]
          }
          create: {
            args: Prisma.UserPresenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          createMany: {
            args: Prisma.UserPresenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPresenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>[]
          }
          delete: {
            args: Prisma.UserPresenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          update: {
            args: Prisma.UserPresenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          deleteMany: {
            args: Prisma.UserPresenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPresenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPresenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>[]
          }
          upsert: {
            args: Prisma.UserPresenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          aggregate: {
            args: Prisma.UserPresenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPresence>
          }
          groupBy: {
            args: Prisma.UserPresenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPresenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPresenceCountArgs<ExtArgs>
            result: $Utils.Optional<UserPresenceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    customer?: CustomerOmit
    ticket?: TicketOmit
    ticketAttachment?: TicketAttachmentOmit
    part?: PartOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseItem?: PurchaseItemOmit
    partUsage?: PartUsageOmit
    auditLog?: AuditLogOmit
    ticketNote?: TicketNoteOmit
    serviceTemplate?: ServiceTemplateOmit
    templateDefaultPart?: TemplateDefaultPartOmit
    ticketService?: TicketServiceOmit
    technicianSpecialization?: TechnicianSpecializationOmit
    technicianUnavailability?: TechnicianUnavailabilityOmit
    notification?: NotificationOmit
    invoice?: InvoiceOmit
    payment?: PaymentOmit
    cashRegister?: CashRegisterOmit
    cashTransaction?: CashTransactionOmit
    tenantSettings?: TenantSettingsOmit
    invoiceHistory?: InvoiceHistoryOmit
    pOSSale?: POSSaleOmit
    pOSSaleItem?: POSSaleItemOmit
    pOSSalePayment?: POSSalePaymentOmit
    pOSQuotation?: POSQuotationOmit
    pOSQuotationItem?: POSQuotationItemOmit
    creditNote?: CreditNoteOmit
    creditNoteItem?: CreditNoteItemOmit
    sessionLog?: SessionLogOmit
    userPresence?: UserPresenceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    auditLogs: number
    sessionLogs: number
    userPresences: number
    cashRegisters: number
    cashTransactions: number
    creditNotes: number
    customers: number
    invoices: number
    notifications: number
    parts: number
    payments: number
    posSales: number
    posQuotations: number
    purchaseOrders: number
    serviceTemplates: number
    tickets: number
    users: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
    sessionLogs?: boolean | TenantCountOutputTypeCountSessionLogsArgs
    userPresences?: boolean | TenantCountOutputTypeCountUserPresencesArgs
    cashRegisters?: boolean | TenantCountOutputTypeCountCashRegistersArgs
    cashTransactions?: boolean | TenantCountOutputTypeCountCashTransactionsArgs
    creditNotes?: boolean | TenantCountOutputTypeCountCreditNotesArgs
    customers?: boolean | TenantCountOutputTypeCountCustomersArgs
    invoices?: boolean | TenantCountOutputTypeCountInvoicesArgs
    notifications?: boolean | TenantCountOutputTypeCountNotificationsArgs
    parts?: boolean | TenantCountOutputTypeCountPartsArgs
    payments?: boolean | TenantCountOutputTypeCountPaymentsArgs
    posSales?: boolean | TenantCountOutputTypeCountPosSalesArgs
    posQuotations?: boolean | TenantCountOutputTypeCountPosQuotationsArgs
    purchaseOrders?: boolean | TenantCountOutputTypeCountPurchaseOrdersArgs
    serviceTemplates?: boolean | TenantCountOutputTypeCountServiceTemplatesArgs
    tickets?: boolean | TenantCountOutputTypeCountTicketsArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSessionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUserPresencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPresenceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCashRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRegisterWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCreditNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPosSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPosQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSQuotationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountServiceTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTemplateWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    usersCreated: number
    usersUpdated: number
    auditLogs: number
    sessionLogs: number
    closedCashRegisters: number
    openedCashRegisters: number
    cashTransactions: number
    creditNotesCreated: number
    creditNotesProcessed: number
    createdCustomers: number
    updatedCustomers: number
    createdInvoices: number
    updatedInvoices: number
    invoiceHistory: number
    notifications: number
    createdParts: number
    updatedParts: number
    posSales: number
    posQuotations: number
    receivedPayments: number
    createdTemplates: number
    updatedTemplates: number
    specializations: number
    unavailabilities: number
    ticketNotes: number
    assignedTickets: number
    createdTickets: number
    updatedTickets: number
    uploadedAttachments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usersCreated?: boolean | UserCountOutputTypeCountUsersCreatedArgs
    usersUpdated?: boolean | UserCountOutputTypeCountUsersUpdatedArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    sessionLogs?: boolean | UserCountOutputTypeCountSessionLogsArgs
    closedCashRegisters?: boolean | UserCountOutputTypeCountClosedCashRegistersArgs
    openedCashRegisters?: boolean | UserCountOutputTypeCountOpenedCashRegistersArgs
    cashTransactions?: boolean | UserCountOutputTypeCountCashTransactionsArgs
    creditNotesCreated?: boolean | UserCountOutputTypeCountCreditNotesCreatedArgs
    creditNotesProcessed?: boolean | UserCountOutputTypeCountCreditNotesProcessedArgs
    createdCustomers?: boolean | UserCountOutputTypeCountCreatedCustomersArgs
    updatedCustomers?: boolean | UserCountOutputTypeCountUpdatedCustomersArgs
    createdInvoices?: boolean | UserCountOutputTypeCountCreatedInvoicesArgs
    updatedInvoices?: boolean | UserCountOutputTypeCountUpdatedInvoicesArgs
    invoiceHistory?: boolean | UserCountOutputTypeCountInvoiceHistoryArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    createdParts?: boolean | UserCountOutputTypeCountCreatedPartsArgs
    updatedParts?: boolean | UserCountOutputTypeCountUpdatedPartsArgs
    posSales?: boolean | UserCountOutputTypeCountPosSalesArgs
    posQuotations?: boolean | UserCountOutputTypeCountPosQuotationsArgs
    receivedPayments?: boolean | UserCountOutputTypeCountReceivedPaymentsArgs
    createdTemplates?: boolean | UserCountOutputTypeCountCreatedTemplatesArgs
    updatedTemplates?: boolean | UserCountOutputTypeCountUpdatedTemplatesArgs
    specializations?: boolean | UserCountOutputTypeCountSpecializationsArgs
    unavailabilities?: boolean | UserCountOutputTypeCountUnavailabilitiesArgs
    ticketNotes?: boolean | UserCountOutputTypeCountTicketNotesArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    createdTickets?: boolean | UserCountOutputTypeCountCreatedTicketsArgs
    updatedTickets?: boolean | UserCountOutputTypeCountUpdatedTicketsArgs
    uploadedAttachments?: boolean | UserCountOutputTypeCountUploadedAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsersUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClosedCashRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRegisterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOpenedCashRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRegisterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreditNotesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreditNotesProcessedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoiceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPosSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPosQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSQuotationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpecializationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicianSpecializationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUnavailabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicianUnavailabilityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    creditNotes: number
    invoices: number
    posSales: number
    posQuotations: number
    tickets: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNotes?: boolean | CustomerCountOutputTypeCountCreditNotesArgs
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
    posSales?: boolean | CustomerCountOutputTypeCountPosSalesArgs
    posQuotations?: boolean | CustomerCountOutputTypeCountPosQuotationsArgs
    tickets?: boolean | CustomerCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCreditNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPosSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPosQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSQuotationWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    attachments: number
    partsUsed: number
    notes: number
    services: number
    viewedByUsers: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | TicketCountOutputTypeCountAttachmentsArgs
    partsUsed?: boolean | TicketCountOutputTypeCountPartsUsedArgs
    notes?: boolean | TicketCountOutputTypeCountNotesArgs
    services?: boolean | TicketCountOutputTypeCountServicesArgs
    viewedByUsers?: boolean | TicketCountOutputTypeCountViewedByUsersArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountPartsUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartUsageWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketNoteWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketServiceWhereInput
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountViewedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPresenceWhereInput
  }


  /**
   * Count Type PartCountOutputType
   */

  export type PartCountOutputType = {
    creditNoteItems: number
    posQuotationItems: number
    posSaleItems: number
    purchaseItems: number
    templateDefaultParts: number
    usages: number
  }

  export type PartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNoteItems?: boolean | PartCountOutputTypeCountCreditNoteItemsArgs
    posQuotationItems?: boolean | PartCountOutputTypeCountPosQuotationItemsArgs
    posSaleItems?: boolean | PartCountOutputTypeCountPosSaleItemsArgs
    purchaseItems?: boolean | PartCountOutputTypeCountPurchaseItemsArgs
    templateDefaultParts?: boolean | PartCountOutputTypeCountTemplateDefaultPartsArgs
    usages?: boolean | PartCountOutputTypeCountUsagesArgs
  }

  // Custom InputTypes
  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartCountOutputType
     */
    select?: PartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountCreditNoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteItemWhereInput
  }

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountPosQuotationItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSQuotationItemWhereInput
  }

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountPosSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleItemWhereInput
  }

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountTemplateDefaultPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateDefaultPartWhereInput
  }

  /**
   * PartCountOutputType without action
   */
  export type PartCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartUsageWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
  }


  /**
   * Count Type ServiceTemplateCountOutputType
   */

  export type ServiceTemplateCountOutputType = {
    defaultParts: number
    usages: number
    tickets: number
  }

  export type ServiceTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultParts?: boolean | ServiceTemplateCountOutputTypeCountDefaultPartsArgs
    usages?: boolean | ServiceTemplateCountOutputTypeCountUsagesArgs
    tickets?: boolean | ServiceTemplateCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * ServiceTemplateCountOutputType without action
   */
  export type ServiceTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplateCountOutputType
     */
    select?: ServiceTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceTemplateCountOutputType without action
   */
  export type ServiceTemplateCountOutputTypeCountDefaultPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateDefaultPartWhereInput
  }

  /**
   * ServiceTemplateCountOutputType without action
   */
  export type ServiceTemplateCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketServiceWhereInput
  }

  /**
   * ServiceTemplateCountOutputType without action
   */
  export type ServiceTemplateCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    history: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | InvoiceCountOutputTypeCountHistoryArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceHistoryWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type CashRegisterCountOutputType
   */

  export type CashRegisterCountOutputType = {
    posSales: number
    transactions: number
  }

  export type CashRegisterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posSales?: boolean | CashRegisterCountOutputTypeCountPosSalesArgs
    transactions?: boolean | CashRegisterCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegisterCountOutputType
     */
    select?: CashRegisterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeCountPosSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleWhereInput
  }

  /**
   * CashRegisterCountOutputType without action
   */
  export type CashRegisterCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }


  /**
   * Count Type POSSaleCountOutputType
   */

  export type POSSaleCountOutputType = {
    creditNotes: number
    items: number
    payments: number
  }

  export type POSSaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNotes?: boolean | POSSaleCountOutputTypeCountCreditNotesArgs
    items?: boolean | POSSaleCountOutputTypeCountItemsArgs
    payments?: boolean | POSSaleCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * POSSaleCountOutputType without action
   */
  export type POSSaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleCountOutputType
     */
    select?: POSSaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * POSSaleCountOutputType without action
   */
  export type POSSaleCountOutputTypeCountCreditNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteWhereInput
  }

  /**
   * POSSaleCountOutputType without action
   */
  export type POSSaleCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleItemWhereInput
  }

  /**
   * POSSaleCountOutputType without action
   */
  export type POSSaleCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSalePaymentWhereInput
  }


  /**
   * Count Type POSQuotationCountOutputType
   */

  export type POSQuotationCountOutputType = {
    items: number
  }

  export type POSQuotationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | POSQuotationCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * POSQuotationCountOutputType without action
   */
  export type POSQuotationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationCountOutputType
     */
    select?: POSQuotationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * POSQuotationCountOutputType without action
   */
  export type POSQuotationCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSQuotationItemWhereInput
  }


  /**
   * Count Type CreditNoteCountOutputType
   */

  export type CreditNoteCountOutputType = {
    items: number
  }

  export type CreditNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CreditNoteCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CreditNoteCountOutputType without action
   */
  export type CreditNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteCountOutputType
     */
    select?: CreditNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreditNoteCountOutputType without action
   */
  export type CreditNoteCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    adminUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    adminUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    adminUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    adminUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    adminUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    adminUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    slug: string
    adminUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    adminUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    sessionLogs?: boolean | Tenant$sessionLogsArgs<ExtArgs>
    userPresences?: boolean | Tenant$userPresencesArgs<ExtArgs>
    cashRegisters?: boolean | Tenant$cashRegistersArgs<ExtArgs>
    cashTransactions?: boolean | Tenant$cashTransactionsArgs<ExtArgs>
    creditNotes?: boolean | Tenant$creditNotesArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    parts?: boolean | Tenant$partsArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    posSales?: boolean | Tenant$posSalesArgs<ExtArgs>
    posQuotations?: boolean | Tenant$posQuotationsArgs<ExtArgs>
    purchaseOrders?: boolean | Tenant$purchaseOrdersArgs<ExtArgs>
    serviceTemplates?: boolean | Tenant$serviceTemplatesArgs<ExtArgs>
    settings?: boolean | Tenant$settingsArgs<ExtArgs>
    tickets?: boolean | Tenant$ticketsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    adminUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    adminUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    adminUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "adminUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    sessionLogs?: boolean | Tenant$sessionLogsArgs<ExtArgs>
    userPresences?: boolean | Tenant$userPresencesArgs<ExtArgs>
    cashRegisters?: boolean | Tenant$cashRegistersArgs<ExtArgs>
    cashTransactions?: boolean | Tenant$cashTransactionsArgs<ExtArgs>
    creditNotes?: boolean | Tenant$creditNotesArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    parts?: boolean | Tenant$partsArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    posSales?: boolean | Tenant$posSalesArgs<ExtArgs>
    posQuotations?: boolean | Tenant$posQuotationsArgs<ExtArgs>
    purchaseOrders?: boolean | Tenant$purchaseOrdersArgs<ExtArgs>
    serviceTemplates?: boolean | Tenant$serviceTemplatesArgs<ExtArgs>
    settings?: boolean | Tenant$settingsArgs<ExtArgs>
    tickets?: boolean | Tenant$ticketsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      sessionLogs: Prisma.$SessionLogPayload<ExtArgs>[]
      userPresences: Prisma.$UserPresencePayload<ExtArgs>[]
      cashRegisters: Prisma.$CashRegisterPayload<ExtArgs>[]
      cashTransactions: Prisma.$CashTransactionPayload<ExtArgs>[]
      creditNotes: Prisma.$CreditNotePayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      parts: Prisma.$PartPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      posSales: Prisma.$POSSalePayload<ExtArgs>[]
      posQuotations: Prisma.$POSQuotationPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      serviceTemplates: Prisma.$ServiceTemplatePayload<ExtArgs>[]
      settings: Prisma.$TenantSettingsPayload<ExtArgs> | null
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      adminUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionLogs<T extends Tenant$sessionLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$sessionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPresences<T extends Tenant$userPresencesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$userPresencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashRegisters<T extends Tenant$cashRegistersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cashRegistersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashTransactions<T extends Tenant$cashTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$cashTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditNotes<T extends Tenant$creditNotesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$creditNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Tenant$customersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Tenant$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Tenant$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parts<T extends Tenant$partsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Tenant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posSales<T extends Tenant$posSalesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$posSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posQuotations<T extends Tenant$posQuotationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$posQuotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Tenant$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceTemplates<T extends Tenant$serviceTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$serviceTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends Tenant$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$settingsArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tickets<T extends Tenant$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly adminUserId: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant.sessionLogs
   */
  export type Tenant$sessionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    where?: SessionLogWhereInput
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    cursor?: SessionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * Tenant.userPresences
   */
  export type Tenant$userPresencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    where?: UserPresenceWhereInput
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    cursor?: UserPresenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * Tenant.cashRegisters
   */
  export type Tenant$cashRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    where?: CashRegisterWhereInput
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    cursor?: CashRegisterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * Tenant.cashTransactions
   */
  export type Tenant$cashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * Tenant.creditNotes
   */
  export type Tenant$creditNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    where?: CreditNoteWhereInput
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    cursor?: CreditNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteScalarFieldEnum | CreditNoteScalarFieldEnum[]
  }

  /**
   * Tenant.customers
   */
  export type Tenant$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Tenant.invoices
   */
  export type Tenant$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.notifications
   */
  export type Tenant$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Tenant.parts
   */
  export type Tenant$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    cursor?: PartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * Tenant.payments
   */
  export type Tenant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Tenant.posSales
   */
  export type Tenant$posSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    where?: POSSaleWhereInput
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    cursor?: POSSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * Tenant.posQuotations
   */
  export type Tenant$posQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    where?: POSQuotationWhereInput
    orderBy?: POSQuotationOrderByWithRelationInput | POSQuotationOrderByWithRelationInput[]
    cursor?: POSQuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSQuotationScalarFieldEnum | POSQuotationScalarFieldEnum[]
  }

  /**
   * Tenant.purchaseOrders
   */
  export type Tenant$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Tenant.serviceTemplates
   */
  export type Tenant$serviceTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    where?: ServiceTemplateWhereInput
    orderBy?: ServiceTemplateOrderByWithRelationInput | ServiceTemplateOrderByWithRelationInput[]
    cursor?: ServiceTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceTemplateScalarFieldEnum | ServiceTemplateScalarFieldEnum[]
  }

  /**
   * Tenant.settings
   */
  export type Tenant$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    where?: TenantSettingsWhereInput
  }

  /**
   * Tenant.tickets
   */
  export type Tenant$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLoginAttempts: number | null
    maxConcurrentTickets: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLoginAttempts: number | null
    maxConcurrentTickets: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    role: $Enums.UserRole | null
    tenantId: string | null
    isActive: boolean | null
    passwordMustChange: boolean | null
    lastLoginAt: Date | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.TechnicianStatus | null
    maxConcurrentTickets: number | null
    statusReason: string | null
    availableFrom: Date | null
    availableUntil: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    role: $Enums.UserRole | null
    tenantId: string | null
    isActive: boolean | null
    passwordMustChange: boolean | null
    lastLoginAt: Date | null
    failedLoginAttempts: number | null
    lockedUntil: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.TechnicianStatus | null
    maxConcurrentTickets: number | null
    statusReason: string | null
    availableFrom: Date | null
    availableUntil: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    name: number
    role: number
    tenantId: number
    isActive: number
    passwordMustChange: number
    lastLoginAt: number
    failedLoginAttempts: number
    lockedUntil: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    status: number
    maxConcurrentTickets: number
    statusReason: number
    availableFrom: number
    availableUntil: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLoginAttempts?: true
    maxConcurrentTickets?: true
  }

  export type UserSumAggregateInputType = {
    failedLoginAttempts?: true
    maxConcurrentTickets?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    name?: true
    role?: true
    tenantId?: true
    isActive?: true
    passwordMustChange?: true
    lastLoginAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    maxConcurrentTickets?: true
    statusReason?: true
    availableFrom?: true
    availableUntil?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    name?: true
    role?: true
    tenantId?: true
    isActive?: true
    passwordMustChange?: true
    lastLoginAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    maxConcurrentTickets?: true
    statusReason?: true
    availableFrom?: true
    availableUntil?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    name?: true
    role?: true
    tenantId?: true
    isActive?: true
    passwordMustChange?: true
    lastLoginAt?: true
    failedLoginAttempts?: true
    lockedUntil?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    maxConcurrentTickets?: true
    statusReason?: true
    availableFrom?: true
    availableUntil?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string | null
    lastName: string | null
    name: string | null
    role: $Enums.UserRole
    tenantId: string
    isActive: boolean
    passwordMustChange: boolean
    lastLoginAt: Date | null
    failedLoginAttempts: number
    lockedUntil: Date | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    status: $Enums.TechnicianStatus
    maxConcurrentTickets: number
    statusReason: string | null
    availableFrom: Date | null
    availableUntil: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    role?: boolean
    tenantId?: boolean
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    maxConcurrentTickets?: boolean
    statusReason?: boolean
    availableFrom?: boolean
    availableUntil?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    usersCreated?: boolean | User$usersCreatedArgs<ExtArgs>
    usersUpdated?: boolean | User$usersUpdatedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sessionLogs?: boolean | User$sessionLogsArgs<ExtArgs>
    presence?: boolean | User$presenceArgs<ExtArgs>
    closedCashRegisters?: boolean | User$closedCashRegistersArgs<ExtArgs>
    openedCashRegisters?: boolean | User$openedCashRegistersArgs<ExtArgs>
    cashTransactions?: boolean | User$cashTransactionsArgs<ExtArgs>
    creditNotesCreated?: boolean | User$creditNotesCreatedArgs<ExtArgs>
    creditNotesProcessed?: boolean | User$creditNotesProcessedArgs<ExtArgs>
    createdCustomers?: boolean | User$createdCustomersArgs<ExtArgs>
    updatedCustomers?: boolean | User$updatedCustomersArgs<ExtArgs>
    createdInvoices?: boolean | User$createdInvoicesArgs<ExtArgs>
    updatedInvoices?: boolean | User$updatedInvoicesArgs<ExtArgs>
    invoiceHistory?: boolean | User$invoiceHistoryArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    createdParts?: boolean | User$createdPartsArgs<ExtArgs>
    updatedParts?: boolean | User$updatedPartsArgs<ExtArgs>
    posSales?: boolean | User$posSalesArgs<ExtArgs>
    posQuotations?: boolean | User$posQuotationsArgs<ExtArgs>
    receivedPayments?: boolean | User$receivedPaymentsArgs<ExtArgs>
    createdTemplates?: boolean | User$createdTemplatesArgs<ExtArgs>
    updatedTemplates?: boolean | User$updatedTemplatesArgs<ExtArgs>
    specializations?: boolean | User$specializationsArgs<ExtArgs>
    unavailabilities?: boolean | User$unavailabilitiesArgs<ExtArgs>
    ticketNotes?: boolean | User$ticketNotesArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    createdTickets?: boolean | User$createdTicketsArgs<ExtArgs>
    updatedTickets?: boolean | User$updatedTicketsArgs<ExtArgs>
    uploadedAttachments?: boolean | User$uploadedAttachmentsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    role?: boolean
    tenantId?: boolean
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    maxConcurrentTickets?: boolean
    statusReason?: boolean
    availableFrom?: boolean
    availableUntil?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    role?: boolean
    tenantId?: boolean
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    maxConcurrentTickets?: boolean
    statusReason?: boolean
    availableFrom?: boolean
    availableUntil?: boolean
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    role?: boolean
    tenantId?: boolean
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: boolean
    failedLoginAttempts?: boolean
    lockedUntil?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    maxConcurrentTickets?: boolean
    statusReason?: boolean
    availableFrom?: boolean
    availableUntil?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "name" | "role" | "tenantId" | "isActive" | "passwordMustChange" | "lastLoginAt" | "failedLoginAttempts" | "lockedUntil" | "createdById" | "updatedById" | "createdAt" | "updatedAt" | "status" | "maxConcurrentTickets" | "statusReason" | "availableFrom" | "availableUntil", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    usersCreated?: boolean | User$usersCreatedArgs<ExtArgs>
    usersUpdated?: boolean | User$usersUpdatedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sessionLogs?: boolean | User$sessionLogsArgs<ExtArgs>
    presence?: boolean | User$presenceArgs<ExtArgs>
    closedCashRegisters?: boolean | User$closedCashRegistersArgs<ExtArgs>
    openedCashRegisters?: boolean | User$openedCashRegistersArgs<ExtArgs>
    cashTransactions?: boolean | User$cashTransactionsArgs<ExtArgs>
    creditNotesCreated?: boolean | User$creditNotesCreatedArgs<ExtArgs>
    creditNotesProcessed?: boolean | User$creditNotesProcessedArgs<ExtArgs>
    createdCustomers?: boolean | User$createdCustomersArgs<ExtArgs>
    updatedCustomers?: boolean | User$updatedCustomersArgs<ExtArgs>
    createdInvoices?: boolean | User$createdInvoicesArgs<ExtArgs>
    updatedInvoices?: boolean | User$updatedInvoicesArgs<ExtArgs>
    invoiceHistory?: boolean | User$invoiceHistoryArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    createdParts?: boolean | User$createdPartsArgs<ExtArgs>
    updatedParts?: boolean | User$updatedPartsArgs<ExtArgs>
    posSales?: boolean | User$posSalesArgs<ExtArgs>
    posQuotations?: boolean | User$posQuotationsArgs<ExtArgs>
    receivedPayments?: boolean | User$receivedPaymentsArgs<ExtArgs>
    createdTemplates?: boolean | User$createdTemplatesArgs<ExtArgs>
    updatedTemplates?: boolean | User$updatedTemplatesArgs<ExtArgs>
    specializations?: boolean | User$specializationsArgs<ExtArgs>
    unavailabilities?: boolean | User$unavailabilitiesArgs<ExtArgs>
    ticketNotes?: boolean | User$ticketNotesArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    createdTickets?: boolean | User$createdTicketsArgs<ExtArgs>
    updatedTickets?: boolean | User$updatedTicketsArgs<ExtArgs>
    uploadedAttachments?: boolean | User$uploadedAttachmentsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | User$createdByArgs<ExtArgs>
    updatedBy?: boolean | User$updatedByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      usersCreated: Prisma.$UserPayload<ExtArgs>[]
      usersUpdated: Prisma.$UserPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      sessionLogs: Prisma.$SessionLogPayload<ExtArgs>[]
      presence: Prisma.$UserPresencePayload<ExtArgs> | null
      closedCashRegisters: Prisma.$CashRegisterPayload<ExtArgs>[]
      openedCashRegisters: Prisma.$CashRegisterPayload<ExtArgs>[]
      cashTransactions: Prisma.$CashTransactionPayload<ExtArgs>[]
      creditNotesCreated: Prisma.$CreditNotePayload<ExtArgs>[]
      creditNotesProcessed: Prisma.$CreditNotePayload<ExtArgs>[]
      createdCustomers: Prisma.$CustomerPayload<ExtArgs>[]
      updatedCustomers: Prisma.$CustomerPayload<ExtArgs>[]
      createdInvoices: Prisma.$InvoicePayload<ExtArgs>[]
      updatedInvoices: Prisma.$InvoicePayload<ExtArgs>[]
      invoiceHistory: Prisma.$InvoiceHistoryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      createdParts: Prisma.$PartPayload<ExtArgs>[]
      updatedParts: Prisma.$PartPayload<ExtArgs>[]
      posSales: Prisma.$POSSalePayload<ExtArgs>[]
      posQuotations: Prisma.$POSQuotationPayload<ExtArgs>[]
      receivedPayments: Prisma.$PaymentPayload<ExtArgs>[]
      createdTemplates: Prisma.$ServiceTemplatePayload<ExtArgs>[]
      updatedTemplates: Prisma.$ServiceTemplatePayload<ExtArgs>[]
      specializations: Prisma.$TechnicianSpecializationPayload<ExtArgs>[]
      unavailabilities: Prisma.$TechnicianUnavailabilityPayload<ExtArgs>[]
      ticketNotes: Prisma.$TicketNotePayload<ExtArgs>[]
      assignedTickets: Prisma.$TicketPayload<ExtArgs>[]
      createdTickets: Prisma.$TicketPayload<ExtArgs>[]
      updatedTickets: Prisma.$TicketPayload<ExtArgs>[]
      uploadedAttachments: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string | null
      lastName: string | null
      name: string | null
      role: $Enums.UserRole
      tenantId: string
      isActive: boolean
      passwordMustChange: boolean
      lastLoginAt: Date | null
      failedLoginAttempts: number
      lockedUntil: Date | null
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
      status: $Enums.TechnicianStatus
      maxConcurrentTickets: number
      statusReason: string | null
      availableFrom: Date | null
      availableUntil: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends User$createdByArgs<ExtArgs> = {}>(args?: Subset<T, User$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends User$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usersCreated<T extends User$usersCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$usersCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usersUpdated<T extends User$usersUpdatedArgs<ExtArgs> = {}>(args?: Subset<T, User$usersUpdatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionLogs<T extends User$sessionLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    presence<T extends User$presenceArgs<ExtArgs> = {}>(args?: Subset<T, User$presenceArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    closedCashRegisters<T extends User$closedCashRegistersArgs<ExtArgs> = {}>(args?: Subset<T, User$closedCashRegistersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    openedCashRegisters<T extends User$openedCashRegistersArgs<ExtArgs> = {}>(args?: Subset<T, User$openedCashRegistersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashTransactions<T extends User$cashTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$cashTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditNotesCreated<T extends User$creditNotesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$creditNotesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditNotesProcessed<T extends User$creditNotesProcessedArgs<ExtArgs> = {}>(args?: Subset<T, User$creditNotesProcessedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCustomers<T extends User$createdCustomersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedCustomers<T extends User$updatedCustomersArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdInvoices<T extends User$createdInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedInvoices<T extends User$updatedInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoiceHistory<T extends User$invoiceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$invoiceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdParts<T extends User$createdPartsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedParts<T extends User$updatedPartsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedPartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posSales<T extends User$posSalesArgs<ExtArgs> = {}>(args?: Subset<T, User$posSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posQuotations<T extends User$posQuotationsArgs<ExtArgs> = {}>(args?: Subset<T, User$posQuotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedPayments<T extends User$receivedPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTemplates<T extends User$createdTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedTemplates<T extends User$updatedTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specializations<T extends User$specializationsArgs<ExtArgs> = {}>(args?: Subset<T, User$specializationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unavailabilities<T extends User$unavailabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$unavailabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketNotes<T extends User$ticketNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTickets<T extends User$createdTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedTickets<T extends User$updatedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedAttachments<T extends User$uploadedAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly passwordMustChange: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly failedLoginAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly createdById: FieldRef<"User", 'String'>
    readonly updatedById: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly status: FieldRef<"User", 'TechnicianStatus'>
    readonly maxConcurrentTickets: FieldRef<"User", 'Int'>
    readonly statusReason: FieldRef<"User", 'String'>
    readonly availableFrom: FieldRef<"User", 'DateTime'>
    readonly availableUntil: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.createdBy
   */
  export type User$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.updatedBy
   */
  export type User$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.usersCreated
   */
  export type User$usersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.usersUpdated
   */
  export type User$usersUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.sessionLogs
   */
  export type User$sessionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    where?: SessionLogWhereInput
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    cursor?: SessionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * User.presence
   */
  export type User$presenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    where?: UserPresenceWhereInput
  }

  /**
   * User.closedCashRegisters
   */
  export type User$closedCashRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    where?: CashRegisterWhereInput
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    cursor?: CashRegisterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * User.openedCashRegisters
   */
  export type User$openedCashRegistersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    where?: CashRegisterWhereInput
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    cursor?: CashRegisterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * User.cashTransactions
   */
  export type User$cashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * User.creditNotesCreated
   */
  export type User$creditNotesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    where?: CreditNoteWhereInput
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    cursor?: CreditNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteScalarFieldEnum | CreditNoteScalarFieldEnum[]
  }

  /**
   * User.creditNotesProcessed
   */
  export type User$creditNotesProcessedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    where?: CreditNoteWhereInput
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    cursor?: CreditNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteScalarFieldEnum | CreditNoteScalarFieldEnum[]
  }

  /**
   * User.createdCustomers
   */
  export type User$createdCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * User.updatedCustomers
   */
  export type User$updatedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * User.createdInvoices
   */
  export type User$createdInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.updatedInvoices
   */
  export type User$updatedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.invoiceHistory
   */
  export type User$invoiceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    where?: InvoiceHistoryWhereInput
    orderBy?: InvoiceHistoryOrderByWithRelationInput | InvoiceHistoryOrderByWithRelationInput[]
    cursor?: InvoiceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceHistoryScalarFieldEnum | InvoiceHistoryScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.createdParts
   */
  export type User$createdPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    cursor?: PartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * User.updatedParts
   */
  export type User$updatedPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    where?: PartWhereInput
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    cursor?: PartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * User.posSales
   */
  export type User$posSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    where?: POSSaleWhereInput
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    cursor?: POSSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * User.posQuotations
   */
  export type User$posQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    where?: POSQuotationWhereInput
    orderBy?: POSQuotationOrderByWithRelationInput | POSQuotationOrderByWithRelationInput[]
    cursor?: POSQuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSQuotationScalarFieldEnum | POSQuotationScalarFieldEnum[]
  }

  /**
   * User.receivedPayments
   */
  export type User$receivedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.createdTemplates
   */
  export type User$createdTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    where?: ServiceTemplateWhereInput
    orderBy?: ServiceTemplateOrderByWithRelationInput | ServiceTemplateOrderByWithRelationInput[]
    cursor?: ServiceTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceTemplateScalarFieldEnum | ServiceTemplateScalarFieldEnum[]
  }

  /**
   * User.updatedTemplates
   */
  export type User$updatedTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    where?: ServiceTemplateWhereInput
    orderBy?: ServiceTemplateOrderByWithRelationInput | ServiceTemplateOrderByWithRelationInput[]
    cursor?: ServiceTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceTemplateScalarFieldEnum | ServiceTemplateScalarFieldEnum[]
  }

  /**
   * User.specializations
   */
  export type User$specializationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    where?: TechnicianSpecializationWhereInput
    orderBy?: TechnicianSpecializationOrderByWithRelationInput | TechnicianSpecializationOrderByWithRelationInput[]
    cursor?: TechnicianSpecializationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicianSpecializationScalarFieldEnum | TechnicianSpecializationScalarFieldEnum[]
  }

  /**
   * User.unavailabilities
   */
  export type User$unavailabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    where?: TechnicianUnavailabilityWhereInput
    orderBy?: TechnicianUnavailabilityOrderByWithRelationInput | TechnicianUnavailabilityOrderByWithRelationInput[]
    cursor?: TechnicianUnavailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnicianUnavailabilityScalarFieldEnum | TechnicianUnavailabilityScalarFieldEnum[]
  }

  /**
   * User.ticketNotes
   */
  export type User$ticketNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    where?: TicketNoteWhereInput
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    cursor?: TicketNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.createdTickets
   */
  export type User$createdTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.updatedTickets
   */
  export type User$updatedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.uploadedAttachments
   */
  export type User$uploadedAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    dpi: string | null
    nit: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    dpi: string | null
    nit: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    tenantId: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    dpi: number
    nit: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    dpi?: true
    nit?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    dpi?: true
    nit?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    dpi?: true
    nit?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    dpi: string | null
    nit: string | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    dpi?: boolean
    nit?: boolean
    createdBy?: boolean | Customer$createdByArgs<ExtArgs>
    creditNotes?: boolean | Customer$creditNotesArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    posSales?: boolean | Customer$posSalesArgs<ExtArgs>
    posQuotations?: boolean | Customer$posQuotationsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tickets?: boolean | Customer$ticketsArgs<ExtArgs>
    updatedBy?: boolean | Customer$updatedByArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    dpi?: boolean
    nit?: boolean
    createdBy?: boolean | Customer$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Customer$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    dpi?: boolean
    nit?: boolean
    createdBy?: boolean | Customer$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Customer$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    dpi?: boolean
    nit?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "address" | "tenantId" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "dpi" | "nit", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Customer$createdByArgs<ExtArgs>
    creditNotes?: boolean | Customer$creditNotesArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    posSales?: boolean | Customer$posSalesArgs<ExtArgs>
    posQuotations?: boolean | Customer$posQuotationsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tickets?: boolean | Customer$ticketsArgs<ExtArgs>
    updatedBy?: boolean | Customer$updatedByArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Customer$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Customer$updatedByArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Customer$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Customer$updatedByArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      creditNotes: Prisma.$CreditNotePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      posSales: Prisma.$POSSalePayload<ExtArgs>[]
      posQuotations: Prisma.$POSQuotationPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
      dpi: string | null
      nit: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Customer$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Customer$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creditNotes<T extends Customer$creditNotesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$creditNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posSales<T extends Customer$posSalesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$posSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posQuotations<T extends Customer$posQuotationsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$posQuotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tickets<T extends Customer$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedBy<T extends Customer$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Customer$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly tenantId: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly createdById: FieldRef<"Customer", 'String'>
    readonly updatedById: FieldRef<"Customer", 'String'>
    readonly dpi: FieldRef<"Customer", 'String'>
    readonly nit: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.createdBy
   */
  export type Customer$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Customer.creditNotes
   */
  export type Customer$creditNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    where?: CreditNoteWhereInput
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    cursor?: CreditNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteScalarFieldEnum | CreditNoteScalarFieldEnum[]
  }

  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Customer.posSales
   */
  export type Customer$posSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    where?: POSSaleWhereInput
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    cursor?: POSSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * Customer.posQuotations
   */
  export type Customer$posQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    where?: POSQuotationWhereInput
    orderBy?: POSQuotationOrderByWithRelationInput | POSQuotationOrderByWithRelationInput[]
    cursor?: POSQuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSQuotationScalarFieldEnum | POSQuotationScalarFieldEnum[]
  }

  /**
   * Customer.tickets
   */
  export type Customer$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Customer.updatedBy
   */
  export type Customer$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    ticketNumber: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    tenantId: string | null
    customerId: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accessories: string | null
    cancellationReason: string | null
    checkInNotes: string | null
    deviceModel: string | null
    deviceType: string | null
    serialNumber: string | null
    createdById: string | null
    serviceTemplateId: string | null
    updatedById: string | null
    priority: $Enums.TicketPriority | null
    dueDate: Date | null
    estimatedCompletionDate: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    ticketNumber: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    tenantId: string | null
    customerId: string | null
    assignedToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accessories: string | null
    cancellationReason: string | null
    checkInNotes: string | null
    deviceModel: string | null
    deviceType: string | null
    serialNumber: string | null
    createdById: string | null
    serviceTemplateId: string | null
    updatedById: string | null
    priority: $Enums.TicketPriority | null
    dueDate: Date | null
    estimatedCompletionDate: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    ticketNumber: number
    title: number
    description: number
    status: number
    tenantId: number
    customerId: number
    assignedToId: number
    createdAt: number
    updatedAt: number
    accessories: number
    cancellationReason: number
    checkInNotes: number
    deviceModel: number
    deviceType: number
    serialNumber: number
    createdById: number
    serviceTemplateId: number
    updatedById: number
    priority: number
    dueDate: number
    estimatedCompletionDate: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    status?: true
    tenantId?: true
    customerId?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    accessories?: true
    cancellationReason?: true
    checkInNotes?: true
    deviceModel?: true
    deviceType?: true
    serialNumber?: true
    createdById?: true
    serviceTemplateId?: true
    updatedById?: true
    priority?: true
    dueDate?: true
    estimatedCompletionDate?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    status?: true
    tenantId?: true
    customerId?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    accessories?: true
    cancellationReason?: true
    checkInNotes?: true
    deviceModel?: true
    deviceType?: true
    serialNumber?: true
    createdById?: true
    serviceTemplateId?: true
    updatedById?: true
    priority?: true
    dueDate?: true
    estimatedCompletionDate?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    status?: true
    tenantId?: true
    customerId?: true
    assignedToId?: true
    createdAt?: true
    updatedAt?: true
    accessories?: true
    cancellationReason?: true
    checkInNotes?: true
    deviceModel?: true
    deviceType?: true
    serialNumber?: true
    createdById?: true
    serviceTemplateId?: true
    updatedById?: true
    priority?: true
    dueDate?: true
    estimatedCompletionDate?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    ticketNumber: string | null
    title: string
    description: string
    status: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId: string | null
    createdAt: Date
    updatedAt: Date
    accessories: string | null
    cancellationReason: string | null
    checkInNotes: string | null
    deviceModel: string | null
    deviceType: string | null
    serialNumber: string | null
    createdById: string | null
    serviceTemplateId: string | null
    updatedById: string | null
    priority: $Enums.TicketPriority
    dueDate: Date | null
    estimatedCompletionDate: Date | null
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    tenantId?: boolean
    customerId?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessories?: boolean
    cancellationReason?: boolean
    checkInNotes?: boolean
    deviceModel?: boolean
    deviceType?: boolean
    serialNumber?: boolean
    createdById?: boolean
    serviceTemplateId?: boolean
    updatedById?: boolean
    priority?: boolean
    dueDate?: boolean
    estimatedCompletionDate?: boolean
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    invoice?: boolean | Ticket$invoiceArgs<ExtArgs>
    partsUsed?: boolean | Ticket$partsUsedArgs<ExtArgs>
    notes?: boolean | Ticket$notesArgs<ExtArgs>
    services?: boolean | Ticket$servicesArgs<ExtArgs>
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    createdBy?: boolean | Ticket$createdByArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    serviceTemplate?: boolean | Ticket$serviceTemplateArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Ticket$updatedByArgs<ExtArgs>
    viewedByUsers?: boolean | Ticket$viewedByUsersArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    tenantId?: boolean
    customerId?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessories?: boolean
    cancellationReason?: boolean
    checkInNotes?: boolean
    deviceModel?: boolean
    deviceType?: boolean
    serialNumber?: boolean
    createdById?: boolean
    serviceTemplateId?: boolean
    updatedById?: boolean
    priority?: boolean
    dueDate?: boolean
    estimatedCompletionDate?: boolean
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    createdBy?: boolean | Ticket$createdByArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    serviceTemplate?: boolean | Ticket$serviceTemplateArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Ticket$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    tenantId?: boolean
    customerId?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessories?: boolean
    cancellationReason?: boolean
    checkInNotes?: boolean
    deviceModel?: boolean
    deviceType?: boolean
    serialNumber?: boolean
    createdById?: boolean
    serviceTemplateId?: boolean
    updatedById?: boolean
    priority?: boolean
    dueDate?: boolean
    estimatedCompletionDate?: boolean
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    createdBy?: boolean | Ticket$createdByArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    serviceTemplate?: boolean | Ticket$serviceTemplateArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Ticket$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    tenantId?: boolean
    customerId?: boolean
    assignedToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessories?: boolean
    cancellationReason?: boolean
    checkInNotes?: boolean
    deviceModel?: boolean
    deviceType?: boolean
    serialNumber?: boolean
    createdById?: boolean
    serviceTemplateId?: boolean
    updatedById?: boolean
    priority?: boolean
    dueDate?: boolean
    estimatedCompletionDate?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketNumber" | "title" | "description" | "status" | "tenantId" | "customerId" | "assignedToId" | "createdAt" | "updatedAt" | "accessories" | "cancellationReason" | "checkInNotes" | "deviceModel" | "deviceType" | "serialNumber" | "createdById" | "serviceTemplateId" | "updatedById" | "priority" | "dueDate" | "estimatedCompletionDate", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | Ticket$attachmentsArgs<ExtArgs>
    invoice?: boolean | Ticket$invoiceArgs<ExtArgs>
    partsUsed?: boolean | Ticket$partsUsedArgs<ExtArgs>
    notes?: boolean | Ticket$notesArgs<ExtArgs>
    services?: boolean | Ticket$servicesArgs<ExtArgs>
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    createdBy?: boolean | Ticket$createdByArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    serviceTemplate?: boolean | Ticket$serviceTemplateArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Ticket$updatedByArgs<ExtArgs>
    viewedByUsers?: boolean | Ticket$viewedByUsersArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    createdBy?: boolean | Ticket$createdByArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    serviceTemplate?: boolean | Ticket$serviceTemplateArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Ticket$updatedByArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Ticket$assignedToArgs<ExtArgs>
    createdBy?: boolean | Ticket$createdByArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    serviceTemplate?: boolean | Ticket$serviceTemplateArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Ticket$updatedByArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      attachments: Prisma.$TicketAttachmentPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      partsUsed: Prisma.$PartUsagePayload<ExtArgs>[]
      notes: Prisma.$TicketNotePayload<ExtArgs>[]
      services: Prisma.$TicketServicePayload<ExtArgs>[]
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs>
      serviceTemplate: Prisma.$ServiceTemplatePayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      viewedByUsers: Prisma.$UserPresencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketNumber: string | null
      title: string
      description: string
      status: $Enums.TicketStatus
      tenantId: string
      customerId: string
      assignedToId: string | null
      createdAt: Date
      updatedAt: Date
      accessories: string | null
      cancellationReason: string | null
      checkInNotes: string | null
      deviceModel: string | null
      deviceType: string | null
      serialNumber: string | null
      createdById: string | null
      serviceTemplateId: string | null
      updatedById: string | null
      priority: $Enums.TicketPriority
      dueDate: Date | null
      estimatedCompletionDate: Date | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachments<T extends Ticket$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Ticket$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    partsUsed<T extends Ticket$partsUsedArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$partsUsedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends Ticket$notesArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Ticket$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTo<T extends Ticket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Ticket$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceTemplate<T extends Ticket$serviceTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$serviceTemplateArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Ticket$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    viewedByUsers<T extends Ticket$viewedByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$viewedByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly ticketNumber: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly tenantId: FieldRef<"Ticket", 'String'>
    readonly customerId: FieldRef<"Ticket", 'String'>
    readonly assignedToId: FieldRef<"Ticket", 'String'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly accessories: FieldRef<"Ticket", 'String'>
    readonly cancellationReason: FieldRef<"Ticket", 'String'>
    readonly checkInNotes: FieldRef<"Ticket", 'String'>
    readonly deviceModel: FieldRef<"Ticket", 'String'>
    readonly deviceType: FieldRef<"Ticket", 'String'>
    readonly serialNumber: FieldRef<"Ticket", 'String'>
    readonly createdById: FieldRef<"Ticket", 'String'>
    readonly serviceTemplateId: FieldRef<"Ticket", 'String'>
    readonly updatedById: FieldRef<"Ticket", 'String'>
    readonly priority: FieldRef<"Ticket", 'TicketPriority'>
    readonly dueDate: FieldRef<"Ticket", 'DateTime'>
    readonly estimatedCompletionDate: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.attachments
   */
  export type Ticket$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    cursor?: TicketAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * Ticket.invoice
   */
  export type Ticket$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Ticket.partsUsed
   */
  export type Ticket$partsUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    where?: PartUsageWhereInput
    orderBy?: PartUsageOrderByWithRelationInput | PartUsageOrderByWithRelationInput[]
    cursor?: PartUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartUsageScalarFieldEnum | PartUsageScalarFieldEnum[]
  }

  /**
   * Ticket.notes
   */
  export type Ticket$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    where?: TicketNoteWhereInput
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    cursor?: TicketNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
  }

  /**
   * Ticket.services
   */
  export type Ticket$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    where?: TicketServiceWhereInput
    orderBy?: TicketServiceOrderByWithRelationInput | TicketServiceOrderByWithRelationInput[]
    cursor?: TicketServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketServiceScalarFieldEnum | TicketServiceScalarFieldEnum[]
  }

  /**
   * Ticket.assignedTo
   */
  export type Ticket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.createdBy
   */
  export type Ticket$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.serviceTemplate
   */
  export type Ticket$serviceTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    where?: ServiceTemplateWhereInput
  }

  /**
   * Ticket.updatedBy
   */
  export type Ticket$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.viewedByUsers
   */
  export type Ticket$viewedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    where?: UserPresenceWhereInput
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    cursor?: UserPresenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketAttachment
   */

  export type AggregateTicketAttachment = {
    _count: TicketAttachmentCountAggregateOutputType | null
    _avg: TicketAttachmentAvgAggregateOutputType | null
    _sum: TicketAttachmentSumAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  export type TicketAttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type TicketAttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type TicketAttachmentMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type TicketAttachmentMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type TicketAttachmentCountAggregateOutputType = {
    id: number
    ticketId: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    url: number
    uploadedById: number
    createdAt: number
    _all: number
  }


  export type TicketAttachmentAvgAggregateInputType = {
    size?: true
  }

  export type TicketAttachmentSumAggregateInputType = {
    size?: true
  }

  export type TicketAttachmentMinAggregateInputType = {
    id?: true
    ticketId?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedById?: true
    createdAt?: true
  }

  export type TicketAttachmentMaxAggregateInputType = {
    id?: true
    ticketId?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedById?: true
    createdAt?: true
  }

  export type TicketAttachmentCountAggregateInputType = {
    id?: true
    ticketId?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedById?: true
    createdAt?: true
    _all?: true
  }

  export type TicketAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachment to aggregate.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketAttachments
    **/
    _count?: true | TicketAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type GetTicketAttachmentAggregateType<T extends TicketAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketAttachment[P]>
      : GetScalarType<T[P], AggregateTicketAttachment[P]>
  }




  export type TicketAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketAttachmentWhereInput
    orderBy?: TicketAttachmentOrderByWithAggregationInput | TicketAttachmentOrderByWithAggregationInput[]
    by: TicketAttachmentScalarFieldEnum[] | TicketAttachmentScalarFieldEnum
    having?: TicketAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketAttachmentCountAggregateInputType | true
    _avg?: TicketAttachmentAvgAggregateInputType
    _sum?: TicketAttachmentSumAggregateInputType
    _min?: TicketAttachmentMinAggregateInputType
    _max?: TicketAttachmentMaxAggregateInputType
  }

  export type TicketAttachmentGroupByOutputType = {
    id: string
    ticketId: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    uploadedById: string
    createdAt: Date
    _count: TicketAttachmentCountAggregateOutputType | null
    _avg: TicketAttachmentAvgAggregateOutputType | null
    _sum: TicketAttachmentSumAggregateOutputType | null
    _min: TicketAttachmentMinAggregateOutputType | null
    _max: TicketAttachmentMaxAggregateOutputType | null
  }

  type GetTicketAttachmentGroupByPayload<T extends TicketAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type TicketAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketAttachment"]>

  export type TicketAttachmentSelectScalar = {
    id?: boolean
    ticketId?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedById?: boolean
    createdAt?: boolean
  }

  export type TicketAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "filename" | "originalName" | "mimeType" | "size" | "url" | "uploadedById" | "createdAt", ExtArgs["result"]["ticketAttachment"]>
  export type TicketAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketAttachment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      filename: string
      originalName: string
      mimeType: string
      size: number
      url: string
      uploadedById: string
      createdAt: Date
    }, ExtArgs["result"]["ticketAttachment"]>
    composites: {}
  }

  type TicketAttachmentGetPayload<S extends boolean | null | undefined | TicketAttachmentDefaultArgs> = $Result.GetResult<Prisma.$TicketAttachmentPayload, S>

  type TicketAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketAttachmentCountAggregateInputType | true
    }

  export interface TicketAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketAttachment'], meta: { name: 'TicketAttachment' } }
    /**
     * Find zero or one TicketAttachment that matches the filter.
     * @param {TicketAttachmentFindUniqueArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketAttachmentFindUniqueArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketAttachmentFindUniqueOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketAttachmentFindFirstArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindFirstOrThrowArgs} args - Arguments to find a TicketAttachment
     * @example
     * // Get one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany()
     * 
     * // Get first 10 TicketAttachments
     * const ticketAttachments = await prisma.ticketAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketAttachmentFindManyArgs>(args?: SelectSubset<T, TicketAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketAttachment.
     * @param {TicketAttachmentCreateArgs} args - Arguments to create a TicketAttachment.
     * @example
     * // Create one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.create({
     *   data: {
     *     // ... data to create a TicketAttachment
     *   }
     * })
     * 
     */
    create<T extends TicketAttachmentCreateArgs>(args: SelectSubset<T, TicketAttachmentCreateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketAttachments.
     * @param {TicketAttachmentCreateManyArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketAttachmentCreateManyArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketAttachments and returns the data saved in the database.
     * @param {TicketAttachmentCreateManyAndReturnArgs} args - Arguments to create many TicketAttachments.
     * @example
     * // Create many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketAttachments and only return the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketAttachment.
     * @param {TicketAttachmentDeleteArgs} args - Arguments to delete one TicketAttachment.
     * @example
     * // Delete one TicketAttachment
     * const TicketAttachment = await prisma.ticketAttachment.delete({
     *   where: {
     *     // ... filter to delete one TicketAttachment
     *   }
     * })
     * 
     */
    delete<T extends TicketAttachmentDeleteArgs>(args: SelectSubset<T, TicketAttachmentDeleteArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketAttachment.
     * @param {TicketAttachmentUpdateArgs} args - Arguments to update one TicketAttachment.
     * @example
     * // Update one TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketAttachmentUpdateArgs>(args: SelectSubset<T, TicketAttachmentUpdateArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketAttachments.
     * @param {TicketAttachmentDeleteManyArgs} args - Arguments to filter TicketAttachments to delete.
     * @example
     * // Delete a few TicketAttachments
     * const { count } = await prisma.ticketAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketAttachmentDeleteManyArgs>(args?: SelectSubset<T, TicketAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketAttachmentUpdateManyArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketAttachments and returns the data updated in the database.
     * @param {TicketAttachmentUpdateManyAndReturnArgs} args - Arguments to update many TicketAttachments.
     * @example
     * // Update many TicketAttachments
     * const ticketAttachment = await prisma.ticketAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketAttachments and only return the `id`
     * const ticketAttachmentWithIdOnly = await prisma.ticketAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketAttachment.
     * @param {TicketAttachmentUpsertArgs} args - Arguments to update or create a TicketAttachment.
     * @example
     * // Update or create a TicketAttachment
     * const ticketAttachment = await prisma.ticketAttachment.upsert({
     *   create: {
     *     // ... data to create a TicketAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketAttachment we want to update
     *   }
     * })
     */
    upsert<T extends TicketAttachmentUpsertArgs>(args: SelectSubset<T, TicketAttachmentUpsertArgs<ExtArgs>>): Prisma__TicketAttachmentClient<$Result.GetResult<Prisma.$TicketAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentCountArgs} args - Arguments to filter TicketAttachments to count.
     * @example
     * // Count the number of TicketAttachments
     * const count = await prisma.ticketAttachment.count({
     *   where: {
     *     // ... the filter for the TicketAttachments we want to count
     *   }
     * })
    **/
    count<T extends TicketAttachmentCountArgs>(
      args?: Subset<T, TicketAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAttachmentAggregateArgs>(args: Subset<T, TicketAttachmentAggregateArgs>): Prisma.PrismaPromise<GetTicketAttachmentAggregateType<T>>

    /**
     * Group by TicketAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: TicketAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketAttachment model
   */
  readonly fields: TicketAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketAttachment model
   */
  interface TicketAttachmentFieldRefs {
    readonly id: FieldRef<"TicketAttachment", 'String'>
    readonly ticketId: FieldRef<"TicketAttachment", 'String'>
    readonly filename: FieldRef<"TicketAttachment", 'String'>
    readonly originalName: FieldRef<"TicketAttachment", 'String'>
    readonly mimeType: FieldRef<"TicketAttachment", 'String'>
    readonly size: FieldRef<"TicketAttachment", 'Int'>
    readonly url: FieldRef<"TicketAttachment", 'String'>
    readonly uploadedById: FieldRef<"TicketAttachment", 'String'>
    readonly createdAt: FieldRef<"TicketAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketAttachment findUnique
   */
  export type TicketAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findUniqueOrThrow
   */
  export type TicketAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment findFirst
   */
  export type TicketAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findFirstOrThrow
   */
  export type TicketAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachment to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketAttachments.
     */
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment findMany
   */
  export type TicketAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which TicketAttachments to fetch.
     */
    where?: TicketAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketAttachments to fetch.
     */
    orderBy?: TicketAttachmentOrderByWithRelationInput | TicketAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketAttachments.
     */
    cursor?: TicketAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketAttachments.
     */
    skip?: number
    distinct?: TicketAttachmentScalarFieldEnum | TicketAttachmentScalarFieldEnum[]
  }

  /**
   * TicketAttachment create
   */
  export type TicketAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketAttachment.
     */
    data: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
  }

  /**
   * TicketAttachment createMany
   */
  export type TicketAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketAttachment createManyAndReturn
   */
  export type TicketAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketAttachments.
     */
    data: TicketAttachmentCreateManyInput | TicketAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAttachment update
   */
  export type TicketAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketAttachment.
     */
    data: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
    /**
     * Choose, which TicketAttachment to update.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment updateMany
   */
  export type TicketAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to update.
     */
    limit?: number
  }

  /**
   * TicketAttachment updateManyAndReturn
   */
  export type TicketAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update TicketAttachments.
     */
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which TicketAttachments to update
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketAttachment upsert
   */
  export type TicketAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketAttachment to update in case it exists.
     */
    where: TicketAttachmentWhereUniqueInput
    /**
     * In case the TicketAttachment found by the `where` argument doesn't exist, create a new TicketAttachment with this data.
     */
    create: XOR<TicketAttachmentCreateInput, TicketAttachmentUncheckedCreateInput>
    /**
     * In case the TicketAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketAttachmentUpdateInput, TicketAttachmentUncheckedUpdateInput>
  }

  /**
   * TicketAttachment delete
   */
  export type TicketAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
    /**
     * Filter which TicketAttachment to delete.
     */
    where: TicketAttachmentWhereUniqueInput
  }

  /**
   * TicketAttachment deleteMany
   */
  export type TicketAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketAttachments to delete
     */
    where?: TicketAttachmentWhereInput
    /**
     * Limit how many TicketAttachments to delete.
     */
    limit?: number
  }

  /**
   * TicketAttachment without action
   */
  export type TicketAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketAttachment
     */
    select?: TicketAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketAttachment
     */
    omit?: TicketAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Part
   */

  export type AggregatePart = {
    _count: PartCountAggregateOutputType | null
    _avg: PartAvgAggregateOutputType | null
    _sum: PartSumAggregateOutputType | null
    _min: PartMinAggregateOutputType | null
    _max: PartMaxAggregateOutputType | null
  }

  export type PartAvgAggregateOutputType = {
    quantity: number | null
    cost: Decimal | null
    price: Decimal | null
    minStock: number | null
  }

  export type PartSumAggregateOutputType = {
    quantity: number | null
    cost: Decimal | null
    price: Decimal | null
    minStock: number | null
  }

  export type PartMinAggregateOutputType = {
    id: string | null
    name: string | null
    sku: string | null
    quantity: number | null
    cost: Decimal | null
    price: Decimal | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    category: string | null
    location: string | null
    minStock: number | null
  }

  export type PartMaxAggregateOutputType = {
    id: string | null
    name: string | null
    sku: string | null
    quantity: number | null
    cost: Decimal | null
    price: Decimal | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    category: string | null
    location: string | null
    minStock: number | null
  }

  export type PartCountAggregateOutputType = {
    id: number
    name: number
    sku: number
    quantity: number
    cost: number
    price: number
    tenantId: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    category: number
    location: number
    minStock: number
    _all: number
  }


  export type PartAvgAggregateInputType = {
    quantity?: true
    cost?: true
    price?: true
    minStock?: true
  }

  export type PartSumAggregateInputType = {
    quantity?: true
    cost?: true
    price?: true
    minStock?: true
  }

  export type PartMinAggregateInputType = {
    id?: true
    name?: true
    sku?: true
    quantity?: true
    cost?: true
    price?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    category?: true
    location?: true
    minStock?: true
  }

  export type PartMaxAggregateInputType = {
    id?: true
    name?: true
    sku?: true
    quantity?: true
    cost?: true
    price?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    category?: true
    location?: true
    minStock?: true
  }

  export type PartCountAggregateInputType = {
    id?: true
    name?: true
    sku?: true
    quantity?: true
    cost?: true
    price?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    category?: true
    location?: true
    minStock?: true
    _all?: true
  }

  export type PartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Part to aggregate.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parts
    **/
    _count?: true | PartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartMaxAggregateInputType
  }

  export type GetPartAggregateType<T extends PartAggregateArgs> = {
        [P in keyof T & keyof AggregatePart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePart[P]>
      : GetScalarType<T[P], AggregatePart[P]>
  }




  export type PartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartWhereInput
    orderBy?: PartOrderByWithAggregationInput | PartOrderByWithAggregationInput[]
    by: PartScalarFieldEnum[] | PartScalarFieldEnum
    having?: PartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartCountAggregateInputType | true
    _avg?: PartAvgAggregateInputType
    _sum?: PartSumAggregateInputType
    _min?: PartMinAggregateInputType
    _max?: PartMaxAggregateInputType
  }

  export type PartGroupByOutputType = {
    id: string
    name: string
    sku: string | null
    quantity: number
    cost: Decimal
    price: Decimal
    tenantId: string
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    updatedById: string | null
    category: string | null
    location: string | null
    minStock: number
    _count: PartCountAggregateOutputType | null
    _avg: PartAvgAggregateOutputType | null
    _sum: PartSumAggregateOutputType | null
    _min: PartMinAggregateOutputType | null
    _max: PartMaxAggregateOutputType | null
  }

  type GetPartGroupByPayload<T extends PartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartGroupByOutputType[P]>
            : GetScalarType<T[P], PartGroupByOutputType[P]>
        }
      >
    >


  export type PartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sku?: boolean
    quantity?: boolean
    cost?: boolean
    price?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    category?: boolean
    location?: boolean
    minStock?: boolean
    creditNoteItems?: boolean | Part$creditNoteItemsArgs<ExtArgs>
    createdBy?: boolean | Part$createdByArgs<ExtArgs>
    posQuotationItems?: boolean | Part$posQuotationItemsArgs<ExtArgs>
    posSaleItems?: boolean | Part$posSaleItemsArgs<ExtArgs>
    purchaseItems?: boolean | Part$purchaseItemsArgs<ExtArgs>
    templateDefaultParts?: boolean | Part$templateDefaultPartsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Part$updatedByArgs<ExtArgs>
    usages?: boolean | Part$usagesArgs<ExtArgs>
    _count?: boolean | PartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["part"]>

  export type PartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sku?: boolean
    quantity?: boolean
    cost?: boolean
    price?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    category?: boolean
    location?: boolean
    minStock?: boolean
    createdBy?: boolean | Part$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Part$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["part"]>

  export type PartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sku?: boolean
    quantity?: boolean
    cost?: boolean
    price?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    category?: boolean
    location?: boolean
    minStock?: boolean
    createdBy?: boolean | Part$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Part$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["part"]>

  export type PartSelectScalar = {
    id?: boolean
    name?: boolean
    sku?: boolean
    quantity?: boolean
    cost?: boolean
    price?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    category?: boolean
    location?: boolean
    minStock?: boolean
  }

  export type PartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "sku" | "quantity" | "cost" | "price" | "tenantId" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "category" | "location" | "minStock", ExtArgs["result"]["part"]>
  export type PartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNoteItems?: boolean | Part$creditNoteItemsArgs<ExtArgs>
    createdBy?: boolean | Part$createdByArgs<ExtArgs>
    posQuotationItems?: boolean | Part$posQuotationItemsArgs<ExtArgs>
    posSaleItems?: boolean | Part$posSaleItemsArgs<ExtArgs>
    purchaseItems?: boolean | Part$purchaseItemsArgs<ExtArgs>
    templateDefaultParts?: boolean | Part$templateDefaultPartsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Part$updatedByArgs<ExtArgs>
    usages?: boolean | Part$usagesArgs<ExtArgs>
    _count?: boolean | PartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Part$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Part$updatedByArgs<ExtArgs>
  }
  export type PartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Part$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | Part$updatedByArgs<ExtArgs>
  }

  export type $PartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Part"
    objects: {
      creditNoteItems: Prisma.$CreditNoteItemPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      posQuotationItems: Prisma.$POSQuotationItemPayload<ExtArgs>[]
      posSaleItems: Prisma.$POSSaleItemPayload<ExtArgs>[]
      purchaseItems: Prisma.$PurchaseItemPayload<ExtArgs>[]
      templateDefaultParts: Prisma.$TemplateDefaultPartPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      usages: Prisma.$PartUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      sku: string | null
      quantity: number
      cost: Prisma.Decimal
      price: Prisma.Decimal
      tenantId: string
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      updatedById: string | null
      category: string | null
      location: string | null
      minStock: number
    }, ExtArgs["result"]["part"]>
    composites: {}
  }

  type PartGetPayload<S extends boolean | null | undefined | PartDefaultArgs> = $Result.GetResult<Prisma.$PartPayload, S>

  type PartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartCountAggregateInputType | true
    }

  export interface PartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Part'], meta: { name: 'Part' } }
    /**
     * Find zero or one Part that matches the filter.
     * @param {PartFindUniqueArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartFindUniqueArgs>(args: SelectSubset<T, PartFindUniqueArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Part that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartFindUniqueOrThrowArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartFindUniqueOrThrowArgs>(args: SelectSubset<T, PartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Part that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindFirstArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartFindFirstArgs>(args?: SelectSubset<T, PartFindFirstArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Part that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindFirstOrThrowArgs} args - Arguments to find a Part
     * @example
     * // Get one Part
     * const part = await prisma.part.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartFindFirstOrThrowArgs>(args?: SelectSubset<T, PartFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parts
     * const parts = await prisma.part.findMany()
     * 
     * // Get first 10 Parts
     * const parts = await prisma.part.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partWithIdOnly = await prisma.part.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartFindManyArgs>(args?: SelectSubset<T, PartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Part.
     * @param {PartCreateArgs} args - Arguments to create a Part.
     * @example
     * // Create one Part
     * const Part = await prisma.part.create({
     *   data: {
     *     // ... data to create a Part
     *   }
     * })
     * 
     */
    create<T extends PartCreateArgs>(args: SelectSubset<T, PartCreateArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parts.
     * @param {PartCreateManyArgs} args - Arguments to create many Parts.
     * @example
     * // Create many Parts
     * const part = await prisma.part.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartCreateManyArgs>(args?: SelectSubset<T, PartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parts and returns the data saved in the database.
     * @param {PartCreateManyAndReturnArgs} args - Arguments to create many Parts.
     * @example
     * // Create many Parts
     * const part = await prisma.part.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parts and only return the `id`
     * const partWithIdOnly = await prisma.part.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartCreateManyAndReturnArgs>(args?: SelectSubset<T, PartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Part.
     * @param {PartDeleteArgs} args - Arguments to delete one Part.
     * @example
     * // Delete one Part
     * const Part = await prisma.part.delete({
     *   where: {
     *     // ... filter to delete one Part
     *   }
     * })
     * 
     */
    delete<T extends PartDeleteArgs>(args: SelectSubset<T, PartDeleteArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Part.
     * @param {PartUpdateArgs} args - Arguments to update one Part.
     * @example
     * // Update one Part
     * const part = await prisma.part.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartUpdateArgs>(args: SelectSubset<T, PartUpdateArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parts.
     * @param {PartDeleteManyArgs} args - Arguments to filter Parts to delete.
     * @example
     * // Delete a few Parts
     * const { count } = await prisma.part.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartDeleteManyArgs>(args?: SelectSubset<T, PartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parts
     * const part = await prisma.part.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartUpdateManyArgs>(args: SelectSubset<T, PartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parts and returns the data updated in the database.
     * @param {PartUpdateManyAndReturnArgs} args - Arguments to update many Parts.
     * @example
     * // Update many Parts
     * const part = await prisma.part.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parts and only return the `id`
     * const partWithIdOnly = await prisma.part.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartUpdateManyAndReturnArgs>(args: SelectSubset<T, PartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Part.
     * @param {PartUpsertArgs} args - Arguments to update or create a Part.
     * @example
     * // Update or create a Part
     * const part = await prisma.part.upsert({
     *   create: {
     *     // ... data to create a Part
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Part we want to update
     *   }
     * })
     */
    upsert<T extends PartUpsertArgs>(args: SelectSubset<T, PartUpsertArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartCountArgs} args - Arguments to filter Parts to count.
     * @example
     * // Count the number of Parts
     * const count = await prisma.part.count({
     *   where: {
     *     // ... the filter for the Parts we want to count
     *   }
     * })
    **/
    count<T extends PartCountArgs>(
      args?: Subset<T, PartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Part.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartAggregateArgs>(args: Subset<T, PartAggregateArgs>): Prisma.PrismaPromise<GetPartAggregateType<T>>

    /**
     * Group by Part.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartGroupByArgs['orderBy'] }
        : { orderBy?: PartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Part model
   */
  readonly fields: PartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Part.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditNoteItems<T extends Part$creditNoteItemsArgs<ExtArgs> = {}>(args?: Subset<T, Part$creditNoteItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends Part$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Part$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    posQuotationItems<T extends Part$posQuotationItemsArgs<ExtArgs> = {}>(args?: Subset<T, Part$posQuotationItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posSaleItems<T extends Part$posSaleItemsArgs<ExtArgs> = {}>(args?: Subset<T, Part$posSaleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseItems<T extends Part$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, Part$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templateDefaultParts<T extends Part$templateDefaultPartsArgs<ExtArgs> = {}>(args?: Subset<T, Part$templateDefaultPartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Part$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Part$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usages<T extends Part$usagesArgs<ExtArgs> = {}>(args?: Subset<T, Part$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Part model
   */
  interface PartFieldRefs {
    readonly id: FieldRef<"Part", 'String'>
    readonly name: FieldRef<"Part", 'String'>
    readonly sku: FieldRef<"Part", 'String'>
    readonly quantity: FieldRef<"Part", 'Int'>
    readonly cost: FieldRef<"Part", 'Decimal'>
    readonly price: FieldRef<"Part", 'Decimal'>
    readonly tenantId: FieldRef<"Part", 'String'>
    readonly createdAt: FieldRef<"Part", 'DateTime'>
    readonly updatedAt: FieldRef<"Part", 'DateTime'>
    readonly createdById: FieldRef<"Part", 'String'>
    readonly updatedById: FieldRef<"Part", 'String'>
    readonly category: FieldRef<"Part", 'String'>
    readonly location: FieldRef<"Part", 'String'>
    readonly minStock: FieldRef<"Part", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Part findUnique
   */
  export type PartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part findUniqueOrThrow
   */
  export type PartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part findFirst
   */
  export type PartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * Part findFirstOrThrow
   */
  export type PartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Part to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parts.
     */
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * Part findMany
   */
  export type PartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter, which Parts to fetch.
     */
    where?: PartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parts to fetch.
     */
    orderBy?: PartOrderByWithRelationInput | PartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parts.
     */
    cursor?: PartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parts.
     */
    skip?: number
    distinct?: PartScalarFieldEnum | PartScalarFieldEnum[]
  }

  /**
   * Part create
   */
  export type PartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The data needed to create a Part.
     */
    data: XOR<PartCreateInput, PartUncheckedCreateInput>
  }

  /**
   * Part createMany
   */
  export type PartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parts.
     */
    data: PartCreateManyInput | PartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Part createManyAndReturn
   */
  export type PartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * The data used to create many Parts.
     */
    data: PartCreateManyInput | PartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Part update
   */
  export type PartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The data needed to update a Part.
     */
    data: XOR<PartUpdateInput, PartUncheckedUpdateInput>
    /**
     * Choose, which Part to update.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part updateMany
   */
  export type PartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parts.
     */
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyInput>
    /**
     * Filter which Parts to update
     */
    where?: PartWhereInput
    /**
     * Limit how many Parts to update.
     */
    limit?: number
  }

  /**
   * Part updateManyAndReturn
   */
  export type PartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * The data used to update Parts.
     */
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyInput>
    /**
     * Filter which Parts to update
     */
    where?: PartWhereInput
    /**
     * Limit how many Parts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Part upsert
   */
  export type PartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * The filter to search for the Part to update in case it exists.
     */
    where: PartWhereUniqueInput
    /**
     * In case the Part found by the `where` argument doesn't exist, create a new Part with this data.
     */
    create: XOR<PartCreateInput, PartUncheckedCreateInput>
    /**
     * In case the Part was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartUpdateInput, PartUncheckedUpdateInput>
  }

  /**
   * Part delete
   */
  export type PartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
    /**
     * Filter which Part to delete.
     */
    where: PartWhereUniqueInput
  }

  /**
   * Part deleteMany
   */
  export type PartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parts to delete
     */
    where?: PartWhereInput
    /**
     * Limit how many Parts to delete.
     */
    limit?: number
  }

  /**
   * Part.creditNoteItems
   */
  export type Part$creditNoteItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    where?: CreditNoteItemWhereInput
    orderBy?: CreditNoteItemOrderByWithRelationInput | CreditNoteItemOrderByWithRelationInput[]
    cursor?: CreditNoteItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteItemScalarFieldEnum | CreditNoteItemScalarFieldEnum[]
  }

  /**
   * Part.createdBy
   */
  export type Part$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Part.posQuotationItems
   */
  export type Part$posQuotationItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    where?: POSQuotationItemWhereInput
    orderBy?: POSQuotationItemOrderByWithRelationInput | POSQuotationItemOrderByWithRelationInput[]
    cursor?: POSQuotationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSQuotationItemScalarFieldEnum | POSQuotationItemScalarFieldEnum[]
  }

  /**
   * Part.posSaleItems
   */
  export type Part$posSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    where?: POSSaleItemWhereInput
    orderBy?: POSSaleItemOrderByWithRelationInput | POSSaleItemOrderByWithRelationInput[]
    cursor?: POSSaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSaleItemScalarFieldEnum | POSSaleItemScalarFieldEnum[]
  }

  /**
   * Part.purchaseItems
   */
  export type Part$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * Part.templateDefaultParts
   */
  export type Part$templateDefaultPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    where?: TemplateDefaultPartWhereInput
    orderBy?: TemplateDefaultPartOrderByWithRelationInput | TemplateDefaultPartOrderByWithRelationInput[]
    cursor?: TemplateDefaultPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateDefaultPartScalarFieldEnum | TemplateDefaultPartScalarFieldEnum[]
  }

  /**
   * Part.updatedBy
   */
  export type Part$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Part.usages
   */
  export type Part$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    where?: PartUsageWhereInput
    orderBy?: PartUsageOrderByWithRelationInput | PartUsageOrderByWithRelationInput[]
    cursor?: PartUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartUsageScalarFieldEnum | PartUsageScalarFieldEnum[]
  }

  /**
   * Part without action
   */
  export type PartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Part
     */
    select?: PartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Part
     */
    omit?: PartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    totalCost: Decimal | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    totalCost: Decimal | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    supplier: string | null
    status: $Enums.PurchaseStatus | null
    orderDate: Date | null
    receivedDate: Date | null
    totalCost: Decimal | null
    tenantId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    supplier: string | null
    status: $Enums.PurchaseStatus | null
    orderDate: Date | null
    receivedDate: Date | null
    totalCost: Decimal | null
    tenantId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    supplier: number
    status: number
    orderDate: number
    receivedDate: number
    totalCost: number
    tenantId: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    totalCost?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    totalCost?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    supplier?: true
    status?: true
    orderDate?: true
    receivedDate?: true
    totalCost?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    supplier?: true
    status?: true
    orderDate?: true
    receivedDate?: true
    totalCost?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    supplier?: true
    status?: true
    orderDate?: true
    receivedDate?: true
    totalCost?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    supplier: string
    status: $Enums.PurchaseStatus
    orderDate: Date
    receivedDate: Date | null
    totalCost: Decimal
    tenantId: string
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    status?: boolean
    orderDate?: boolean
    receivedDate?: boolean
    totalCost?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    status?: boolean
    orderDate?: boolean
    receivedDate?: boolean
    totalCost?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    status?: boolean
    orderDate?: boolean
    receivedDate?: boolean
    totalCost?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    supplier?: boolean
    status?: boolean
    orderDate?: boolean
    receivedDate?: boolean
    totalCost?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplier" | "status" | "orderDate" | "receivedDate" | "totalCost" | "tenantId" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      items: Prisma.$PurchaseItemPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplier: string
      status: $Enums.PurchaseStatus
      orderDate: Date
      receivedDate: Date | null
      totalCost: Prisma.Decimal
      tenantId: string
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly supplier: FieldRef<"PurchaseOrder", 'String'>
    readonly status: FieldRef<"PurchaseOrder", 'PurchaseStatus'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly receivedDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly totalCost: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly tenantId: FieldRef<"PurchaseOrder", 'String'>
    readonly createdById: FieldRef<"PurchaseOrder", 'String'>
    readonly updatedById: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    cursor?: PurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseItem
   */

  export type AggregatePurchaseItem = {
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  export type PurchaseItemAvgAggregateOutputType = {
    quantity: number | null
    unitCost: Decimal | null
  }

  export type PurchaseItemSumAggregateOutputType = {
    quantity: number | null
    unitCost: Decimal | null
  }

  export type PurchaseItemMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    unitCost: Decimal | null
    partId: string | null
    purchaseOrderId: string | null
  }

  export type PurchaseItemMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    unitCost: Decimal | null
    partId: string | null
    purchaseOrderId: string | null
  }

  export type PurchaseItemCountAggregateOutputType = {
    id: number
    quantity: number
    unitCost: number
    partId: number
    purchaseOrderId: number
    _all: number
  }


  export type PurchaseItemAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
  }

  export type PurchaseItemSumAggregateInputType = {
    quantity?: true
    unitCost?: true
  }

  export type PurchaseItemMinAggregateInputType = {
    id?: true
    quantity?: true
    unitCost?: true
    partId?: true
    purchaseOrderId?: true
  }

  export type PurchaseItemMaxAggregateInputType = {
    id?: true
    quantity?: true
    unitCost?: true
    partId?: true
    purchaseOrderId?: true
  }

  export type PurchaseItemCountAggregateInputType = {
    id?: true
    quantity?: true
    unitCost?: true
    partId?: true
    purchaseOrderId?: true
    _all?: true
  }

  export type PurchaseItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItem to aggregate.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseItems
    **/
    _count?: true | PurchaseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type GetPurchaseItemAggregateType<T extends PurchaseItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseItem[P]>
      : GetScalarType<T[P], AggregatePurchaseItem[P]>
  }




  export type PurchaseItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseItemWhereInput
    orderBy?: PurchaseItemOrderByWithAggregationInput | PurchaseItemOrderByWithAggregationInput[]
    by: PurchaseItemScalarFieldEnum[] | PurchaseItemScalarFieldEnum
    having?: PurchaseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseItemCountAggregateInputType | true
    _avg?: PurchaseItemAvgAggregateInputType
    _sum?: PurchaseItemSumAggregateInputType
    _min?: PurchaseItemMinAggregateInputType
    _max?: PurchaseItemMaxAggregateInputType
  }

  export type PurchaseItemGroupByOutputType = {
    id: string
    quantity: number
    unitCost: Decimal
    partId: string
    purchaseOrderId: string
    _count: PurchaseItemCountAggregateOutputType | null
    _avg: PurchaseItemAvgAggregateOutputType | null
    _sum: PurchaseItemSumAggregateOutputType | null
    _min: PurchaseItemMinAggregateOutputType | null
    _max: PurchaseItemMaxAggregateOutputType | null
  }

  type GetPurchaseItemGroupByPayload<T extends PurchaseItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitCost?: boolean
    partId?: boolean
    purchaseOrderId?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitCost?: boolean
    partId?: boolean
    purchaseOrderId?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    unitCost?: boolean
    partId?: boolean
    purchaseOrderId?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseItem"]>

  export type PurchaseItemSelectScalar = {
    id?: boolean
    quantity?: boolean
    unitCost?: boolean
    partId?: boolean
    purchaseOrderId?: boolean
  }

  export type PurchaseItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "unitCost" | "partId" | "purchaseOrderId", ExtArgs["result"]["purchaseItem"]>
  export type PurchaseItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }
  export type PurchaseItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }
  export type PurchaseItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }

  export type $PurchaseItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseItem"
    objects: {
      part: Prisma.$PartPayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      unitCost: Prisma.Decimal
      partId: string
      purchaseOrderId: string
    }, ExtArgs["result"]["purchaseItem"]>
    composites: {}
  }

  type PurchaseItemGetPayload<S extends boolean | null | undefined | PurchaseItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseItemPayload, S>

  type PurchaseItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseItemCountAggregateInputType | true
    }

  export interface PurchaseItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseItem'], meta: { name: 'PurchaseItem' } }
    /**
     * Find zero or one PurchaseItem that matches the filter.
     * @param {PurchaseItemFindUniqueArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseItemFindUniqueArgs>(args: SelectSubset<T, PurchaseItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseItemFindFirstArgs>(args?: SelectSubset<T, PurchaseItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseItem
     * @example
     * // Get one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany()
     * 
     * // Get first 10 PurchaseItems
     * const purchaseItems = await prisma.purchaseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseItemFindManyArgs>(args?: SelectSubset<T, PurchaseItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseItem.
     * @param {PurchaseItemCreateArgs} args - Arguments to create a PurchaseItem.
     * @example
     * // Create one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.create({
     *   data: {
     *     // ... data to create a PurchaseItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseItemCreateArgs>(args: SelectSubset<T, PurchaseItemCreateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseItems.
     * @param {PurchaseItemCreateManyArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseItemCreateManyArgs>(args?: SelectSubset<T, PurchaseItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseItems and returns the data saved in the database.
     * @param {PurchaseItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseItems.
     * @example
     * // Create many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseItems and only return the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseItem.
     * @param {PurchaseItemDeleteArgs} args - Arguments to delete one PurchaseItem.
     * @example
     * // Delete one PurchaseItem
     * const PurchaseItem = await prisma.purchaseItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseItemDeleteArgs>(args: SelectSubset<T, PurchaseItemDeleteArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseItem.
     * @param {PurchaseItemUpdateArgs} args - Arguments to update one PurchaseItem.
     * @example
     * // Update one PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseItemUpdateArgs>(args: SelectSubset<T, PurchaseItemUpdateArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseItems.
     * @param {PurchaseItemDeleteManyArgs} args - Arguments to filter PurchaseItems to delete.
     * @example
     * // Delete a few PurchaseItems
     * const { count } = await prisma.purchaseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseItemUpdateManyArgs>(args: SelectSubset<T, PurchaseItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseItems and returns the data updated in the database.
     * @param {PurchaseItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseItems.
     * @example
     * // Update many PurchaseItems
     * const purchaseItem = await prisma.purchaseItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseItems and only return the `id`
     * const purchaseItemWithIdOnly = await prisma.purchaseItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseItem.
     * @param {PurchaseItemUpsertArgs} args - Arguments to update or create a PurchaseItem.
     * @example
     * // Update or create a PurchaseItem
     * const purchaseItem = await prisma.purchaseItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseItemUpsertArgs>(args: SelectSubset<T, PurchaseItemUpsertArgs<ExtArgs>>): Prisma__PurchaseItemClient<$Result.GetResult<Prisma.$PurchaseItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemCountArgs} args - Arguments to filter PurchaseItems to count.
     * @example
     * // Count the number of PurchaseItems
     * const count = await prisma.purchaseItem.count({
     *   where: {
     *     // ... the filter for the PurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseItemCountArgs>(
      args?: Subset<T, PurchaseItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseItemAggregateArgs>(args: Subset<T, PurchaseItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseItemAggregateType<T>>

    /**
     * Group by PurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseItem model
   */
  readonly fields: PurchaseItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    part<T extends PartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartDefaultArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseItem model
   */
  interface PurchaseItemFieldRefs {
    readonly id: FieldRef<"PurchaseItem", 'String'>
    readonly quantity: FieldRef<"PurchaseItem", 'Int'>
    readonly unitCost: FieldRef<"PurchaseItem", 'Decimal'>
    readonly partId: FieldRef<"PurchaseItem", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseItem findUnique
   */
  export type PurchaseItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findUniqueOrThrow
   */
  export type PurchaseItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem findFirst
   */
  export type PurchaseItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findFirstOrThrow
   */
  export type PurchaseItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItem to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseItems.
     */
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem findMany
   */
  export type PurchaseItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseItems to fetch.
     */
    where?: PurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseItems to fetch.
     */
    orderBy?: PurchaseItemOrderByWithRelationInput | PurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseItems.
     */
    cursor?: PurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseItems.
     */
    skip?: number
    distinct?: PurchaseItemScalarFieldEnum | PurchaseItemScalarFieldEnum[]
  }

  /**
   * PurchaseItem create
   */
  export type PurchaseItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseItem.
     */
    data: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
  }

  /**
   * PurchaseItem createMany
   */
  export type PurchaseItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseItem createManyAndReturn
   */
  export type PurchaseItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseItems.
     */
    data: PurchaseItemCreateManyInput | PurchaseItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItem update
   */
  export type PurchaseItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseItem.
     */
    data: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseItem to update.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem updateMany
   */
  export type PurchaseItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseItem updateManyAndReturn
   */
  export type PurchaseItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseItems.
     */
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseItems to update
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseItem upsert
   */
  export type PurchaseItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseItem to update in case it exists.
     */
    where: PurchaseItemWhereUniqueInput
    /**
     * In case the PurchaseItem found by the `where` argument doesn't exist, create a new PurchaseItem with this data.
     */
    create: XOR<PurchaseItemCreateInput, PurchaseItemUncheckedCreateInput>
    /**
     * In case the PurchaseItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseItemUpdateInput, PurchaseItemUncheckedUpdateInput>
  }

  /**
   * PurchaseItem delete
   */
  export type PurchaseItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseItem to delete.
     */
    where: PurchaseItemWhereUniqueInput
  }

  /**
   * PurchaseItem deleteMany
   */
  export type PurchaseItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseItems to delete
     */
    where?: PurchaseItemWhereInput
    /**
     * Limit how many PurchaseItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseItem without action
   */
  export type PurchaseItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseItem
     */
    select?: PurchaseItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseItem
     */
    omit?: PurchaseItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseItemInclude<ExtArgs> | null
  }


  /**
   * Model PartUsage
   */

  export type AggregatePartUsage = {
    _count: PartUsageCountAggregateOutputType | null
    _avg: PartUsageAvgAggregateOutputType | null
    _sum: PartUsageSumAggregateOutputType | null
    _min: PartUsageMinAggregateOutputType | null
    _max: PartUsageMaxAggregateOutputType | null
  }

  export type PartUsageAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PartUsageSumAggregateOutputType = {
    quantity: number | null
  }

  export type PartUsageMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    ticketId: string | null
    partId: string | null
    createdAt: Date | null
  }

  export type PartUsageMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    ticketId: string | null
    partId: string | null
    createdAt: Date | null
  }

  export type PartUsageCountAggregateOutputType = {
    id: number
    quantity: number
    ticketId: number
    partId: number
    createdAt: number
    _all: number
  }


  export type PartUsageAvgAggregateInputType = {
    quantity?: true
  }

  export type PartUsageSumAggregateInputType = {
    quantity?: true
  }

  export type PartUsageMinAggregateInputType = {
    id?: true
    quantity?: true
    ticketId?: true
    partId?: true
    createdAt?: true
  }

  export type PartUsageMaxAggregateInputType = {
    id?: true
    quantity?: true
    ticketId?: true
    partId?: true
    createdAt?: true
  }

  export type PartUsageCountAggregateInputType = {
    id?: true
    quantity?: true
    ticketId?: true
    partId?: true
    createdAt?: true
    _all?: true
  }

  export type PartUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartUsage to aggregate.
     */
    where?: PartUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartUsages to fetch.
     */
    orderBy?: PartUsageOrderByWithRelationInput | PartUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PartUsages
    **/
    _count?: true | PartUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartUsageMaxAggregateInputType
  }

  export type GetPartUsageAggregateType<T extends PartUsageAggregateArgs> = {
        [P in keyof T & keyof AggregatePartUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartUsage[P]>
      : GetScalarType<T[P], AggregatePartUsage[P]>
  }




  export type PartUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartUsageWhereInput
    orderBy?: PartUsageOrderByWithAggregationInput | PartUsageOrderByWithAggregationInput[]
    by: PartUsageScalarFieldEnum[] | PartUsageScalarFieldEnum
    having?: PartUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartUsageCountAggregateInputType | true
    _avg?: PartUsageAvgAggregateInputType
    _sum?: PartUsageSumAggregateInputType
    _min?: PartUsageMinAggregateInputType
    _max?: PartUsageMaxAggregateInputType
  }

  export type PartUsageGroupByOutputType = {
    id: string
    quantity: number
    ticketId: string
    partId: string
    createdAt: Date
    _count: PartUsageCountAggregateOutputType | null
    _avg: PartUsageAvgAggregateOutputType | null
    _sum: PartUsageSumAggregateOutputType | null
    _min: PartUsageMinAggregateOutputType | null
    _max: PartUsageMaxAggregateOutputType | null
  }

  type GetPartUsageGroupByPayload<T extends PartUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartUsageGroupByOutputType[P]>
            : GetScalarType<T[P], PartUsageGroupByOutputType[P]>
        }
      >
    >


  export type PartUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    ticketId?: boolean
    partId?: boolean
    createdAt?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partUsage"]>

  export type PartUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    ticketId?: boolean
    partId?: boolean
    createdAt?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partUsage"]>

  export type PartUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    ticketId?: boolean
    partId?: boolean
    createdAt?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partUsage"]>

  export type PartUsageSelectScalar = {
    id?: boolean
    quantity?: boolean
    ticketId?: boolean
    partId?: boolean
    createdAt?: boolean
  }

  export type PartUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "ticketId" | "partId" | "createdAt", ExtArgs["result"]["partUsage"]>
  export type PartUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type PartUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type PartUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $PartUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PartUsage"
    objects: {
      part: Prisma.$PartPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      ticketId: string
      partId: string
      createdAt: Date
    }, ExtArgs["result"]["partUsage"]>
    composites: {}
  }

  type PartUsageGetPayload<S extends boolean | null | undefined | PartUsageDefaultArgs> = $Result.GetResult<Prisma.$PartUsagePayload, S>

  type PartUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartUsageCountAggregateInputType | true
    }

  export interface PartUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PartUsage'], meta: { name: 'PartUsage' } }
    /**
     * Find zero or one PartUsage that matches the filter.
     * @param {PartUsageFindUniqueArgs} args - Arguments to find a PartUsage
     * @example
     * // Get one PartUsage
     * const partUsage = await prisma.partUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartUsageFindUniqueArgs>(args: SelectSubset<T, PartUsageFindUniqueArgs<ExtArgs>>): Prisma__PartUsageClient<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PartUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartUsageFindUniqueOrThrowArgs} args - Arguments to find a PartUsage
     * @example
     * // Get one PartUsage
     * const partUsage = await prisma.partUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, PartUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartUsageClient<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUsageFindFirstArgs} args - Arguments to find a PartUsage
     * @example
     * // Get one PartUsage
     * const partUsage = await prisma.partUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartUsageFindFirstArgs>(args?: SelectSubset<T, PartUsageFindFirstArgs<ExtArgs>>): Prisma__PartUsageClient<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PartUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUsageFindFirstOrThrowArgs} args - Arguments to find a PartUsage
     * @example
     * // Get one PartUsage
     * const partUsage = await prisma.partUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, PartUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartUsageClient<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PartUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PartUsages
     * const partUsages = await prisma.partUsage.findMany()
     * 
     * // Get first 10 PartUsages
     * const partUsages = await prisma.partUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partUsageWithIdOnly = await prisma.partUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartUsageFindManyArgs>(args?: SelectSubset<T, PartUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PartUsage.
     * @param {PartUsageCreateArgs} args - Arguments to create a PartUsage.
     * @example
     * // Create one PartUsage
     * const PartUsage = await prisma.partUsage.create({
     *   data: {
     *     // ... data to create a PartUsage
     *   }
     * })
     * 
     */
    create<T extends PartUsageCreateArgs>(args: SelectSubset<T, PartUsageCreateArgs<ExtArgs>>): Prisma__PartUsageClient<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PartUsages.
     * @param {PartUsageCreateManyArgs} args - Arguments to create many PartUsages.
     * @example
     * // Create many PartUsages
     * const partUsage = await prisma.partUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartUsageCreateManyArgs>(args?: SelectSubset<T, PartUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PartUsages and returns the data saved in the database.
     * @param {PartUsageCreateManyAndReturnArgs} args - Arguments to create many PartUsages.
     * @example
     * // Create many PartUsages
     * const partUsage = await prisma.partUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PartUsages and only return the `id`
     * const partUsageWithIdOnly = await prisma.partUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, PartUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PartUsage.
     * @param {PartUsageDeleteArgs} args - Arguments to delete one PartUsage.
     * @example
     * // Delete one PartUsage
     * const PartUsage = await prisma.partUsage.delete({
     *   where: {
     *     // ... filter to delete one PartUsage
     *   }
     * })
     * 
     */
    delete<T extends PartUsageDeleteArgs>(args: SelectSubset<T, PartUsageDeleteArgs<ExtArgs>>): Prisma__PartUsageClient<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PartUsage.
     * @param {PartUsageUpdateArgs} args - Arguments to update one PartUsage.
     * @example
     * // Update one PartUsage
     * const partUsage = await prisma.partUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartUsageUpdateArgs>(args: SelectSubset<T, PartUsageUpdateArgs<ExtArgs>>): Prisma__PartUsageClient<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PartUsages.
     * @param {PartUsageDeleteManyArgs} args - Arguments to filter PartUsages to delete.
     * @example
     * // Delete a few PartUsages
     * const { count } = await prisma.partUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartUsageDeleteManyArgs>(args?: SelectSubset<T, PartUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PartUsages
     * const partUsage = await prisma.partUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartUsageUpdateManyArgs>(args: SelectSubset<T, PartUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PartUsages and returns the data updated in the database.
     * @param {PartUsageUpdateManyAndReturnArgs} args - Arguments to update many PartUsages.
     * @example
     * // Update many PartUsages
     * const partUsage = await prisma.partUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PartUsages and only return the `id`
     * const partUsageWithIdOnly = await prisma.partUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, PartUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PartUsage.
     * @param {PartUsageUpsertArgs} args - Arguments to update or create a PartUsage.
     * @example
     * // Update or create a PartUsage
     * const partUsage = await prisma.partUsage.upsert({
     *   create: {
     *     // ... data to create a PartUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PartUsage we want to update
     *   }
     * })
     */
    upsert<T extends PartUsageUpsertArgs>(args: SelectSubset<T, PartUsageUpsertArgs<ExtArgs>>): Prisma__PartUsageClient<$Result.GetResult<Prisma.$PartUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PartUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUsageCountArgs} args - Arguments to filter PartUsages to count.
     * @example
     * // Count the number of PartUsages
     * const count = await prisma.partUsage.count({
     *   where: {
     *     // ... the filter for the PartUsages we want to count
     *   }
     * })
    **/
    count<T extends PartUsageCountArgs>(
      args?: Subset<T, PartUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PartUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartUsageAggregateArgs>(args: Subset<T, PartUsageAggregateArgs>): Prisma.PrismaPromise<GetPartUsageAggregateType<T>>

    /**
     * Group by PartUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartUsageGroupByArgs['orderBy'] }
        : { orderBy?: PartUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PartUsage model
   */
  readonly fields: PartUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PartUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    part<T extends PartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartDefaultArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PartUsage model
   */
  interface PartUsageFieldRefs {
    readonly id: FieldRef<"PartUsage", 'String'>
    readonly quantity: FieldRef<"PartUsage", 'Int'>
    readonly ticketId: FieldRef<"PartUsage", 'String'>
    readonly partId: FieldRef<"PartUsage", 'String'>
    readonly createdAt: FieldRef<"PartUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PartUsage findUnique
   */
  export type PartUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * Filter, which PartUsage to fetch.
     */
    where: PartUsageWhereUniqueInput
  }

  /**
   * PartUsage findUniqueOrThrow
   */
  export type PartUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * Filter, which PartUsage to fetch.
     */
    where: PartUsageWhereUniqueInput
  }

  /**
   * PartUsage findFirst
   */
  export type PartUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * Filter, which PartUsage to fetch.
     */
    where?: PartUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartUsages to fetch.
     */
    orderBy?: PartUsageOrderByWithRelationInput | PartUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartUsages.
     */
    cursor?: PartUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartUsages.
     */
    distinct?: PartUsageScalarFieldEnum | PartUsageScalarFieldEnum[]
  }

  /**
   * PartUsage findFirstOrThrow
   */
  export type PartUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * Filter, which PartUsage to fetch.
     */
    where?: PartUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartUsages to fetch.
     */
    orderBy?: PartUsageOrderByWithRelationInput | PartUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PartUsages.
     */
    cursor?: PartUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PartUsages.
     */
    distinct?: PartUsageScalarFieldEnum | PartUsageScalarFieldEnum[]
  }

  /**
   * PartUsage findMany
   */
  export type PartUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * Filter, which PartUsages to fetch.
     */
    where?: PartUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PartUsages to fetch.
     */
    orderBy?: PartUsageOrderByWithRelationInput | PartUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PartUsages.
     */
    cursor?: PartUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PartUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PartUsages.
     */
    skip?: number
    distinct?: PartUsageScalarFieldEnum | PartUsageScalarFieldEnum[]
  }

  /**
   * PartUsage create
   */
  export type PartUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a PartUsage.
     */
    data: XOR<PartUsageCreateInput, PartUsageUncheckedCreateInput>
  }

  /**
   * PartUsage createMany
   */
  export type PartUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PartUsages.
     */
    data: PartUsageCreateManyInput | PartUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PartUsage createManyAndReturn
   */
  export type PartUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * The data used to create many PartUsages.
     */
    data: PartUsageCreateManyInput | PartUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartUsage update
   */
  export type PartUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a PartUsage.
     */
    data: XOR<PartUsageUpdateInput, PartUsageUncheckedUpdateInput>
    /**
     * Choose, which PartUsage to update.
     */
    where: PartUsageWhereUniqueInput
  }

  /**
   * PartUsage updateMany
   */
  export type PartUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PartUsages.
     */
    data: XOR<PartUsageUpdateManyMutationInput, PartUsageUncheckedUpdateManyInput>
    /**
     * Filter which PartUsages to update
     */
    where?: PartUsageWhereInput
    /**
     * Limit how many PartUsages to update.
     */
    limit?: number
  }

  /**
   * PartUsage updateManyAndReturn
   */
  export type PartUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * The data used to update PartUsages.
     */
    data: XOR<PartUsageUpdateManyMutationInput, PartUsageUncheckedUpdateManyInput>
    /**
     * Filter which PartUsages to update
     */
    where?: PartUsageWhereInput
    /**
     * Limit how many PartUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PartUsage upsert
   */
  export type PartUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the PartUsage to update in case it exists.
     */
    where: PartUsageWhereUniqueInput
    /**
     * In case the PartUsage found by the `where` argument doesn't exist, create a new PartUsage with this data.
     */
    create: XOR<PartUsageCreateInput, PartUsageUncheckedCreateInput>
    /**
     * In case the PartUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartUsageUpdateInput, PartUsageUncheckedUpdateInput>
  }

  /**
   * PartUsage delete
   */
  export type PartUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
    /**
     * Filter which PartUsage to delete.
     */
    where: PartUsageWhereUniqueInput
  }

  /**
   * PartUsage deleteMany
   */
  export type PartUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PartUsages to delete
     */
    where?: PartUsageWhereInput
    /**
     * Limit how many PartUsages to delete.
     */
    limit?: number
  }

  /**
   * PartUsage without action
   */
  export type PartUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartUsage
     */
    select?: PartUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PartUsage
     */
    omit?: PartUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartUsageInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    details: string | null
    userId: string | null
    tenantId: string | null
    createdAt: Date | null
    action: $Enums.AuditAction | null
    module: $Enums.AuditModule | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    details: string | null
    userId: string | null
    tenantId: string | null
    createdAt: Date | null
    action: $Enums.AuditAction | null
    module: $Enums.AuditModule | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    details: number
    userId: number
    tenantId: number
    createdAt: number
    action: number
    module: number
    entityType: number
    entityId: number
    metadata: number
    ipAddress: number
    userAgent: number
    success: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    details?: true
    userId?: true
    tenantId?: true
    createdAt?: true
    action?: true
    module?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    success?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    details?: true
    userId?: true
    tenantId?: true
    createdAt?: true
    action?: true
    module?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    success?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    details?: true
    userId?: true
    tenantId?: true
    createdAt?: true
    action?: true
    module?: true
    entityType?: true
    entityId?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    details: string | null
    userId: string | null
    tenantId: string
    createdAt: Date
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType: string | null
    entityId: string | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    details?: boolean
    userId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    action?: boolean
    module?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    details?: boolean
    userId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    action?: boolean
    module?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    details?: boolean
    userId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    action?: boolean
    module?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    details?: boolean
    userId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    action?: boolean
    module?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "details" | "userId" | "tenantId" | "createdAt" | "action" | "module" | "entityType" | "entityId" | "metadata" | "ipAddress" | "userAgent" | "success", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      details: string | null
      userId: string | null
      tenantId: string
      createdAt: Date
      action: $Enums.AuditAction
      module: $Enums.AuditModule
      entityType: string | null
      entityId: string | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      success: boolean
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly module: FieldRef<"AuditLog", 'AuditModule'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly success: FieldRef<"AuditLog", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model TicketNote
   */

  export type AggregateTicketNote = {
    _count: TicketNoteCountAggregateOutputType | null
    _min: TicketNoteMinAggregateOutputType | null
    _max: TicketNoteMaxAggregateOutputType | null
  }

  export type TicketNoteMinAggregateOutputType = {
    id: string | null
    content: string | null
    isInternal: boolean | null
    ticketId: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketNoteMaxAggregateOutputType = {
    id: string | null
    content: string | null
    isInternal: boolean | null
    ticketId: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketNoteCountAggregateOutputType = {
    id: number
    content: number
    isInternal: number
    ticketId: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketNoteMinAggregateInputType = {
    id?: true
    content?: true
    isInternal?: true
    ticketId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketNoteMaxAggregateInputType = {
    id?: true
    content?: true
    isInternal?: true
    ticketId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketNoteCountAggregateInputType = {
    id?: true
    content?: true
    isInternal?: true
    ticketId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketNote to aggregate.
     */
    where?: TicketNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketNotes to fetch.
     */
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketNotes
    **/
    _count?: true | TicketNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketNoteMaxAggregateInputType
  }

  export type GetTicketNoteAggregateType<T extends TicketNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketNote[P]>
      : GetScalarType<T[P], AggregateTicketNote[P]>
  }




  export type TicketNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketNoteWhereInput
    orderBy?: TicketNoteOrderByWithAggregationInput | TicketNoteOrderByWithAggregationInput[]
    by: TicketNoteScalarFieldEnum[] | TicketNoteScalarFieldEnum
    having?: TicketNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketNoteCountAggregateInputType | true
    _min?: TicketNoteMinAggregateInputType
    _max?: TicketNoteMaxAggregateInputType
  }

  export type TicketNoteGroupByOutputType = {
    id: string
    content: string
    isInternal: boolean
    ticketId: string
    authorId: string
    createdAt: Date
    updatedAt: Date
    _count: TicketNoteCountAggregateOutputType | null
    _min: TicketNoteMinAggregateOutputType | null
    _max: TicketNoteMaxAggregateOutputType | null
  }

  type GetTicketNoteGroupByPayload<T extends TicketNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketNoteGroupByOutputType[P]>
            : GetScalarType<T[P], TicketNoteGroupByOutputType[P]>
        }
      >
    >


  export type TicketNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isInternal?: boolean
    ticketId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketNote"]>

  export type TicketNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isInternal?: boolean
    ticketId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketNote"]>

  export type TicketNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isInternal?: boolean
    ticketId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketNote"]>

  export type TicketNoteSelectScalar = {
    id?: boolean
    content?: boolean
    isInternal?: boolean
    ticketId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "isInternal" | "ticketId" | "authorId" | "createdAt" | "updatedAt", ExtArgs["result"]["ticketNote"]>
  export type TicketNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketNote"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      isInternal: boolean
      ticketId: string
      authorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticketNote"]>
    composites: {}
  }

  type TicketNoteGetPayload<S extends boolean | null | undefined | TicketNoteDefaultArgs> = $Result.GetResult<Prisma.$TicketNotePayload, S>

  type TicketNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketNoteCountAggregateInputType | true
    }

  export interface TicketNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketNote'], meta: { name: 'TicketNote' } }
    /**
     * Find zero or one TicketNote that matches the filter.
     * @param {TicketNoteFindUniqueArgs} args - Arguments to find a TicketNote
     * @example
     * // Get one TicketNote
     * const ticketNote = await prisma.ticketNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketNoteFindUniqueArgs>(args: SelectSubset<T, TicketNoteFindUniqueArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketNoteFindUniqueOrThrowArgs} args - Arguments to find a TicketNote
     * @example
     * // Get one TicketNote
     * const ticketNote = await prisma.ticketNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteFindFirstArgs} args - Arguments to find a TicketNote
     * @example
     * // Get one TicketNote
     * const ticketNote = await prisma.ticketNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketNoteFindFirstArgs>(args?: SelectSubset<T, TicketNoteFindFirstArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteFindFirstOrThrowArgs} args - Arguments to find a TicketNote
     * @example
     * // Get one TicketNote
     * const ticketNote = await prisma.ticketNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketNotes
     * const ticketNotes = await prisma.ticketNote.findMany()
     * 
     * // Get first 10 TicketNotes
     * const ticketNotes = await prisma.ticketNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketNoteWithIdOnly = await prisma.ticketNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketNoteFindManyArgs>(args?: SelectSubset<T, TicketNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketNote.
     * @param {TicketNoteCreateArgs} args - Arguments to create a TicketNote.
     * @example
     * // Create one TicketNote
     * const TicketNote = await prisma.ticketNote.create({
     *   data: {
     *     // ... data to create a TicketNote
     *   }
     * })
     * 
     */
    create<T extends TicketNoteCreateArgs>(args: SelectSubset<T, TicketNoteCreateArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketNotes.
     * @param {TicketNoteCreateManyArgs} args - Arguments to create many TicketNotes.
     * @example
     * // Create many TicketNotes
     * const ticketNote = await prisma.ticketNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketNoteCreateManyArgs>(args?: SelectSubset<T, TicketNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketNotes and returns the data saved in the database.
     * @param {TicketNoteCreateManyAndReturnArgs} args - Arguments to create many TicketNotes.
     * @example
     * // Create many TicketNotes
     * const ticketNote = await prisma.ticketNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketNotes and only return the `id`
     * const ticketNoteWithIdOnly = await prisma.ticketNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketNote.
     * @param {TicketNoteDeleteArgs} args - Arguments to delete one TicketNote.
     * @example
     * // Delete one TicketNote
     * const TicketNote = await prisma.ticketNote.delete({
     *   where: {
     *     // ... filter to delete one TicketNote
     *   }
     * })
     * 
     */
    delete<T extends TicketNoteDeleteArgs>(args: SelectSubset<T, TicketNoteDeleteArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketNote.
     * @param {TicketNoteUpdateArgs} args - Arguments to update one TicketNote.
     * @example
     * // Update one TicketNote
     * const ticketNote = await prisma.ticketNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketNoteUpdateArgs>(args: SelectSubset<T, TicketNoteUpdateArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketNotes.
     * @param {TicketNoteDeleteManyArgs} args - Arguments to filter TicketNotes to delete.
     * @example
     * // Delete a few TicketNotes
     * const { count } = await prisma.ticketNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketNoteDeleteManyArgs>(args?: SelectSubset<T, TicketNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketNotes
     * const ticketNote = await prisma.ticketNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketNoteUpdateManyArgs>(args: SelectSubset<T, TicketNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketNotes and returns the data updated in the database.
     * @param {TicketNoteUpdateManyAndReturnArgs} args - Arguments to update many TicketNotes.
     * @example
     * // Update many TicketNotes
     * const ticketNote = await prisma.ticketNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketNotes and only return the `id`
     * const ticketNoteWithIdOnly = await prisma.ticketNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketNote.
     * @param {TicketNoteUpsertArgs} args - Arguments to update or create a TicketNote.
     * @example
     * // Update or create a TicketNote
     * const ticketNote = await prisma.ticketNote.upsert({
     *   create: {
     *     // ... data to create a TicketNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketNote we want to update
     *   }
     * })
     */
    upsert<T extends TicketNoteUpsertArgs>(args: SelectSubset<T, TicketNoteUpsertArgs<ExtArgs>>): Prisma__TicketNoteClient<$Result.GetResult<Prisma.$TicketNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteCountArgs} args - Arguments to filter TicketNotes to count.
     * @example
     * // Count the number of TicketNotes
     * const count = await prisma.ticketNote.count({
     *   where: {
     *     // ... the filter for the TicketNotes we want to count
     *   }
     * })
    **/
    count<T extends TicketNoteCountArgs>(
      args?: Subset<T, TicketNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketNoteAggregateArgs>(args: Subset<T, TicketNoteAggregateArgs>): Prisma.PrismaPromise<GetTicketNoteAggregateType<T>>

    /**
     * Group by TicketNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketNoteGroupByArgs['orderBy'] }
        : { orderBy?: TicketNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketNote model
   */
  readonly fields: TicketNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketNote model
   */
  interface TicketNoteFieldRefs {
    readonly id: FieldRef<"TicketNote", 'String'>
    readonly content: FieldRef<"TicketNote", 'String'>
    readonly isInternal: FieldRef<"TicketNote", 'Boolean'>
    readonly ticketId: FieldRef<"TicketNote", 'String'>
    readonly authorId: FieldRef<"TicketNote", 'String'>
    readonly createdAt: FieldRef<"TicketNote", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketNote findUnique
   */
  export type TicketNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNote to fetch.
     */
    where: TicketNoteWhereUniqueInput
  }

  /**
   * TicketNote findUniqueOrThrow
   */
  export type TicketNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNote to fetch.
     */
    where: TicketNoteWhereUniqueInput
  }

  /**
   * TicketNote findFirst
   */
  export type TicketNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNote to fetch.
     */
    where?: TicketNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketNotes to fetch.
     */
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketNotes.
     */
    cursor?: TicketNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketNotes.
     */
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
  }

  /**
   * TicketNote findFirstOrThrow
   */
  export type TicketNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNote to fetch.
     */
    where?: TicketNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketNotes to fetch.
     */
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketNotes.
     */
    cursor?: TicketNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketNotes.
     */
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
  }

  /**
   * TicketNote findMany
   */
  export type TicketNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter, which TicketNotes to fetch.
     */
    where?: TicketNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketNotes to fetch.
     */
    orderBy?: TicketNoteOrderByWithRelationInput | TicketNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketNotes.
     */
    cursor?: TicketNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketNotes.
     */
    skip?: number
    distinct?: TicketNoteScalarFieldEnum | TicketNoteScalarFieldEnum[]
  }

  /**
   * TicketNote create
   */
  export type TicketNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketNote.
     */
    data: XOR<TicketNoteCreateInput, TicketNoteUncheckedCreateInput>
  }

  /**
   * TicketNote createMany
   */
  export type TicketNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketNotes.
     */
    data: TicketNoteCreateManyInput | TicketNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketNote createManyAndReturn
   */
  export type TicketNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * The data used to create many TicketNotes.
     */
    data: TicketNoteCreateManyInput | TicketNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketNote update
   */
  export type TicketNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketNote.
     */
    data: XOR<TicketNoteUpdateInput, TicketNoteUncheckedUpdateInput>
    /**
     * Choose, which TicketNote to update.
     */
    where: TicketNoteWhereUniqueInput
  }

  /**
   * TicketNote updateMany
   */
  export type TicketNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketNotes.
     */
    data: XOR<TicketNoteUpdateManyMutationInput, TicketNoteUncheckedUpdateManyInput>
    /**
     * Filter which TicketNotes to update
     */
    where?: TicketNoteWhereInput
    /**
     * Limit how many TicketNotes to update.
     */
    limit?: number
  }

  /**
   * TicketNote updateManyAndReturn
   */
  export type TicketNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * The data used to update TicketNotes.
     */
    data: XOR<TicketNoteUpdateManyMutationInput, TicketNoteUncheckedUpdateManyInput>
    /**
     * Filter which TicketNotes to update
     */
    where?: TicketNoteWhereInput
    /**
     * Limit how many TicketNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketNote upsert
   */
  export type TicketNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketNote to update in case it exists.
     */
    where: TicketNoteWhereUniqueInput
    /**
     * In case the TicketNote found by the `where` argument doesn't exist, create a new TicketNote with this data.
     */
    create: XOR<TicketNoteCreateInput, TicketNoteUncheckedCreateInput>
    /**
     * In case the TicketNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketNoteUpdateInput, TicketNoteUncheckedUpdateInput>
  }

  /**
   * TicketNote delete
   */
  export type TicketNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
    /**
     * Filter which TicketNote to delete.
     */
    where: TicketNoteWhereUniqueInput
  }

  /**
   * TicketNote deleteMany
   */
  export type TicketNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketNotes to delete
     */
    where?: TicketNoteWhereInput
    /**
     * Limit how many TicketNotes to delete.
     */
    limit?: number
  }

  /**
   * TicketNote without action
   */
  export type TicketNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketNote
     */
    select?: TicketNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketNote
     */
    omit?: TicketNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketNoteInclude<ExtArgs> | null
  }


  /**
   * Model ServiceTemplate
   */

  export type AggregateServiceTemplate = {
    _count: ServiceTemplateCountAggregateOutputType | null
    _avg: ServiceTemplateAvgAggregateOutputType | null
    _sum: ServiceTemplateSumAggregateOutputType | null
    _min: ServiceTemplateMinAggregateOutputType | null
    _max: ServiceTemplateMaxAggregateOutputType | null
  }

  export type ServiceTemplateAvgAggregateOutputType = {
    estimatedDuration: number | null
    laborCost: Decimal | null
  }

  export type ServiceTemplateSumAggregateOutputType = {
    estimatedDuration: number | null
    laborCost: Decimal | null
  }

  export type ServiceTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.ServiceCategory | null
    defaultTitle: string | null
    defaultDescription: string | null
    defaultPriority: string | null
    estimatedDuration: number | null
    laborCost: Decimal | null
    isActive: boolean | null
    color: string | null
    icon: string | null
    tenantId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.ServiceCategory | null
    defaultTitle: string | null
    defaultDescription: string | null
    defaultPriority: string | null
    estimatedDuration: number | null
    laborCost: Decimal | null
    isActive: boolean | null
    color: string | null
    icon: string | null
    tenantId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTemplateCountAggregateOutputType = {
    id: number
    name: number
    category: number
    defaultTitle: number
    defaultDescription: number
    defaultPriority: number
    estimatedDuration: number
    laborCost: number
    isActive: number
    color: number
    icon: number
    tenantId: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceTemplateAvgAggregateInputType = {
    estimatedDuration?: true
    laborCost?: true
  }

  export type ServiceTemplateSumAggregateInputType = {
    estimatedDuration?: true
    laborCost?: true
  }

  export type ServiceTemplateMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    defaultTitle?: true
    defaultDescription?: true
    defaultPriority?: true
    estimatedDuration?: true
    laborCost?: true
    isActive?: true
    color?: true
    icon?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    defaultTitle?: true
    defaultDescription?: true
    defaultPriority?: true
    estimatedDuration?: true
    laborCost?: true
    isActive?: true
    color?: true
    icon?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTemplateCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    defaultTitle?: true
    defaultDescription?: true
    defaultPriority?: true
    estimatedDuration?: true
    laborCost?: true
    isActive?: true
    color?: true
    icon?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTemplate to aggregate.
     */
    where?: ServiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTemplates to fetch.
     */
    orderBy?: ServiceTemplateOrderByWithRelationInput | ServiceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTemplates
    **/
    _count?: true | ServiceTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTemplateMaxAggregateInputType
  }

  export type GetServiceTemplateAggregateType<T extends ServiceTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTemplate[P]>
      : GetScalarType<T[P], AggregateServiceTemplate[P]>
  }




  export type ServiceTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTemplateWhereInput
    orderBy?: ServiceTemplateOrderByWithAggregationInput | ServiceTemplateOrderByWithAggregationInput[]
    by: ServiceTemplateScalarFieldEnum[] | ServiceTemplateScalarFieldEnum
    having?: ServiceTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTemplateCountAggregateInputType | true
    _avg?: ServiceTemplateAvgAggregateInputType
    _sum?: ServiceTemplateSumAggregateInputType
    _min?: ServiceTemplateMinAggregateInputType
    _max?: ServiceTemplateMaxAggregateInputType
  }

  export type ServiceTemplateGroupByOutputType = {
    id: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority: string
    estimatedDuration: number | null
    laborCost: Decimal | null
    isActive: boolean
    color: string | null
    icon: string | null
    tenantId: string
    createdById: string | null
    updatedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceTemplateCountAggregateOutputType | null
    _avg: ServiceTemplateAvgAggregateOutputType | null
    _sum: ServiceTemplateSumAggregateOutputType | null
    _min: ServiceTemplateMinAggregateOutputType | null
    _max: ServiceTemplateMaxAggregateOutputType | null
  }

  type GetServiceTemplateGroupByPayload<T extends ServiceTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    defaultTitle?: boolean
    defaultDescription?: boolean
    defaultPriority?: boolean
    estimatedDuration?: boolean
    laborCost?: boolean
    isActive?: boolean
    color?: boolean
    icon?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | ServiceTemplate$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | ServiceTemplate$updatedByArgs<ExtArgs>
    defaultParts?: boolean | ServiceTemplate$defaultPartsArgs<ExtArgs>
    usages?: boolean | ServiceTemplate$usagesArgs<ExtArgs>
    tickets?: boolean | ServiceTemplate$ticketsArgs<ExtArgs>
    _count?: boolean | ServiceTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTemplate"]>

  export type ServiceTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    defaultTitle?: boolean
    defaultDescription?: boolean
    defaultPriority?: boolean
    estimatedDuration?: boolean
    laborCost?: boolean
    isActive?: boolean
    color?: boolean
    icon?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | ServiceTemplate$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | ServiceTemplate$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTemplate"]>

  export type ServiceTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    defaultTitle?: boolean
    defaultDescription?: boolean
    defaultPriority?: boolean
    estimatedDuration?: boolean
    laborCost?: boolean
    isActive?: boolean
    color?: boolean
    icon?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | ServiceTemplate$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | ServiceTemplate$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTemplate"]>

  export type ServiceTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    defaultTitle?: boolean
    defaultDescription?: boolean
    defaultPriority?: boolean
    estimatedDuration?: boolean
    laborCost?: boolean
    isActive?: boolean
    color?: boolean
    icon?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "defaultTitle" | "defaultDescription" | "defaultPriority" | "estimatedDuration" | "laborCost" | "isActive" | "color" | "icon" | "tenantId" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceTemplate"]>
  export type ServiceTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | ServiceTemplate$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | ServiceTemplate$updatedByArgs<ExtArgs>
    defaultParts?: boolean | ServiceTemplate$defaultPartsArgs<ExtArgs>
    usages?: boolean | ServiceTemplate$usagesArgs<ExtArgs>
    tickets?: boolean | ServiceTemplate$ticketsArgs<ExtArgs>
    _count?: boolean | ServiceTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | ServiceTemplate$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | ServiceTemplate$updatedByArgs<ExtArgs>
  }
  export type ServiceTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | ServiceTemplate$createdByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    updatedBy?: boolean | ServiceTemplate$updatedByArgs<ExtArgs>
  }

  export type $ServiceTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceTemplate"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      defaultParts: Prisma.$TemplateDefaultPartPayload<ExtArgs>[]
      usages: Prisma.$TicketServicePayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.ServiceCategory
      defaultTitle: string
      defaultDescription: string
      defaultPriority: string
      estimatedDuration: number | null
      laborCost: Prisma.Decimal | null
      isActive: boolean
      color: string | null
      icon: string | null
      tenantId: string
      createdById: string | null
      updatedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceTemplate"]>
    composites: {}
  }

  type ServiceTemplateGetPayload<S extends boolean | null | undefined | ServiceTemplateDefaultArgs> = $Result.GetResult<Prisma.$ServiceTemplatePayload, S>

  type ServiceTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceTemplateCountAggregateInputType | true
    }

  export interface ServiceTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTemplate'], meta: { name: 'ServiceTemplate' } }
    /**
     * Find zero or one ServiceTemplate that matches the filter.
     * @param {ServiceTemplateFindUniqueArgs} args - Arguments to find a ServiceTemplate
     * @example
     * // Get one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceTemplateFindUniqueArgs>(args: SelectSubset<T, ServiceTemplateFindUniqueArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceTemplateFindUniqueOrThrowArgs} args - Arguments to find a ServiceTemplate
     * @example
     * // Get one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateFindFirstArgs} args - Arguments to find a ServiceTemplate
     * @example
     * // Get one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceTemplateFindFirstArgs>(args?: SelectSubset<T, ServiceTemplateFindFirstArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateFindFirstOrThrowArgs} args - Arguments to find a ServiceTemplate
     * @example
     * // Get one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTemplates
     * const serviceTemplates = await prisma.serviceTemplate.findMany()
     * 
     * // Get first 10 ServiceTemplates
     * const serviceTemplates = await prisma.serviceTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTemplateWithIdOnly = await prisma.serviceTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceTemplateFindManyArgs>(args?: SelectSubset<T, ServiceTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceTemplate.
     * @param {ServiceTemplateCreateArgs} args - Arguments to create a ServiceTemplate.
     * @example
     * // Create one ServiceTemplate
     * const ServiceTemplate = await prisma.serviceTemplate.create({
     *   data: {
     *     // ... data to create a ServiceTemplate
     *   }
     * })
     * 
     */
    create<T extends ServiceTemplateCreateArgs>(args: SelectSubset<T, ServiceTemplateCreateArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceTemplates.
     * @param {ServiceTemplateCreateManyArgs} args - Arguments to create many ServiceTemplates.
     * @example
     * // Create many ServiceTemplates
     * const serviceTemplate = await prisma.serviceTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceTemplateCreateManyArgs>(args?: SelectSubset<T, ServiceTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceTemplates and returns the data saved in the database.
     * @param {ServiceTemplateCreateManyAndReturnArgs} args - Arguments to create many ServiceTemplates.
     * @example
     * // Create many ServiceTemplates
     * const serviceTemplate = await prisma.serviceTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceTemplates and only return the `id`
     * const serviceTemplateWithIdOnly = await prisma.serviceTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceTemplate.
     * @param {ServiceTemplateDeleteArgs} args - Arguments to delete one ServiceTemplate.
     * @example
     * // Delete one ServiceTemplate
     * const ServiceTemplate = await prisma.serviceTemplate.delete({
     *   where: {
     *     // ... filter to delete one ServiceTemplate
     *   }
     * })
     * 
     */
    delete<T extends ServiceTemplateDeleteArgs>(args: SelectSubset<T, ServiceTemplateDeleteArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceTemplate.
     * @param {ServiceTemplateUpdateArgs} args - Arguments to update one ServiceTemplate.
     * @example
     * // Update one ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceTemplateUpdateArgs>(args: SelectSubset<T, ServiceTemplateUpdateArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceTemplates.
     * @param {ServiceTemplateDeleteManyArgs} args - Arguments to filter ServiceTemplates to delete.
     * @example
     * // Delete a few ServiceTemplates
     * const { count } = await prisma.serviceTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceTemplateDeleteManyArgs>(args?: SelectSubset<T, ServiceTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTemplates
     * const serviceTemplate = await prisma.serviceTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceTemplateUpdateManyArgs>(args: SelectSubset<T, ServiceTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTemplates and returns the data updated in the database.
     * @param {ServiceTemplateUpdateManyAndReturnArgs} args - Arguments to update many ServiceTemplates.
     * @example
     * // Update many ServiceTemplates
     * const serviceTemplate = await prisma.serviceTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceTemplates and only return the `id`
     * const serviceTemplateWithIdOnly = await prisma.serviceTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceTemplate.
     * @param {ServiceTemplateUpsertArgs} args - Arguments to update or create a ServiceTemplate.
     * @example
     * // Update or create a ServiceTemplate
     * const serviceTemplate = await prisma.serviceTemplate.upsert({
     *   create: {
     *     // ... data to create a ServiceTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ServiceTemplateUpsertArgs>(args: SelectSubset<T, ServiceTemplateUpsertArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateCountArgs} args - Arguments to filter ServiceTemplates to count.
     * @example
     * // Count the number of ServiceTemplates
     * const count = await prisma.serviceTemplate.count({
     *   where: {
     *     // ... the filter for the ServiceTemplates we want to count
     *   }
     * })
    **/
    count<T extends ServiceTemplateCountArgs>(
      args?: Subset<T, ServiceTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTemplateAggregateArgs>(args: Subset<T, ServiceTemplateAggregateArgs>): Prisma.PrismaPromise<GetServiceTemplateAggregateType<T>>

    /**
     * Group by ServiceTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceTemplate model
   */
  readonly fields: ServiceTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends ServiceTemplate$createdByArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTemplate$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends ServiceTemplate$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTemplate$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    defaultParts<T extends ServiceTemplate$defaultPartsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTemplate$defaultPartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usages<T extends ServiceTemplate$usagesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTemplate$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends ServiceTemplate$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTemplate$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceTemplate model
   */
  interface ServiceTemplateFieldRefs {
    readonly id: FieldRef<"ServiceTemplate", 'String'>
    readonly name: FieldRef<"ServiceTemplate", 'String'>
    readonly category: FieldRef<"ServiceTemplate", 'ServiceCategory'>
    readonly defaultTitle: FieldRef<"ServiceTemplate", 'String'>
    readonly defaultDescription: FieldRef<"ServiceTemplate", 'String'>
    readonly defaultPriority: FieldRef<"ServiceTemplate", 'String'>
    readonly estimatedDuration: FieldRef<"ServiceTemplate", 'Int'>
    readonly laborCost: FieldRef<"ServiceTemplate", 'Decimal'>
    readonly isActive: FieldRef<"ServiceTemplate", 'Boolean'>
    readonly color: FieldRef<"ServiceTemplate", 'String'>
    readonly icon: FieldRef<"ServiceTemplate", 'String'>
    readonly tenantId: FieldRef<"ServiceTemplate", 'String'>
    readonly createdById: FieldRef<"ServiceTemplate", 'String'>
    readonly updatedById: FieldRef<"ServiceTemplate", 'String'>
    readonly createdAt: FieldRef<"ServiceTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceTemplate findUnique
   */
  export type ServiceTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplate to fetch.
     */
    where: ServiceTemplateWhereUniqueInput
  }

  /**
   * ServiceTemplate findUniqueOrThrow
   */
  export type ServiceTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplate to fetch.
     */
    where: ServiceTemplateWhereUniqueInput
  }

  /**
   * ServiceTemplate findFirst
   */
  export type ServiceTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplate to fetch.
     */
    where?: ServiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTemplates to fetch.
     */
    orderBy?: ServiceTemplateOrderByWithRelationInput | ServiceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTemplates.
     */
    cursor?: ServiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTemplates.
     */
    distinct?: ServiceTemplateScalarFieldEnum | ServiceTemplateScalarFieldEnum[]
  }

  /**
   * ServiceTemplate findFirstOrThrow
   */
  export type ServiceTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplate to fetch.
     */
    where?: ServiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTemplates to fetch.
     */
    orderBy?: ServiceTemplateOrderByWithRelationInput | ServiceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTemplates.
     */
    cursor?: ServiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTemplates.
     */
    distinct?: ServiceTemplateScalarFieldEnum | ServiceTemplateScalarFieldEnum[]
  }

  /**
   * ServiceTemplate findMany
   */
  export type ServiceTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTemplates to fetch.
     */
    where?: ServiceTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTemplates to fetch.
     */
    orderBy?: ServiceTemplateOrderByWithRelationInput | ServiceTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTemplates.
     */
    cursor?: ServiceTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTemplates.
     */
    skip?: number
    distinct?: ServiceTemplateScalarFieldEnum | ServiceTemplateScalarFieldEnum[]
  }

  /**
   * ServiceTemplate create
   */
  export type ServiceTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceTemplate.
     */
    data: XOR<ServiceTemplateCreateInput, ServiceTemplateUncheckedCreateInput>
  }

  /**
   * ServiceTemplate createMany
   */
  export type ServiceTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTemplates.
     */
    data: ServiceTemplateCreateManyInput | ServiceTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTemplate createManyAndReturn
   */
  export type ServiceTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceTemplates.
     */
    data: ServiceTemplateCreateManyInput | ServiceTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceTemplate update
   */
  export type ServiceTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceTemplate.
     */
    data: XOR<ServiceTemplateUpdateInput, ServiceTemplateUncheckedUpdateInput>
    /**
     * Choose, which ServiceTemplate to update.
     */
    where: ServiceTemplateWhereUniqueInput
  }

  /**
   * ServiceTemplate updateMany
   */
  export type ServiceTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTemplates.
     */
    data: XOR<ServiceTemplateUpdateManyMutationInput, ServiceTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTemplates to update
     */
    where?: ServiceTemplateWhereInput
    /**
     * Limit how many ServiceTemplates to update.
     */
    limit?: number
  }

  /**
   * ServiceTemplate updateManyAndReturn
   */
  export type ServiceTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ServiceTemplates.
     */
    data: XOR<ServiceTemplateUpdateManyMutationInput, ServiceTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTemplates to update
     */
    where?: ServiceTemplateWhereInput
    /**
     * Limit how many ServiceTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceTemplate upsert
   */
  export type ServiceTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceTemplate to update in case it exists.
     */
    where: ServiceTemplateWhereUniqueInput
    /**
     * In case the ServiceTemplate found by the `where` argument doesn't exist, create a new ServiceTemplate with this data.
     */
    create: XOR<ServiceTemplateCreateInput, ServiceTemplateUncheckedCreateInput>
    /**
     * In case the ServiceTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTemplateUpdateInput, ServiceTemplateUncheckedUpdateInput>
  }

  /**
   * ServiceTemplate delete
   */
  export type ServiceTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
    /**
     * Filter which ServiceTemplate to delete.
     */
    where: ServiceTemplateWhereUniqueInput
  }

  /**
   * ServiceTemplate deleteMany
   */
  export type ServiceTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTemplates to delete
     */
    where?: ServiceTemplateWhereInput
    /**
     * Limit how many ServiceTemplates to delete.
     */
    limit?: number
  }

  /**
   * ServiceTemplate.createdBy
   */
  export type ServiceTemplate$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ServiceTemplate.updatedBy
   */
  export type ServiceTemplate$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ServiceTemplate.defaultParts
   */
  export type ServiceTemplate$defaultPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    where?: TemplateDefaultPartWhereInput
    orderBy?: TemplateDefaultPartOrderByWithRelationInput | TemplateDefaultPartOrderByWithRelationInput[]
    cursor?: TemplateDefaultPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateDefaultPartScalarFieldEnum | TemplateDefaultPartScalarFieldEnum[]
  }

  /**
   * ServiceTemplate.usages
   */
  export type ServiceTemplate$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    where?: TicketServiceWhereInput
    orderBy?: TicketServiceOrderByWithRelationInput | TicketServiceOrderByWithRelationInput[]
    cursor?: TicketServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketServiceScalarFieldEnum | TicketServiceScalarFieldEnum[]
  }

  /**
   * ServiceTemplate.tickets
   */
  export type ServiceTemplate$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * ServiceTemplate without action
   */
  export type ServiceTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTemplate
     */
    select?: ServiceTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTemplate
     */
    omit?: ServiceTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTemplateInclude<ExtArgs> | null
  }


  /**
   * Model TemplateDefaultPart
   */

  export type AggregateTemplateDefaultPart = {
    _count: TemplateDefaultPartCountAggregateOutputType | null
    _avg: TemplateDefaultPartAvgAggregateOutputType | null
    _sum: TemplateDefaultPartSumAggregateOutputType | null
    _min: TemplateDefaultPartMinAggregateOutputType | null
    _max: TemplateDefaultPartMaxAggregateOutputType | null
  }

  export type TemplateDefaultPartAvgAggregateOutputType = {
    quantity: number | null
  }

  export type TemplateDefaultPartSumAggregateOutputType = {
    quantity: number | null
  }

  export type TemplateDefaultPartMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    required: boolean | null
    templateId: string | null
    partId: string | null
    createdAt: Date | null
  }

  export type TemplateDefaultPartMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    required: boolean | null
    templateId: string | null
    partId: string | null
    createdAt: Date | null
  }

  export type TemplateDefaultPartCountAggregateOutputType = {
    id: number
    quantity: number
    required: number
    templateId: number
    partId: number
    createdAt: number
    _all: number
  }


  export type TemplateDefaultPartAvgAggregateInputType = {
    quantity?: true
  }

  export type TemplateDefaultPartSumAggregateInputType = {
    quantity?: true
  }

  export type TemplateDefaultPartMinAggregateInputType = {
    id?: true
    quantity?: true
    required?: true
    templateId?: true
    partId?: true
    createdAt?: true
  }

  export type TemplateDefaultPartMaxAggregateInputType = {
    id?: true
    quantity?: true
    required?: true
    templateId?: true
    partId?: true
    createdAt?: true
  }

  export type TemplateDefaultPartCountAggregateInputType = {
    id?: true
    quantity?: true
    required?: true
    templateId?: true
    partId?: true
    createdAt?: true
    _all?: true
  }

  export type TemplateDefaultPartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateDefaultPart to aggregate.
     */
    where?: TemplateDefaultPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateDefaultParts to fetch.
     */
    orderBy?: TemplateDefaultPartOrderByWithRelationInput | TemplateDefaultPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateDefaultPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateDefaultParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateDefaultParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateDefaultParts
    **/
    _count?: true | TemplateDefaultPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateDefaultPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateDefaultPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateDefaultPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateDefaultPartMaxAggregateInputType
  }

  export type GetTemplateDefaultPartAggregateType<T extends TemplateDefaultPartAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateDefaultPart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateDefaultPart[P]>
      : GetScalarType<T[P], AggregateTemplateDefaultPart[P]>
  }




  export type TemplateDefaultPartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateDefaultPartWhereInput
    orderBy?: TemplateDefaultPartOrderByWithAggregationInput | TemplateDefaultPartOrderByWithAggregationInput[]
    by: TemplateDefaultPartScalarFieldEnum[] | TemplateDefaultPartScalarFieldEnum
    having?: TemplateDefaultPartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateDefaultPartCountAggregateInputType | true
    _avg?: TemplateDefaultPartAvgAggregateInputType
    _sum?: TemplateDefaultPartSumAggregateInputType
    _min?: TemplateDefaultPartMinAggregateInputType
    _max?: TemplateDefaultPartMaxAggregateInputType
  }

  export type TemplateDefaultPartGroupByOutputType = {
    id: string
    quantity: number
    required: boolean
    templateId: string
    partId: string
    createdAt: Date
    _count: TemplateDefaultPartCountAggregateOutputType | null
    _avg: TemplateDefaultPartAvgAggregateOutputType | null
    _sum: TemplateDefaultPartSumAggregateOutputType | null
    _min: TemplateDefaultPartMinAggregateOutputType | null
    _max: TemplateDefaultPartMaxAggregateOutputType | null
  }

  type GetTemplateDefaultPartGroupByPayload<T extends TemplateDefaultPartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateDefaultPartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateDefaultPartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateDefaultPartGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateDefaultPartGroupByOutputType[P]>
        }
      >
    >


  export type TemplateDefaultPartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    required?: boolean
    templateId?: boolean
    partId?: boolean
    createdAt?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    template?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateDefaultPart"]>

  export type TemplateDefaultPartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    required?: boolean
    templateId?: boolean
    partId?: boolean
    createdAt?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    template?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateDefaultPart"]>

  export type TemplateDefaultPartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    required?: boolean
    templateId?: boolean
    partId?: boolean
    createdAt?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    template?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateDefaultPart"]>

  export type TemplateDefaultPartSelectScalar = {
    id?: boolean
    quantity?: boolean
    required?: boolean
    templateId?: boolean
    partId?: boolean
    createdAt?: boolean
  }

  export type TemplateDefaultPartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "required" | "templateId" | "partId" | "createdAt", ExtArgs["result"]["templateDefaultPart"]>
  export type TemplateDefaultPartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    template?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
  }
  export type TemplateDefaultPartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    template?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
  }
  export type TemplateDefaultPartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    template?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
  }

  export type $TemplateDefaultPartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateDefaultPart"
    objects: {
      part: Prisma.$PartPayload<ExtArgs>
      template: Prisma.$ServiceTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      required: boolean
      templateId: string
      partId: string
      createdAt: Date
    }, ExtArgs["result"]["templateDefaultPart"]>
    composites: {}
  }

  type TemplateDefaultPartGetPayload<S extends boolean | null | undefined | TemplateDefaultPartDefaultArgs> = $Result.GetResult<Prisma.$TemplateDefaultPartPayload, S>

  type TemplateDefaultPartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateDefaultPartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateDefaultPartCountAggregateInputType | true
    }

  export interface TemplateDefaultPartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateDefaultPart'], meta: { name: 'TemplateDefaultPart' } }
    /**
     * Find zero or one TemplateDefaultPart that matches the filter.
     * @param {TemplateDefaultPartFindUniqueArgs} args - Arguments to find a TemplateDefaultPart
     * @example
     * // Get one TemplateDefaultPart
     * const templateDefaultPart = await prisma.templateDefaultPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateDefaultPartFindUniqueArgs>(args: SelectSubset<T, TemplateDefaultPartFindUniqueArgs<ExtArgs>>): Prisma__TemplateDefaultPartClient<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TemplateDefaultPart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateDefaultPartFindUniqueOrThrowArgs} args - Arguments to find a TemplateDefaultPart
     * @example
     * // Get one TemplateDefaultPart
     * const templateDefaultPart = await prisma.templateDefaultPart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateDefaultPartFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateDefaultPartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateDefaultPartClient<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateDefaultPart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDefaultPartFindFirstArgs} args - Arguments to find a TemplateDefaultPart
     * @example
     * // Get one TemplateDefaultPart
     * const templateDefaultPart = await prisma.templateDefaultPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateDefaultPartFindFirstArgs>(args?: SelectSubset<T, TemplateDefaultPartFindFirstArgs<ExtArgs>>): Prisma__TemplateDefaultPartClient<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateDefaultPart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDefaultPartFindFirstOrThrowArgs} args - Arguments to find a TemplateDefaultPart
     * @example
     * // Get one TemplateDefaultPart
     * const templateDefaultPart = await prisma.templateDefaultPart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateDefaultPartFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateDefaultPartFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateDefaultPartClient<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TemplateDefaultParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDefaultPartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateDefaultParts
     * const templateDefaultParts = await prisma.templateDefaultPart.findMany()
     * 
     * // Get first 10 TemplateDefaultParts
     * const templateDefaultParts = await prisma.templateDefaultPart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateDefaultPartWithIdOnly = await prisma.templateDefaultPart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateDefaultPartFindManyArgs>(args?: SelectSubset<T, TemplateDefaultPartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TemplateDefaultPart.
     * @param {TemplateDefaultPartCreateArgs} args - Arguments to create a TemplateDefaultPart.
     * @example
     * // Create one TemplateDefaultPart
     * const TemplateDefaultPart = await prisma.templateDefaultPart.create({
     *   data: {
     *     // ... data to create a TemplateDefaultPart
     *   }
     * })
     * 
     */
    create<T extends TemplateDefaultPartCreateArgs>(args: SelectSubset<T, TemplateDefaultPartCreateArgs<ExtArgs>>): Prisma__TemplateDefaultPartClient<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TemplateDefaultParts.
     * @param {TemplateDefaultPartCreateManyArgs} args - Arguments to create many TemplateDefaultParts.
     * @example
     * // Create many TemplateDefaultParts
     * const templateDefaultPart = await prisma.templateDefaultPart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateDefaultPartCreateManyArgs>(args?: SelectSubset<T, TemplateDefaultPartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateDefaultParts and returns the data saved in the database.
     * @param {TemplateDefaultPartCreateManyAndReturnArgs} args - Arguments to create many TemplateDefaultParts.
     * @example
     * // Create many TemplateDefaultParts
     * const templateDefaultPart = await prisma.templateDefaultPart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateDefaultParts and only return the `id`
     * const templateDefaultPartWithIdOnly = await prisma.templateDefaultPart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateDefaultPartCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateDefaultPartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TemplateDefaultPart.
     * @param {TemplateDefaultPartDeleteArgs} args - Arguments to delete one TemplateDefaultPart.
     * @example
     * // Delete one TemplateDefaultPart
     * const TemplateDefaultPart = await prisma.templateDefaultPart.delete({
     *   where: {
     *     // ... filter to delete one TemplateDefaultPart
     *   }
     * })
     * 
     */
    delete<T extends TemplateDefaultPartDeleteArgs>(args: SelectSubset<T, TemplateDefaultPartDeleteArgs<ExtArgs>>): Prisma__TemplateDefaultPartClient<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TemplateDefaultPart.
     * @param {TemplateDefaultPartUpdateArgs} args - Arguments to update one TemplateDefaultPart.
     * @example
     * // Update one TemplateDefaultPart
     * const templateDefaultPart = await prisma.templateDefaultPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateDefaultPartUpdateArgs>(args: SelectSubset<T, TemplateDefaultPartUpdateArgs<ExtArgs>>): Prisma__TemplateDefaultPartClient<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TemplateDefaultParts.
     * @param {TemplateDefaultPartDeleteManyArgs} args - Arguments to filter TemplateDefaultParts to delete.
     * @example
     * // Delete a few TemplateDefaultParts
     * const { count } = await prisma.templateDefaultPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDefaultPartDeleteManyArgs>(args?: SelectSubset<T, TemplateDefaultPartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateDefaultParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDefaultPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateDefaultParts
     * const templateDefaultPart = await prisma.templateDefaultPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateDefaultPartUpdateManyArgs>(args: SelectSubset<T, TemplateDefaultPartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateDefaultParts and returns the data updated in the database.
     * @param {TemplateDefaultPartUpdateManyAndReturnArgs} args - Arguments to update many TemplateDefaultParts.
     * @example
     * // Update many TemplateDefaultParts
     * const templateDefaultPart = await prisma.templateDefaultPart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateDefaultParts and only return the `id`
     * const templateDefaultPartWithIdOnly = await prisma.templateDefaultPart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateDefaultPartUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateDefaultPartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TemplateDefaultPart.
     * @param {TemplateDefaultPartUpsertArgs} args - Arguments to update or create a TemplateDefaultPart.
     * @example
     * // Update or create a TemplateDefaultPart
     * const templateDefaultPart = await prisma.templateDefaultPart.upsert({
     *   create: {
     *     // ... data to create a TemplateDefaultPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateDefaultPart we want to update
     *   }
     * })
     */
    upsert<T extends TemplateDefaultPartUpsertArgs>(args: SelectSubset<T, TemplateDefaultPartUpsertArgs<ExtArgs>>): Prisma__TemplateDefaultPartClient<$Result.GetResult<Prisma.$TemplateDefaultPartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TemplateDefaultParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDefaultPartCountArgs} args - Arguments to filter TemplateDefaultParts to count.
     * @example
     * // Count the number of TemplateDefaultParts
     * const count = await prisma.templateDefaultPart.count({
     *   where: {
     *     // ... the filter for the TemplateDefaultParts we want to count
     *   }
     * })
    **/
    count<T extends TemplateDefaultPartCountArgs>(
      args?: Subset<T, TemplateDefaultPartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateDefaultPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateDefaultPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDefaultPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateDefaultPartAggregateArgs>(args: Subset<T, TemplateDefaultPartAggregateArgs>): Prisma.PrismaPromise<GetTemplateDefaultPartAggregateType<T>>

    /**
     * Group by TemplateDefaultPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDefaultPartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateDefaultPartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateDefaultPartGroupByArgs['orderBy'] }
        : { orderBy?: TemplateDefaultPartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateDefaultPartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateDefaultPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateDefaultPart model
   */
  readonly fields: TemplateDefaultPartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateDefaultPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateDefaultPartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    part<T extends PartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartDefaultArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends ServiceTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTemplateDefaultArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateDefaultPart model
   */
  interface TemplateDefaultPartFieldRefs {
    readonly id: FieldRef<"TemplateDefaultPart", 'String'>
    readonly quantity: FieldRef<"TemplateDefaultPart", 'Int'>
    readonly required: FieldRef<"TemplateDefaultPart", 'Boolean'>
    readonly templateId: FieldRef<"TemplateDefaultPart", 'String'>
    readonly partId: FieldRef<"TemplateDefaultPart", 'String'>
    readonly createdAt: FieldRef<"TemplateDefaultPart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateDefaultPart findUnique
   */
  export type TemplateDefaultPartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * Filter, which TemplateDefaultPart to fetch.
     */
    where: TemplateDefaultPartWhereUniqueInput
  }

  /**
   * TemplateDefaultPart findUniqueOrThrow
   */
  export type TemplateDefaultPartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * Filter, which TemplateDefaultPart to fetch.
     */
    where: TemplateDefaultPartWhereUniqueInput
  }

  /**
   * TemplateDefaultPart findFirst
   */
  export type TemplateDefaultPartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * Filter, which TemplateDefaultPart to fetch.
     */
    where?: TemplateDefaultPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateDefaultParts to fetch.
     */
    orderBy?: TemplateDefaultPartOrderByWithRelationInput | TemplateDefaultPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateDefaultParts.
     */
    cursor?: TemplateDefaultPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateDefaultParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateDefaultParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateDefaultParts.
     */
    distinct?: TemplateDefaultPartScalarFieldEnum | TemplateDefaultPartScalarFieldEnum[]
  }

  /**
   * TemplateDefaultPart findFirstOrThrow
   */
  export type TemplateDefaultPartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * Filter, which TemplateDefaultPart to fetch.
     */
    where?: TemplateDefaultPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateDefaultParts to fetch.
     */
    orderBy?: TemplateDefaultPartOrderByWithRelationInput | TemplateDefaultPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateDefaultParts.
     */
    cursor?: TemplateDefaultPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateDefaultParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateDefaultParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateDefaultParts.
     */
    distinct?: TemplateDefaultPartScalarFieldEnum | TemplateDefaultPartScalarFieldEnum[]
  }

  /**
   * TemplateDefaultPart findMany
   */
  export type TemplateDefaultPartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * Filter, which TemplateDefaultParts to fetch.
     */
    where?: TemplateDefaultPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateDefaultParts to fetch.
     */
    orderBy?: TemplateDefaultPartOrderByWithRelationInput | TemplateDefaultPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateDefaultParts.
     */
    cursor?: TemplateDefaultPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateDefaultParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateDefaultParts.
     */
    skip?: number
    distinct?: TemplateDefaultPartScalarFieldEnum | TemplateDefaultPartScalarFieldEnum[]
  }

  /**
   * TemplateDefaultPart create
   */
  export type TemplateDefaultPartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateDefaultPart.
     */
    data: XOR<TemplateDefaultPartCreateInput, TemplateDefaultPartUncheckedCreateInput>
  }

  /**
   * TemplateDefaultPart createMany
   */
  export type TemplateDefaultPartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateDefaultParts.
     */
    data: TemplateDefaultPartCreateManyInput | TemplateDefaultPartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateDefaultPart createManyAndReturn
   */
  export type TemplateDefaultPartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateDefaultParts.
     */
    data: TemplateDefaultPartCreateManyInput | TemplateDefaultPartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateDefaultPart update
   */
  export type TemplateDefaultPartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateDefaultPart.
     */
    data: XOR<TemplateDefaultPartUpdateInput, TemplateDefaultPartUncheckedUpdateInput>
    /**
     * Choose, which TemplateDefaultPart to update.
     */
    where: TemplateDefaultPartWhereUniqueInput
  }

  /**
   * TemplateDefaultPart updateMany
   */
  export type TemplateDefaultPartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateDefaultParts.
     */
    data: XOR<TemplateDefaultPartUpdateManyMutationInput, TemplateDefaultPartUncheckedUpdateManyInput>
    /**
     * Filter which TemplateDefaultParts to update
     */
    where?: TemplateDefaultPartWhereInput
    /**
     * Limit how many TemplateDefaultParts to update.
     */
    limit?: number
  }

  /**
   * TemplateDefaultPart updateManyAndReturn
   */
  export type TemplateDefaultPartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * The data used to update TemplateDefaultParts.
     */
    data: XOR<TemplateDefaultPartUpdateManyMutationInput, TemplateDefaultPartUncheckedUpdateManyInput>
    /**
     * Filter which TemplateDefaultParts to update
     */
    where?: TemplateDefaultPartWhereInput
    /**
     * Limit how many TemplateDefaultParts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateDefaultPart upsert
   */
  export type TemplateDefaultPartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateDefaultPart to update in case it exists.
     */
    where: TemplateDefaultPartWhereUniqueInput
    /**
     * In case the TemplateDefaultPart found by the `where` argument doesn't exist, create a new TemplateDefaultPart with this data.
     */
    create: XOR<TemplateDefaultPartCreateInput, TemplateDefaultPartUncheckedCreateInput>
    /**
     * In case the TemplateDefaultPart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateDefaultPartUpdateInput, TemplateDefaultPartUncheckedUpdateInput>
  }

  /**
   * TemplateDefaultPart delete
   */
  export type TemplateDefaultPartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
    /**
     * Filter which TemplateDefaultPart to delete.
     */
    where: TemplateDefaultPartWhereUniqueInput
  }

  /**
   * TemplateDefaultPart deleteMany
   */
  export type TemplateDefaultPartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateDefaultParts to delete
     */
    where?: TemplateDefaultPartWhereInput
    /**
     * Limit how many TemplateDefaultParts to delete.
     */
    limit?: number
  }

  /**
   * TemplateDefaultPart without action
   */
  export type TemplateDefaultPartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateDefaultPart
     */
    select?: TemplateDefaultPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateDefaultPart
     */
    omit?: TemplateDefaultPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateDefaultPartInclude<ExtArgs> | null
  }


  /**
   * Model TicketService
   */

  export type AggregateTicketService = {
    _count: TicketServiceCountAggregateOutputType | null
    _avg: TicketServiceAvgAggregateOutputType | null
    _sum: TicketServiceSumAggregateOutputType | null
    _min: TicketServiceMinAggregateOutputType | null
    _max: TicketServiceMaxAggregateOutputType | null
  }

  export type TicketServiceAvgAggregateOutputType = {
    laborCost: Decimal | null
  }

  export type TicketServiceSumAggregateOutputType = {
    laborCost: Decimal | null
  }

  export type TicketServiceMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    serviceId: string | null
    name: string | null
    laborCost: Decimal | null
    createdAt: Date | null
  }

  export type TicketServiceMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    serviceId: string | null
    name: string | null
    laborCost: Decimal | null
    createdAt: Date | null
  }

  export type TicketServiceCountAggregateOutputType = {
    id: number
    ticketId: number
    serviceId: number
    name: number
    laborCost: number
    createdAt: number
    _all: number
  }


  export type TicketServiceAvgAggregateInputType = {
    laborCost?: true
  }

  export type TicketServiceSumAggregateInputType = {
    laborCost?: true
  }

  export type TicketServiceMinAggregateInputType = {
    id?: true
    ticketId?: true
    serviceId?: true
    name?: true
    laborCost?: true
    createdAt?: true
  }

  export type TicketServiceMaxAggregateInputType = {
    id?: true
    ticketId?: true
    serviceId?: true
    name?: true
    laborCost?: true
    createdAt?: true
  }

  export type TicketServiceCountAggregateInputType = {
    id?: true
    ticketId?: true
    serviceId?: true
    name?: true
    laborCost?: true
    createdAt?: true
    _all?: true
  }

  export type TicketServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketService to aggregate.
     */
    where?: TicketServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketServices to fetch.
     */
    orderBy?: TicketServiceOrderByWithRelationInput | TicketServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketServices
    **/
    _count?: true | TicketServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketServiceMaxAggregateInputType
  }

  export type GetTicketServiceAggregateType<T extends TicketServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketService[P]>
      : GetScalarType<T[P], AggregateTicketService[P]>
  }




  export type TicketServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketServiceWhereInput
    orderBy?: TicketServiceOrderByWithAggregationInput | TicketServiceOrderByWithAggregationInput[]
    by: TicketServiceScalarFieldEnum[] | TicketServiceScalarFieldEnum
    having?: TicketServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketServiceCountAggregateInputType | true
    _avg?: TicketServiceAvgAggregateInputType
    _sum?: TicketServiceSumAggregateInputType
    _min?: TicketServiceMinAggregateInputType
    _max?: TicketServiceMaxAggregateInputType
  }

  export type TicketServiceGroupByOutputType = {
    id: string
    ticketId: string
    serviceId: string
    name: string
    laborCost: Decimal
    createdAt: Date
    _count: TicketServiceCountAggregateOutputType | null
    _avg: TicketServiceAvgAggregateOutputType | null
    _sum: TicketServiceSumAggregateOutputType | null
    _min: TicketServiceMinAggregateOutputType | null
    _max: TicketServiceMaxAggregateOutputType | null
  }

  type GetTicketServiceGroupByPayload<T extends TicketServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketServiceGroupByOutputType[P]>
            : GetScalarType<T[P], TicketServiceGroupByOutputType[P]>
        }
      >
    >


  export type TicketServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    serviceId?: boolean
    name?: boolean
    laborCost?: boolean
    createdAt?: boolean
    service?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketService"]>

  export type TicketServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    serviceId?: boolean
    name?: boolean
    laborCost?: boolean
    createdAt?: boolean
    service?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketService"]>

  export type TicketServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    serviceId?: boolean
    name?: boolean
    laborCost?: boolean
    createdAt?: boolean
    service?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketService"]>

  export type TicketServiceSelectScalar = {
    id?: boolean
    ticketId?: boolean
    serviceId?: boolean
    name?: boolean
    laborCost?: boolean
    createdAt?: boolean
  }

  export type TicketServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "serviceId" | "name" | "laborCost" | "createdAt", ExtArgs["result"]["ticketService"]>
  export type TicketServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }
  export type TicketServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceTemplateDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
  }

  export type $TicketServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketService"
    objects: {
      service: Prisma.$ServiceTemplatePayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      serviceId: string
      name: string
      laborCost: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["ticketService"]>
    composites: {}
  }

  type TicketServiceGetPayload<S extends boolean | null | undefined | TicketServiceDefaultArgs> = $Result.GetResult<Prisma.$TicketServicePayload, S>

  type TicketServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketServiceCountAggregateInputType | true
    }

  export interface TicketServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketService'], meta: { name: 'TicketService' } }
    /**
     * Find zero or one TicketService that matches the filter.
     * @param {TicketServiceFindUniqueArgs} args - Arguments to find a TicketService
     * @example
     * // Get one TicketService
     * const ticketService = await prisma.ticketService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketServiceFindUniqueArgs>(args: SelectSubset<T, TicketServiceFindUniqueArgs<ExtArgs>>): Prisma__TicketServiceClient<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketServiceFindUniqueOrThrowArgs} args - Arguments to find a TicketService
     * @example
     * // Get one TicketService
     * const ticketService = await prisma.ticketService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketServiceClient<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketServiceFindFirstArgs} args - Arguments to find a TicketService
     * @example
     * // Get one TicketService
     * const ticketService = await prisma.ticketService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketServiceFindFirstArgs>(args?: SelectSubset<T, TicketServiceFindFirstArgs<ExtArgs>>): Prisma__TicketServiceClient<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketServiceFindFirstOrThrowArgs} args - Arguments to find a TicketService
     * @example
     * // Get one TicketService
     * const ticketService = await prisma.ticketService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketServiceClient<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketServices
     * const ticketServices = await prisma.ticketService.findMany()
     * 
     * // Get first 10 TicketServices
     * const ticketServices = await prisma.ticketService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketServiceWithIdOnly = await prisma.ticketService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketServiceFindManyArgs>(args?: SelectSubset<T, TicketServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketService.
     * @param {TicketServiceCreateArgs} args - Arguments to create a TicketService.
     * @example
     * // Create one TicketService
     * const TicketService = await prisma.ticketService.create({
     *   data: {
     *     // ... data to create a TicketService
     *   }
     * })
     * 
     */
    create<T extends TicketServiceCreateArgs>(args: SelectSubset<T, TicketServiceCreateArgs<ExtArgs>>): Prisma__TicketServiceClient<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketServices.
     * @param {TicketServiceCreateManyArgs} args - Arguments to create many TicketServices.
     * @example
     * // Create many TicketServices
     * const ticketService = await prisma.ticketService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketServiceCreateManyArgs>(args?: SelectSubset<T, TicketServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketServices and returns the data saved in the database.
     * @param {TicketServiceCreateManyAndReturnArgs} args - Arguments to create many TicketServices.
     * @example
     * // Create many TicketServices
     * const ticketService = await prisma.ticketService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketServices and only return the `id`
     * const ticketServiceWithIdOnly = await prisma.ticketService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketService.
     * @param {TicketServiceDeleteArgs} args - Arguments to delete one TicketService.
     * @example
     * // Delete one TicketService
     * const TicketService = await prisma.ticketService.delete({
     *   where: {
     *     // ... filter to delete one TicketService
     *   }
     * })
     * 
     */
    delete<T extends TicketServiceDeleteArgs>(args: SelectSubset<T, TicketServiceDeleteArgs<ExtArgs>>): Prisma__TicketServiceClient<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketService.
     * @param {TicketServiceUpdateArgs} args - Arguments to update one TicketService.
     * @example
     * // Update one TicketService
     * const ticketService = await prisma.ticketService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketServiceUpdateArgs>(args: SelectSubset<T, TicketServiceUpdateArgs<ExtArgs>>): Prisma__TicketServiceClient<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketServices.
     * @param {TicketServiceDeleteManyArgs} args - Arguments to filter TicketServices to delete.
     * @example
     * // Delete a few TicketServices
     * const { count } = await prisma.ticketService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketServiceDeleteManyArgs>(args?: SelectSubset<T, TicketServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketServices
     * const ticketService = await prisma.ticketService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketServiceUpdateManyArgs>(args: SelectSubset<T, TicketServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketServices and returns the data updated in the database.
     * @param {TicketServiceUpdateManyAndReturnArgs} args - Arguments to update many TicketServices.
     * @example
     * // Update many TicketServices
     * const ticketService = await prisma.ticketService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketServices and only return the `id`
     * const ticketServiceWithIdOnly = await prisma.ticketService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketService.
     * @param {TicketServiceUpsertArgs} args - Arguments to update or create a TicketService.
     * @example
     * // Update or create a TicketService
     * const ticketService = await prisma.ticketService.upsert({
     *   create: {
     *     // ... data to create a TicketService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketService we want to update
     *   }
     * })
     */
    upsert<T extends TicketServiceUpsertArgs>(args: SelectSubset<T, TicketServiceUpsertArgs<ExtArgs>>): Prisma__TicketServiceClient<$Result.GetResult<Prisma.$TicketServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketServiceCountArgs} args - Arguments to filter TicketServices to count.
     * @example
     * // Count the number of TicketServices
     * const count = await prisma.ticketService.count({
     *   where: {
     *     // ... the filter for the TicketServices we want to count
     *   }
     * })
    **/
    count<T extends TicketServiceCountArgs>(
      args?: Subset<T, TicketServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketServiceAggregateArgs>(args: Subset<T, TicketServiceAggregateArgs>): Prisma.PrismaPromise<GetTicketServiceAggregateType<T>>

    /**
     * Group by TicketService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketServiceGroupByArgs['orderBy'] }
        : { orderBy?: TicketServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketService model
   */
  readonly fields: TicketServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTemplateDefaultArgs<ExtArgs>>): Prisma__ServiceTemplateClient<$Result.GetResult<Prisma.$ServiceTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketService model
   */
  interface TicketServiceFieldRefs {
    readonly id: FieldRef<"TicketService", 'String'>
    readonly ticketId: FieldRef<"TicketService", 'String'>
    readonly serviceId: FieldRef<"TicketService", 'String'>
    readonly name: FieldRef<"TicketService", 'String'>
    readonly laborCost: FieldRef<"TicketService", 'Decimal'>
    readonly createdAt: FieldRef<"TicketService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketService findUnique
   */
  export type TicketServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * Filter, which TicketService to fetch.
     */
    where: TicketServiceWhereUniqueInput
  }

  /**
   * TicketService findUniqueOrThrow
   */
  export type TicketServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * Filter, which TicketService to fetch.
     */
    where: TicketServiceWhereUniqueInput
  }

  /**
   * TicketService findFirst
   */
  export type TicketServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * Filter, which TicketService to fetch.
     */
    where?: TicketServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketServices to fetch.
     */
    orderBy?: TicketServiceOrderByWithRelationInput | TicketServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketServices.
     */
    cursor?: TicketServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketServices.
     */
    distinct?: TicketServiceScalarFieldEnum | TicketServiceScalarFieldEnum[]
  }

  /**
   * TicketService findFirstOrThrow
   */
  export type TicketServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * Filter, which TicketService to fetch.
     */
    where?: TicketServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketServices to fetch.
     */
    orderBy?: TicketServiceOrderByWithRelationInput | TicketServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketServices.
     */
    cursor?: TicketServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketServices.
     */
    distinct?: TicketServiceScalarFieldEnum | TicketServiceScalarFieldEnum[]
  }

  /**
   * TicketService findMany
   */
  export type TicketServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * Filter, which TicketServices to fetch.
     */
    where?: TicketServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketServices to fetch.
     */
    orderBy?: TicketServiceOrderByWithRelationInput | TicketServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketServices.
     */
    cursor?: TicketServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketServices.
     */
    skip?: number
    distinct?: TicketServiceScalarFieldEnum | TicketServiceScalarFieldEnum[]
  }

  /**
   * TicketService create
   */
  export type TicketServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketService.
     */
    data: XOR<TicketServiceCreateInput, TicketServiceUncheckedCreateInput>
  }

  /**
   * TicketService createMany
   */
  export type TicketServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketServices.
     */
    data: TicketServiceCreateManyInput | TicketServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketService createManyAndReturn
   */
  export type TicketServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * The data used to create many TicketServices.
     */
    data: TicketServiceCreateManyInput | TicketServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketService update
   */
  export type TicketServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketService.
     */
    data: XOR<TicketServiceUpdateInput, TicketServiceUncheckedUpdateInput>
    /**
     * Choose, which TicketService to update.
     */
    where: TicketServiceWhereUniqueInput
  }

  /**
   * TicketService updateMany
   */
  export type TicketServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketServices.
     */
    data: XOR<TicketServiceUpdateManyMutationInput, TicketServiceUncheckedUpdateManyInput>
    /**
     * Filter which TicketServices to update
     */
    where?: TicketServiceWhereInput
    /**
     * Limit how many TicketServices to update.
     */
    limit?: number
  }

  /**
   * TicketService updateManyAndReturn
   */
  export type TicketServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * The data used to update TicketServices.
     */
    data: XOR<TicketServiceUpdateManyMutationInput, TicketServiceUncheckedUpdateManyInput>
    /**
     * Filter which TicketServices to update
     */
    where?: TicketServiceWhereInput
    /**
     * Limit how many TicketServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketService upsert
   */
  export type TicketServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketService to update in case it exists.
     */
    where: TicketServiceWhereUniqueInput
    /**
     * In case the TicketService found by the `where` argument doesn't exist, create a new TicketService with this data.
     */
    create: XOR<TicketServiceCreateInput, TicketServiceUncheckedCreateInput>
    /**
     * In case the TicketService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketServiceUpdateInput, TicketServiceUncheckedUpdateInput>
  }

  /**
   * TicketService delete
   */
  export type TicketServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
    /**
     * Filter which TicketService to delete.
     */
    where: TicketServiceWhereUniqueInput
  }

  /**
   * TicketService deleteMany
   */
  export type TicketServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketServices to delete
     */
    where?: TicketServiceWhereInput
    /**
     * Limit how many TicketServices to delete.
     */
    limit?: number
  }

  /**
   * TicketService without action
   */
  export type TicketServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketService
     */
    select?: TicketServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketService
     */
    omit?: TicketServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketServiceInclude<ExtArgs> | null
  }


  /**
   * Model TechnicianSpecialization
   */

  export type AggregateTechnicianSpecialization = {
    _count: TechnicianSpecializationCountAggregateOutputType | null
    _min: TechnicianSpecializationMinAggregateOutputType | null
    _max: TechnicianSpecializationMaxAggregateOutputType | null
  }

  export type TechnicianSpecializationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    specialization: $Enums.Specialization | null
    createdAt: Date | null
  }

  export type TechnicianSpecializationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    specialization: $Enums.Specialization | null
    createdAt: Date | null
  }

  export type TechnicianSpecializationCountAggregateOutputType = {
    id: number
    userId: number
    specialization: number
    createdAt: number
    _all: number
  }


  export type TechnicianSpecializationMinAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    createdAt?: true
  }

  export type TechnicianSpecializationMaxAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    createdAt?: true
  }

  export type TechnicianSpecializationCountAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    createdAt?: true
    _all?: true
  }

  export type TechnicianSpecializationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicianSpecialization to aggregate.
     */
    where?: TechnicianSpecializationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianSpecializations to fetch.
     */
    orderBy?: TechnicianSpecializationOrderByWithRelationInput | TechnicianSpecializationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicianSpecializationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianSpecializations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianSpecializations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicianSpecializations
    **/
    _count?: true | TechnicianSpecializationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicianSpecializationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicianSpecializationMaxAggregateInputType
  }

  export type GetTechnicianSpecializationAggregateType<T extends TechnicianSpecializationAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicianSpecialization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicianSpecialization[P]>
      : GetScalarType<T[P], AggregateTechnicianSpecialization[P]>
  }




  export type TechnicianSpecializationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicianSpecializationWhereInput
    orderBy?: TechnicianSpecializationOrderByWithAggregationInput | TechnicianSpecializationOrderByWithAggregationInput[]
    by: TechnicianSpecializationScalarFieldEnum[] | TechnicianSpecializationScalarFieldEnum
    having?: TechnicianSpecializationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicianSpecializationCountAggregateInputType | true
    _min?: TechnicianSpecializationMinAggregateInputType
    _max?: TechnicianSpecializationMaxAggregateInputType
  }

  export type TechnicianSpecializationGroupByOutputType = {
    id: string
    userId: string
    specialization: $Enums.Specialization
    createdAt: Date
    _count: TechnicianSpecializationCountAggregateOutputType | null
    _min: TechnicianSpecializationMinAggregateOutputType | null
    _max: TechnicianSpecializationMaxAggregateOutputType | null
  }

  type GetTechnicianSpecializationGroupByPayload<T extends TechnicianSpecializationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicianSpecializationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicianSpecializationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicianSpecializationGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicianSpecializationGroupByOutputType[P]>
        }
      >
    >


  export type TechnicianSpecializationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicianSpecialization"]>

  export type TechnicianSpecializationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicianSpecialization"]>

  export type TechnicianSpecializationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicianSpecialization"]>

  export type TechnicianSpecializationSelectScalar = {
    id?: boolean
    userId?: boolean
    specialization?: boolean
    createdAt?: boolean
  }

  export type TechnicianSpecializationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "specialization" | "createdAt", ExtArgs["result"]["technicianSpecialization"]>
  export type TechnicianSpecializationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TechnicianSpecializationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TechnicianSpecializationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TechnicianSpecializationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicianSpecialization"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      specialization: $Enums.Specialization
      createdAt: Date
    }, ExtArgs["result"]["technicianSpecialization"]>
    composites: {}
  }

  type TechnicianSpecializationGetPayload<S extends boolean | null | undefined | TechnicianSpecializationDefaultArgs> = $Result.GetResult<Prisma.$TechnicianSpecializationPayload, S>

  type TechnicianSpecializationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechnicianSpecializationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechnicianSpecializationCountAggregateInputType | true
    }

  export interface TechnicianSpecializationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicianSpecialization'], meta: { name: 'TechnicianSpecialization' } }
    /**
     * Find zero or one TechnicianSpecialization that matches the filter.
     * @param {TechnicianSpecializationFindUniqueArgs} args - Arguments to find a TechnicianSpecialization
     * @example
     * // Get one TechnicianSpecialization
     * const technicianSpecialization = await prisma.technicianSpecialization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicianSpecializationFindUniqueArgs>(args: SelectSubset<T, TechnicianSpecializationFindUniqueArgs<ExtArgs>>): Prisma__TechnicianSpecializationClient<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TechnicianSpecialization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechnicianSpecializationFindUniqueOrThrowArgs} args - Arguments to find a TechnicianSpecialization
     * @example
     * // Get one TechnicianSpecialization
     * const technicianSpecialization = await prisma.technicianSpecialization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicianSpecializationFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicianSpecializationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicianSpecializationClient<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicianSpecialization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianSpecializationFindFirstArgs} args - Arguments to find a TechnicianSpecialization
     * @example
     * // Get one TechnicianSpecialization
     * const technicianSpecialization = await prisma.technicianSpecialization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicianSpecializationFindFirstArgs>(args?: SelectSubset<T, TechnicianSpecializationFindFirstArgs<ExtArgs>>): Prisma__TechnicianSpecializationClient<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicianSpecialization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianSpecializationFindFirstOrThrowArgs} args - Arguments to find a TechnicianSpecialization
     * @example
     * // Get one TechnicianSpecialization
     * const technicianSpecialization = await prisma.technicianSpecialization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicianSpecializationFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicianSpecializationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicianSpecializationClient<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TechnicianSpecializations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianSpecializationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicianSpecializations
     * const technicianSpecializations = await prisma.technicianSpecialization.findMany()
     * 
     * // Get first 10 TechnicianSpecializations
     * const technicianSpecializations = await prisma.technicianSpecialization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicianSpecializationWithIdOnly = await prisma.technicianSpecialization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicianSpecializationFindManyArgs>(args?: SelectSubset<T, TechnicianSpecializationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TechnicianSpecialization.
     * @param {TechnicianSpecializationCreateArgs} args - Arguments to create a TechnicianSpecialization.
     * @example
     * // Create one TechnicianSpecialization
     * const TechnicianSpecialization = await prisma.technicianSpecialization.create({
     *   data: {
     *     // ... data to create a TechnicianSpecialization
     *   }
     * })
     * 
     */
    create<T extends TechnicianSpecializationCreateArgs>(args: SelectSubset<T, TechnicianSpecializationCreateArgs<ExtArgs>>): Prisma__TechnicianSpecializationClient<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TechnicianSpecializations.
     * @param {TechnicianSpecializationCreateManyArgs} args - Arguments to create many TechnicianSpecializations.
     * @example
     * // Create many TechnicianSpecializations
     * const technicianSpecialization = await prisma.technicianSpecialization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicianSpecializationCreateManyArgs>(args?: SelectSubset<T, TechnicianSpecializationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechnicianSpecializations and returns the data saved in the database.
     * @param {TechnicianSpecializationCreateManyAndReturnArgs} args - Arguments to create many TechnicianSpecializations.
     * @example
     * // Create many TechnicianSpecializations
     * const technicianSpecialization = await prisma.technicianSpecialization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechnicianSpecializations and only return the `id`
     * const technicianSpecializationWithIdOnly = await prisma.technicianSpecialization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicianSpecializationCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicianSpecializationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TechnicianSpecialization.
     * @param {TechnicianSpecializationDeleteArgs} args - Arguments to delete one TechnicianSpecialization.
     * @example
     * // Delete one TechnicianSpecialization
     * const TechnicianSpecialization = await prisma.technicianSpecialization.delete({
     *   where: {
     *     // ... filter to delete one TechnicianSpecialization
     *   }
     * })
     * 
     */
    delete<T extends TechnicianSpecializationDeleteArgs>(args: SelectSubset<T, TechnicianSpecializationDeleteArgs<ExtArgs>>): Prisma__TechnicianSpecializationClient<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TechnicianSpecialization.
     * @param {TechnicianSpecializationUpdateArgs} args - Arguments to update one TechnicianSpecialization.
     * @example
     * // Update one TechnicianSpecialization
     * const technicianSpecialization = await prisma.technicianSpecialization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicianSpecializationUpdateArgs>(args: SelectSubset<T, TechnicianSpecializationUpdateArgs<ExtArgs>>): Prisma__TechnicianSpecializationClient<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TechnicianSpecializations.
     * @param {TechnicianSpecializationDeleteManyArgs} args - Arguments to filter TechnicianSpecializations to delete.
     * @example
     * // Delete a few TechnicianSpecializations
     * const { count } = await prisma.technicianSpecialization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicianSpecializationDeleteManyArgs>(args?: SelectSubset<T, TechnicianSpecializationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicianSpecializations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianSpecializationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicianSpecializations
     * const technicianSpecialization = await prisma.technicianSpecialization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicianSpecializationUpdateManyArgs>(args: SelectSubset<T, TechnicianSpecializationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicianSpecializations and returns the data updated in the database.
     * @param {TechnicianSpecializationUpdateManyAndReturnArgs} args - Arguments to update many TechnicianSpecializations.
     * @example
     * // Update many TechnicianSpecializations
     * const technicianSpecialization = await prisma.technicianSpecialization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TechnicianSpecializations and only return the `id`
     * const technicianSpecializationWithIdOnly = await prisma.technicianSpecialization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechnicianSpecializationUpdateManyAndReturnArgs>(args: SelectSubset<T, TechnicianSpecializationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TechnicianSpecialization.
     * @param {TechnicianSpecializationUpsertArgs} args - Arguments to update or create a TechnicianSpecialization.
     * @example
     * // Update or create a TechnicianSpecialization
     * const technicianSpecialization = await prisma.technicianSpecialization.upsert({
     *   create: {
     *     // ... data to create a TechnicianSpecialization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicianSpecialization we want to update
     *   }
     * })
     */
    upsert<T extends TechnicianSpecializationUpsertArgs>(args: SelectSubset<T, TechnicianSpecializationUpsertArgs<ExtArgs>>): Prisma__TechnicianSpecializationClient<$Result.GetResult<Prisma.$TechnicianSpecializationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TechnicianSpecializations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianSpecializationCountArgs} args - Arguments to filter TechnicianSpecializations to count.
     * @example
     * // Count the number of TechnicianSpecializations
     * const count = await prisma.technicianSpecialization.count({
     *   where: {
     *     // ... the filter for the TechnicianSpecializations we want to count
     *   }
     * })
    **/
    count<T extends TechnicianSpecializationCountArgs>(
      args?: Subset<T, TechnicianSpecializationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicianSpecializationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicianSpecialization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianSpecializationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicianSpecializationAggregateArgs>(args: Subset<T, TechnicianSpecializationAggregateArgs>): Prisma.PrismaPromise<GetTechnicianSpecializationAggregateType<T>>

    /**
     * Group by TechnicianSpecialization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianSpecializationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicianSpecializationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicianSpecializationGroupByArgs['orderBy'] }
        : { orderBy?: TechnicianSpecializationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicianSpecializationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicianSpecializationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicianSpecialization model
   */
  readonly fields: TechnicianSpecializationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicianSpecialization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicianSpecializationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechnicianSpecialization model
   */
  interface TechnicianSpecializationFieldRefs {
    readonly id: FieldRef<"TechnicianSpecialization", 'String'>
    readonly userId: FieldRef<"TechnicianSpecialization", 'String'>
    readonly specialization: FieldRef<"TechnicianSpecialization", 'Specialization'>
    readonly createdAt: FieldRef<"TechnicianSpecialization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TechnicianSpecialization findUnique
   */
  export type TechnicianSpecializationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSpecialization to fetch.
     */
    where: TechnicianSpecializationWhereUniqueInput
  }

  /**
   * TechnicianSpecialization findUniqueOrThrow
   */
  export type TechnicianSpecializationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSpecialization to fetch.
     */
    where: TechnicianSpecializationWhereUniqueInput
  }

  /**
   * TechnicianSpecialization findFirst
   */
  export type TechnicianSpecializationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSpecialization to fetch.
     */
    where?: TechnicianSpecializationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianSpecializations to fetch.
     */
    orderBy?: TechnicianSpecializationOrderByWithRelationInput | TechnicianSpecializationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicianSpecializations.
     */
    cursor?: TechnicianSpecializationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianSpecializations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianSpecializations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicianSpecializations.
     */
    distinct?: TechnicianSpecializationScalarFieldEnum | TechnicianSpecializationScalarFieldEnum[]
  }

  /**
   * TechnicianSpecialization findFirstOrThrow
   */
  export type TechnicianSpecializationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSpecialization to fetch.
     */
    where?: TechnicianSpecializationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianSpecializations to fetch.
     */
    orderBy?: TechnicianSpecializationOrderByWithRelationInput | TechnicianSpecializationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicianSpecializations.
     */
    cursor?: TechnicianSpecializationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianSpecializations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianSpecializations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicianSpecializations.
     */
    distinct?: TechnicianSpecializationScalarFieldEnum | TechnicianSpecializationScalarFieldEnum[]
  }

  /**
   * TechnicianSpecialization findMany
   */
  export type TechnicianSpecializationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianSpecializations to fetch.
     */
    where?: TechnicianSpecializationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianSpecializations to fetch.
     */
    orderBy?: TechnicianSpecializationOrderByWithRelationInput | TechnicianSpecializationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicianSpecializations.
     */
    cursor?: TechnicianSpecializationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianSpecializations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianSpecializations.
     */
    skip?: number
    distinct?: TechnicianSpecializationScalarFieldEnum | TechnicianSpecializationScalarFieldEnum[]
  }

  /**
   * TechnicianSpecialization create
   */
  export type TechnicianSpecializationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicianSpecialization.
     */
    data: XOR<TechnicianSpecializationCreateInput, TechnicianSpecializationUncheckedCreateInput>
  }

  /**
   * TechnicianSpecialization createMany
   */
  export type TechnicianSpecializationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicianSpecializations.
     */
    data: TechnicianSpecializationCreateManyInput | TechnicianSpecializationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechnicianSpecialization createManyAndReturn
   */
  export type TechnicianSpecializationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * The data used to create many TechnicianSpecializations.
     */
    data: TechnicianSpecializationCreateManyInput | TechnicianSpecializationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicianSpecialization update
   */
  export type TechnicianSpecializationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicianSpecialization.
     */
    data: XOR<TechnicianSpecializationUpdateInput, TechnicianSpecializationUncheckedUpdateInput>
    /**
     * Choose, which TechnicianSpecialization to update.
     */
    where: TechnicianSpecializationWhereUniqueInput
  }

  /**
   * TechnicianSpecialization updateMany
   */
  export type TechnicianSpecializationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicianSpecializations.
     */
    data: XOR<TechnicianSpecializationUpdateManyMutationInput, TechnicianSpecializationUncheckedUpdateManyInput>
    /**
     * Filter which TechnicianSpecializations to update
     */
    where?: TechnicianSpecializationWhereInput
    /**
     * Limit how many TechnicianSpecializations to update.
     */
    limit?: number
  }

  /**
   * TechnicianSpecialization updateManyAndReturn
   */
  export type TechnicianSpecializationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * The data used to update TechnicianSpecializations.
     */
    data: XOR<TechnicianSpecializationUpdateManyMutationInput, TechnicianSpecializationUncheckedUpdateManyInput>
    /**
     * Filter which TechnicianSpecializations to update
     */
    where?: TechnicianSpecializationWhereInput
    /**
     * Limit how many TechnicianSpecializations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicianSpecialization upsert
   */
  export type TechnicianSpecializationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicianSpecialization to update in case it exists.
     */
    where: TechnicianSpecializationWhereUniqueInput
    /**
     * In case the TechnicianSpecialization found by the `where` argument doesn't exist, create a new TechnicianSpecialization with this data.
     */
    create: XOR<TechnicianSpecializationCreateInput, TechnicianSpecializationUncheckedCreateInput>
    /**
     * In case the TechnicianSpecialization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicianSpecializationUpdateInput, TechnicianSpecializationUncheckedUpdateInput>
  }

  /**
   * TechnicianSpecialization delete
   */
  export type TechnicianSpecializationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
    /**
     * Filter which TechnicianSpecialization to delete.
     */
    where: TechnicianSpecializationWhereUniqueInput
  }

  /**
   * TechnicianSpecialization deleteMany
   */
  export type TechnicianSpecializationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicianSpecializations to delete
     */
    where?: TechnicianSpecializationWhereInput
    /**
     * Limit how many TechnicianSpecializations to delete.
     */
    limit?: number
  }

  /**
   * TechnicianSpecialization without action
   */
  export type TechnicianSpecializationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianSpecialization
     */
    select?: TechnicianSpecializationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianSpecialization
     */
    omit?: TechnicianSpecializationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianSpecializationInclude<ExtArgs> | null
  }


  /**
   * Model TechnicianUnavailability
   */

  export type AggregateTechnicianUnavailability = {
    _count: TechnicianUnavailabilityCountAggregateOutputType | null
    _min: TechnicianUnavailabilityMinAggregateOutputType | null
    _max: TechnicianUnavailabilityMaxAggregateOutputType | null
  }

  export type TechnicianUnavailabilityMinAggregateOutputType = {
    id: string | null
    reason: $Enums.TechnicianStatus | null
    notes: string | null
    userId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TechnicianUnavailabilityMaxAggregateOutputType = {
    id: string | null
    reason: $Enums.TechnicianStatus | null
    notes: string | null
    userId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TechnicianUnavailabilityCountAggregateOutputType = {
    id: number
    reason: number
    notes: number
    userId: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TechnicianUnavailabilityMinAggregateInputType = {
    id?: true
    reason?: true
    notes?: true
    userId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TechnicianUnavailabilityMaxAggregateInputType = {
    id?: true
    reason?: true
    notes?: true
    userId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TechnicianUnavailabilityCountAggregateInputType = {
    id?: true
    reason?: true
    notes?: true
    userId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TechnicianUnavailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicianUnavailability to aggregate.
     */
    where?: TechnicianUnavailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianUnavailabilities to fetch.
     */
    orderBy?: TechnicianUnavailabilityOrderByWithRelationInput | TechnicianUnavailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicianUnavailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianUnavailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianUnavailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicianUnavailabilities
    **/
    _count?: true | TechnicianUnavailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicianUnavailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicianUnavailabilityMaxAggregateInputType
  }

  export type GetTechnicianUnavailabilityAggregateType<T extends TechnicianUnavailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicianUnavailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicianUnavailability[P]>
      : GetScalarType<T[P], AggregateTechnicianUnavailability[P]>
  }




  export type TechnicianUnavailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicianUnavailabilityWhereInput
    orderBy?: TechnicianUnavailabilityOrderByWithAggregationInput | TechnicianUnavailabilityOrderByWithAggregationInput[]
    by: TechnicianUnavailabilityScalarFieldEnum[] | TechnicianUnavailabilityScalarFieldEnum
    having?: TechnicianUnavailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicianUnavailabilityCountAggregateInputType | true
    _min?: TechnicianUnavailabilityMinAggregateInputType
    _max?: TechnicianUnavailabilityMaxAggregateInputType
  }

  export type TechnicianUnavailabilityGroupByOutputType = {
    id: string
    reason: $Enums.TechnicianStatus
    notes: string | null
    userId: string
    startDate: Date
    endDate: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TechnicianUnavailabilityCountAggregateOutputType | null
    _min: TechnicianUnavailabilityMinAggregateOutputType | null
    _max: TechnicianUnavailabilityMaxAggregateOutputType | null
  }

  type GetTechnicianUnavailabilityGroupByPayload<T extends TechnicianUnavailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicianUnavailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicianUnavailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicianUnavailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicianUnavailabilityGroupByOutputType[P]>
        }
      >
    >


  export type TechnicianUnavailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    notes?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicianUnavailability"]>

  export type TechnicianUnavailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    notes?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicianUnavailability"]>

  export type TechnicianUnavailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    notes?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicianUnavailability"]>

  export type TechnicianUnavailabilitySelectScalar = {
    id?: boolean
    reason?: boolean
    notes?: boolean
    userId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TechnicianUnavailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reason" | "notes" | "userId" | "startDate" | "endDate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["technicianUnavailability"]>
  export type TechnicianUnavailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TechnicianUnavailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TechnicianUnavailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TechnicianUnavailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicianUnavailability"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reason: $Enums.TechnicianStatus
      notes: string | null
      userId: string
      startDate: Date
      endDate: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["technicianUnavailability"]>
    composites: {}
  }

  type TechnicianUnavailabilityGetPayload<S extends boolean | null | undefined | TechnicianUnavailabilityDefaultArgs> = $Result.GetResult<Prisma.$TechnicianUnavailabilityPayload, S>

  type TechnicianUnavailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechnicianUnavailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechnicianUnavailabilityCountAggregateInputType | true
    }

  export interface TechnicianUnavailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicianUnavailability'], meta: { name: 'TechnicianUnavailability' } }
    /**
     * Find zero or one TechnicianUnavailability that matches the filter.
     * @param {TechnicianUnavailabilityFindUniqueArgs} args - Arguments to find a TechnicianUnavailability
     * @example
     * // Get one TechnicianUnavailability
     * const technicianUnavailability = await prisma.technicianUnavailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicianUnavailabilityFindUniqueArgs>(args: SelectSubset<T, TechnicianUnavailabilityFindUniqueArgs<ExtArgs>>): Prisma__TechnicianUnavailabilityClient<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TechnicianUnavailability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechnicianUnavailabilityFindUniqueOrThrowArgs} args - Arguments to find a TechnicianUnavailability
     * @example
     * // Get one TechnicianUnavailability
     * const technicianUnavailability = await prisma.technicianUnavailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicianUnavailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicianUnavailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicianUnavailabilityClient<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicianUnavailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUnavailabilityFindFirstArgs} args - Arguments to find a TechnicianUnavailability
     * @example
     * // Get one TechnicianUnavailability
     * const technicianUnavailability = await prisma.technicianUnavailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicianUnavailabilityFindFirstArgs>(args?: SelectSubset<T, TechnicianUnavailabilityFindFirstArgs<ExtArgs>>): Prisma__TechnicianUnavailabilityClient<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicianUnavailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUnavailabilityFindFirstOrThrowArgs} args - Arguments to find a TechnicianUnavailability
     * @example
     * // Get one TechnicianUnavailability
     * const technicianUnavailability = await prisma.technicianUnavailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicianUnavailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicianUnavailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicianUnavailabilityClient<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TechnicianUnavailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUnavailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicianUnavailabilities
     * const technicianUnavailabilities = await prisma.technicianUnavailability.findMany()
     * 
     * // Get first 10 TechnicianUnavailabilities
     * const technicianUnavailabilities = await prisma.technicianUnavailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicianUnavailabilityWithIdOnly = await prisma.technicianUnavailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicianUnavailabilityFindManyArgs>(args?: SelectSubset<T, TechnicianUnavailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TechnicianUnavailability.
     * @param {TechnicianUnavailabilityCreateArgs} args - Arguments to create a TechnicianUnavailability.
     * @example
     * // Create one TechnicianUnavailability
     * const TechnicianUnavailability = await prisma.technicianUnavailability.create({
     *   data: {
     *     // ... data to create a TechnicianUnavailability
     *   }
     * })
     * 
     */
    create<T extends TechnicianUnavailabilityCreateArgs>(args: SelectSubset<T, TechnicianUnavailabilityCreateArgs<ExtArgs>>): Prisma__TechnicianUnavailabilityClient<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TechnicianUnavailabilities.
     * @param {TechnicianUnavailabilityCreateManyArgs} args - Arguments to create many TechnicianUnavailabilities.
     * @example
     * // Create many TechnicianUnavailabilities
     * const technicianUnavailability = await prisma.technicianUnavailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicianUnavailabilityCreateManyArgs>(args?: SelectSubset<T, TechnicianUnavailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechnicianUnavailabilities and returns the data saved in the database.
     * @param {TechnicianUnavailabilityCreateManyAndReturnArgs} args - Arguments to create many TechnicianUnavailabilities.
     * @example
     * // Create many TechnicianUnavailabilities
     * const technicianUnavailability = await prisma.technicianUnavailability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechnicianUnavailabilities and only return the `id`
     * const technicianUnavailabilityWithIdOnly = await prisma.technicianUnavailability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicianUnavailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicianUnavailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TechnicianUnavailability.
     * @param {TechnicianUnavailabilityDeleteArgs} args - Arguments to delete one TechnicianUnavailability.
     * @example
     * // Delete one TechnicianUnavailability
     * const TechnicianUnavailability = await prisma.technicianUnavailability.delete({
     *   where: {
     *     // ... filter to delete one TechnicianUnavailability
     *   }
     * })
     * 
     */
    delete<T extends TechnicianUnavailabilityDeleteArgs>(args: SelectSubset<T, TechnicianUnavailabilityDeleteArgs<ExtArgs>>): Prisma__TechnicianUnavailabilityClient<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TechnicianUnavailability.
     * @param {TechnicianUnavailabilityUpdateArgs} args - Arguments to update one TechnicianUnavailability.
     * @example
     * // Update one TechnicianUnavailability
     * const technicianUnavailability = await prisma.technicianUnavailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicianUnavailabilityUpdateArgs>(args: SelectSubset<T, TechnicianUnavailabilityUpdateArgs<ExtArgs>>): Prisma__TechnicianUnavailabilityClient<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TechnicianUnavailabilities.
     * @param {TechnicianUnavailabilityDeleteManyArgs} args - Arguments to filter TechnicianUnavailabilities to delete.
     * @example
     * // Delete a few TechnicianUnavailabilities
     * const { count } = await prisma.technicianUnavailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicianUnavailabilityDeleteManyArgs>(args?: SelectSubset<T, TechnicianUnavailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicianUnavailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUnavailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicianUnavailabilities
     * const technicianUnavailability = await prisma.technicianUnavailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicianUnavailabilityUpdateManyArgs>(args: SelectSubset<T, TechnicianUnavailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicianUnavailabilities and returns the data updated in the database.
     * @param {TechnicianUnavailabilityUpdateManyAndReturnArgs} args - Arguments to update many TechnicianUnavailabilities.
     * @example
     * // Update many TechnicianUnavailabilities
     * const technicianUnavailability = await prisma.technicianUnavailability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TechnicianUnavailabilities and only return the `id`
     * const technicianUnavailabilityWithIdOnly = await prisma.technicianUnavailability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechnicianUnavailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, TechnicianUnavailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TechnicianUnavailability.
     * @param {TechnicianUnavailabilityUpsertArgs} args - Arguments to update or create a TechnicianUnavailability.
     * @example
     * // Update or create a TechnicianUnavailability
     * const technicianUnavailability = await prisma.technicianUnavailability.upsert({
     *   create: {
     *     // ... data to create a TechnicianUnavailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicianUnavailability we want to update
     *   }
     * })
     */
    upsert<T extends TechnicianUnavailabilityUpsertArgs>(args: SelectSubset<T, TechnicianUnavailabilityUpsertArgs<ExtArgs>>): Prisma__TechnicianUnavailabilityClient<$Result.GetResult<Prisma.$TechnicianUnavailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TechnicianUnavailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUnavailabilityCountArgs} args - Arguments to filter TechnicianUnavailabilities to count.
     * @example
     * // Count the number of TechnicianUnavailabilities
     * const count = await prisma.technicianUnavailability.count({
     *   where: {
     *     // ... the filter for the TechnicianUnavailabilities we want to count
     *   }
     * })
    **/
    count<T extends TechnicianUnavailabilityCountArgs>(
      args?: Subset<T, TechnicianUnavailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicianUnavailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicianUnavailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUnavailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicianUnavailabilityAggregateArgs>(args: Subset<T, TechnicianUnavailabilityAggregateArgs>): Prisma.PrismaPromise<GetTechnicianUnavailabilityAggregateType<T>>

    /**
     * Group by TechnicianUnavailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicianUnavailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicianUnavailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicianUnavailabilityGroupByArgs['orderBy'] }
        : { orderBy?: TechnicianUnavailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicianUnavailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicianUnavailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicianUnavailability model
   */
  readonly fields: TechnicianUnavailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicianUnavailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicianUnavailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechnicianUnavailability model
   */
  interface TechnicianUnavailabilityFieldRefs {
    readonly id: FieldRef<"TechnicianUnavailability", 'String'>
    readonly reason: FieldRef<"TechnicianUnavailability", 'TechnicianStatus'>
    readonly notes: FieldRef<"TechnicianUnavailability", 'String'>
    readonly userId: FieldRef<"TechnicianUnavailability", 'String'>
    readonly startDate: FieldRef<"TechnicianUnavailability", 'DateTime'>
    readonly endDate: FieldRef<"TechnicianUnavailability", 'DateTime'>
    readonly isActive: FieldRef<"TechnicianUnavailability", 'Boolean'>
    readonly createdAt: FieldRef<"TechnicianUnavailability", 'DateTime'>
    readonly updatedAt: FieldRef<"TechnicianUnavailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TechnicianUnavailability findUnique
   */
  export type TechnicianUnavailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianUnavailability to fetch.
     */
    where: TechnicianUnavailabilityWhereUniqueInput
  }

  /**
   * TechnicianUnavailability findUniqueOrThrow
   */
  export type TechnicianUnavailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianUnavailability to fetch.
     */
    where: TechnicianUnavailabilityWhereUniqueInput
  }

  /**
   * TechnicianUnavailability findFirst
   */
  export type TechnicianUnavailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianUnavailability to fetch.
     */
    where?: TechnicianUnavailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianUnavailabilities to fetch.
     */
    orderBy?: TechnicianUnavailabilityOrderByWithRelationInput | TechnicianUnavailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicianUnavailabilities.
     */
    cursor?: TechnicianUnavailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianUnavailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianUnavailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicianUnavailabilities.
     */
    distinct?: TechnicianUnavailabilityScalarFieldEnum | TechnicianUnavailabilityScalarFieldEnum[]
  }

  /**
   * TechnicianUnavailability findFirstOrThrow
   */
  export type TechnicianUnavailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianUnavailability to fetch.
     */
    where?: TechnicianUnavailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianUnavailabilities to fetch.
     */
    orderBy?: TechnicianUnavailabilityOrderByWithRelationInput | TechnicianUnavailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicianUnavailabilities.
     */
    cursor?: TechnicianUnavailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianUnavailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianUnavailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicianUnavailabilities.
     */
    distinct?: TechnicianUnavailabilityScalarFieldEnum | TechnicianUnavailabilityScalarFieldEnum[]
  }

  /**
   * TechnicianUnavailability findMany
   */
  export type TechnicianUnavailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * Filter, which TechnicianUnavailabilities to fetch.
     */
    where?: TechnicianUnavailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicianUnavailabilities to fetch.
     */
    orderBy?: TechnicianUnavailabilityOrderByWithRelationInput | TechnicianUnavailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicianUnavailabilities.
     */
    cursor?: TechnicianUnavailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicianUnavailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicianUnavailabilities.
     */
    skip?: number
    distinct?: TechnicianUnavailabilityScalarFieldEnum | TechnicianUnavailabilityScalarFieldEnum[]
  }

  /**
   * TechnicianUnavailability create
   */
  export type TechnicianUnavailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicianUnavailability.
     */
    data: XOR<TechnicianUnavailabilityCreateInput, TechnicianUnavailabilityUncheckedCreateInput>
  }

  /**
   * TechnicianUnavailability createMany
   */
  export type TechnicianUnavailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicianUnavailabilities.
     */
    data: TechnicianUnavailabilityCreateManyInput | TechnicianUnavailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechnicianUnavailability createManyAndReturn
   */
  export type TechnicianUnavailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many TechnicianUnavailabilities.
     */
    data: TechnicianUnavailabilityCreateManyInput | TechnicianUnavailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicianUnavailability update
   */
  export type TechnicianUnavailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicianUnavailability.
     */
    data: XOR<TechnicianUnavailabilityUpdateInput, TechnicianUnavailabilityUncheckedUpdateInput>
    /**
     * Choose, which TechnicianUnavailability to update.
     */
    where: TechnicianUnavailabilityWhereUniqueInput
  }

  /**
   * TechnicianUnavailability updateMany
   */
  export type TechnicianUnavailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicianUnavailabilities.
     */
    data: XOR<TechnicianUnavailabilityUpdateManyMutationInput, TechnicianUnavailabilityUncheckedUpdateManyInput>
    /**
     * Filter which TechnicianUnavailabilities to update
     */
    where?: TechnicianUnavailabilityWhereInput
    /**
     * Limit how many TechnicianUnavailabilities to update.
     */
    limit?: number
  }

  /**
   * TechnicianUnavailability updateManyAndReturn
   */
  export type TechnicianUnavailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * The data used to update TechnicianUnavailabilities.
     */
    data: XOR<TechnicianUnavailabilityUpdateManyMutationInput, TechnicianUnavailabilityUncheckedUpdateManyInput>
    /**
     * Filter which TechnicianUnavailabilities to update
     */
    where?: TechnicianUnavailabilityWhereInput
    /**
     * Limit how many TechnicianUnavailabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicianUnavailability upsert
   */
  export type TechnicianUnavailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicianUnavailability to update in case it exists.
     */
    where: TechnicianUnavailabilityWhereUniqueInput
    /**
     * In case the TechnicianUnavailability found by the `where` argument doesn't exist, create a new TechnicianUnavailability with this data.
     */
    create: XOR<TechnicianUnavailabilityCreateInput, TechnicianUnavailabilityUncheckedCreateInput>
    /**
     * In case the TechnicianUnavailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicianUnavailabilityUpdateInput, TechnicianUnavailabilityUncheckedUpdateInput>
  }

  /**
   * TechnicianUnavailability delete
   */
  export type TechnicianUnavailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
    /**
     * Filter which TechnicianUnavailability to delete.
     */
    where: TechnicianUnavailabilityWhereUniqueInput
  }

  /**
   * TechnicianUnavailability deleteMany
   */
  export type TechnicianUnavailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicianUnavailabilities to delete
     */
    where?: TechnicianUnavailabilityWhereInput
    /**
     * Limit how many TechnicianUnavailabilities to delete.
     */
    limit?: number
  }

  /**
   * TechnicianUnavailability without action
   */
  export type TechnicianUnavailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicianUnavailability
     */
    select?: TechnicianUnavailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicianUnavailability
     */
    omit?: TechnicianUnavailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicianUnavailabilityInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    link: string | null
    isRead: boolean | null
    tenantId: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    link: string | null
    isRead: boolean | null
    tenantId: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    link: number
    isRead: number
    tenantId: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    isRead?: true
    tenantId?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    isRead?: true
    tenantId?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    isRead?: true
    tenantId?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    link: string | null
    isRead: boolean
    tenantId: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    tenantId?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    tenantId?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    tenantId?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    isRead?: boolean
    tenantId?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "link" | "isRead" | "tenantId" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      link: string | null
      isRead: boolean
      tenantId: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly tenantId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    laborCost: Decimal | null
    partsCost: Decimal | null
    partsMarkup: Decimal | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    laborCost: Decimal | null
    partsCost: Decimal | null
    partsMarkup: Decimal | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    status: $Enums.InvoiceStatus | null
    ticketId: string | null
    customerId: string | null
    laborCost: Decimal | null
    partsCost: Decimal | null
    partsMarkup: Decimal | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    customerName: string | null
    customerNIT: string | null
    customerDPI: string | null
    customerAddress: string | null
    notes: string | null
    paymentTerms: string | null
    issuedAt: Date | null
    dueAt: Date | null
    paidAt: Date | null
    tenantId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    status: $Enums.InvoiceStatus | null
    ticketId: string | null
    customerId: string | null
    laborCost: Decimal | null
    partsCost: Decimal | null
    partsMarkup: Decimal | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    customerName: string | null
    customerNIT: string | null
    customerDPI: string | null
    customerAddress: string | null
    notes: string | null
    paymentTerms: string | null
    issuedAt: Date | null
    dueAt: Date | null
    paidAt: Date | null
    tenantId: string | null
    createdById: string | null
    updatedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    status: number
    ticketId: number
    customerId: number
    laborCost: number
    partsCost: number
    partsMarkup: number
    subtotal: number
    taxRate: number
    taxAmount: number
    discountAmount: number
    total: number
    customerName: number
    customerNIT: number
    customerDPI: number
    customerAddress: number
    notes: number
    paymentTerms: number
    issuedAt: number
    dueAt: number
    paidAt: number
    tenantId: number
    createdById: number
    updatedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    laborCost?: true
    partsCost?: true
    partsMarkup?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    laborCost?: true
    partsCost?: true
    partsMarkup?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    ticketId?: true
    customerId?: true
    laborCost?: true
    partsCost?: true
    partsMarkup?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    customerName?: true
    customerNIT?: true
    customerDPI?: true
    customerAddress?: true
    notes?: true
    paymentTerms?: true
    issuedAt?: true
    dueAt?: true
    paidAt?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    ticketId?: true
    customerId?: true
    laborCost?: true
    partsCost?: true
    partsMarkup?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    customerName?: true
    customerNIT?: true
    customerDPI?: true
    customerAddress?: true
    notes?: true
    paymentTerms?: true
    issuedAt?: true
    dueAt?: true
    paidAt?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    status?: true
    ticketId?: true
    customerId?: true
    laborCost?: true
    partsCost?: true
    partsMarkup?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    customerName?: true
    customerNIT?: true
    customerDPI?: true
    customerAddress?: true
    notes?: true
    paymentTerms?: true
    issuedAt?: true
    dueAt?: true
    paidAt?: true
    tenantId?: true
    createdById?: true
    updatedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    status: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost: Decimal
    partsCost: Decimal
    partsMarkup: Decimal
    subtotal: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    discountAmount: Decimal
    total: Decimal
    customerName: string
    customerNIT: string | null
    customerDPI: string | null
    customerAddress: string | null
    notes: string | null
    paymentTerms: string | null
    issuedAt: Date
    dueAt: Date | null
    paidAt: Date | null
    tenantId: string
    createdById: string
    updatedById: string
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    ticketId?: boolean
    customerId?: boolean
    laborCost?: boolean
    partsCost?: boolean
    partsMarkup?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    customerName?: boolean
    customerNIT?: boolean
    customerDPI?: boolean
    customerAddress?: boolean
    notes?: boolean
    paymentTerms?: boolean
    issuedAt?: boolean
    dueAt?: boolean
    paidAt?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    history?: boolean | Invoice$historyArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    ticketId?: boolean
    customerId?: boolean
    laborCost?: boolean
    partsCost?: boolean
    partsMarkup?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    customerName?: boolean
    customerNIT?: boolean
    customerDPI?: boolean
    customerAddress?: boolean
    notes?: boolean
    paymentTerms?: boolean
    issuedAt?: boolean
    dueAt?: boolean
    paidAt?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    ticketId?: boolean
    customerId?: boolean
    laborCost?: boolean
    partsCost?: boolean
    partsMarkup?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    customerName?: boolean
    customerNIT?: boolean
    customerDPI?: boolean
    customerAddress?: boolean
    notes?: boolean
    paymentTerms?: boolean
    issuedAt?: boolean
    dueAt?: boolean
    paidAt?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    status?: boolean
    ticketId?: boolean
    customerId?: boolean
    laborCost?: boolean
    partsCost?: boolean
    partsMarkup?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    customerName?: boolean
    customerNIT?: boolean
    customerDPI?: boolean
    customerAddress?: boolean
    notes?: boolean
    paymentTerms?: boolean
    issuedAt?: boolean
    dueAt?: boolean
    paidAt?: boolean
    tenantId?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "status" | "ticketId" | "customerId" | "laborCost" | "partsCost" | "partsMarkup" | "subtotal" | "taxRate" | "taxAmount" | "discountAmount" | "total" | "customerName" | "customerNIT" | "customerDPI" | "customerAddress" | "notes" | "paymentTerms" | "issuedAt" | "dueAt" | "paidAt" | "tenantId" | "createdById" | "updatedById" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    history?: boolean | Invoice$historyArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    updatedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      history: Prisma.$InvoiceHistoryPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      ticket: Prisma.$TicketPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      status: $Enums.InvoiceStatus
      ticketId: string
      customerId: string
      laborCost: Prisma.Decimal
      partsCost: Prisma.Decimal
      partsMarkup: Prisma.Decimal
      subtotal: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      total: Prisma.Decimal
      customerName: string
      customerNIT: string | null
      customerDPI: string | null
      customerAddress: string | null
      notes: string | null
      paymentTerms: string | null
      issuedAt: Date
      dueAt: Date | null
      paidAt: Date | null
      tenantId: string
      createdById: string
      updatedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    history<T extends Invoice$historyArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly ticketId: FieldRef<"Invoice", 'String'>
    readonly customerId: FieldRef<"Invoice", 'String'>
    readonly laborCost: FieldRef<"Invoice", 'Decimal'>
    readonly partsCost: FieldRef<"Invoice", 'Decimal'>
    readonly partsMarkup: FieldRef<"Invoice", 'Decimal'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly taxRate: FieldRef<"Invoice", 'Decimal'>
    readonly taxAmount: FieldRef<"Invoice", 'Decimal'>
    readonly discountAmount: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly customerName: FieldRef<"Invoice", 'String'>
    readonly customerNIT: FieldRef<"Invoice", 'String'>
    readonly customerDPI: FieldRef<"Invoice", 'String'>
    readonly customerAddress: FieldRef<"Invoice", 'String'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly paymentTerms: FieldRef<"Invoice", 'String'>
    readonly issuedAt: FieldRef<"Invoice", 'DateTime'>
    readonly dueAt: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly createdById: FieldRef<"Invoice", 'String'>
    readonly updatedById: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.history
   */
  export type Invoice$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    where?: InvoiceHistoryWhereInput
    orderBy?: InvoiceHistoryOrderByWithRelationInput | InvoiceHistoryOrderByWithRelationInput[]
    cursor?: InvoiceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceHistoryScalarFieldEnum | InvoiceHistoryScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    paymentNumber: string | null
    invoiceId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    transactionRef: string | null
    notes: string | null
    paidAt: Date | null
    tenantId: string | null
    receivedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    paymentNumber: string | null
    invoiceId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.PaymentMethod | null
    transactionRef: string | null
    notes: string | null
    paidAt: Date | null
    tenantId: string | null
    receivedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    paymentNumber: number
    invoiceId: number
    amount: number
    paymentMethod: number
    transactionRef: number
    notes: number
    paidAt: number
    tenantId: number
    receivedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    paymentNumber?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    transactionRef?: true
    notes?: true
    paidAt?: true
    tenantId?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    paymentNumber?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    transactionRef?: true
    notes?: true
    paidAt?: true
    tenantId?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    paymentNumber?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    transactionRef?: true
    notes?: true
    paidAt?: true
    tenantId?: true
    receivedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    paymentNumber: string
    invoiceId: string
    amount: Decimal
    paymentMethod: $Enums.PaymentMethod
    transactionRef: string | null
    notes: string | null
    paidAt: Date
    tenantId: string
    receivedById: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNumber?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionRef?: boolean
    notes?: boolean
    paidAt?: boolean
    tenantId?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNumber?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionRef?: boolean
    notes?: boolean
    paidAt?: boolean
    tenantId?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNumber?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionRef?: boolean
    notes?: boolean
    paidAt?: boolean
    tenantId?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    paymentNumber?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionRef?: boolean
    notes?: boolean
    paidAt?: boolean
    tenantId?: boolean
    receivedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentNumber" | "invoiceId" | "amount" | "paymentMethod" | "transactionRef" | "notes" | "paidAt" | "tenantId" | "receivedById" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      receivedBy: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentNumber: string
      invoiceId: string
      amount: Prisma.Decimal
      paymentMethod: $Enums.PaymentMethod
      transactionRef: string | null
      notes: string | null
      paidAt: Date
      tenantId: string
      receivedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receivedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly paymentNumber: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly transactionRef: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly tenantId: FieldRef<"Payment", 'String'>
    readonly receivedById: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model CashRegister
   */

  export type AggregateCashRegister = {
    _count: CashRegisterCountAggregateOutputType | null
    _avg: CashRegisterAvgAggregateOutputType | null
    _sum: CashRegisterSumAggregateOutputType | null
    _min: CashRegisterMinAggregateOutputType | null
    _max: CashRegisterMaxAggregateOutputType | null
  }

  export type CashRegisterAvgAggregateOutputType = {
    openingBalance: Decimal | null
    closingBalance: Decimal | null
    expectedBalance: Decimal | null
    difference: Decimal | null
  }

  export type CashRegisterSumAggregateOutputType = {
    openingBalance: Decimal | null
    closingBalance: Decimal | null
    expectedBalance: Decimal | null
    difference: Decimal | null
  }

  export type CashRegisterMinAggregateOutputType = {
    id: string | null
    name: string | null
    isOpen: boolean | null
    openedAt: Date | null
    closedAt: Date | null
    openingBalance: Decimal | null
    closingBalance: Decimal | null
    expectedBalance: Decimal | null
    difference: Decimal | null
    closingNotes: string | null
    tenantId: string | null
    openedById: string | null
    closedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashRegisterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isOpen: boolean | null
    openedAt: Date | null
    closedAt: Date | null
    openingBalance: Decimal | null
    closingBalance: Decimal | null
    expectedBalance: Decimal | null
    difference: Decimal | null
    closingNotes: string | null
    tenantId: string | null
    openedById: string | null
    closedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CashRegisterCountAggregateOutputType = {
    id: number
    name: number
    isOpen: number
    openedAt: number
    closedAt: number
    openingBalance: number
    closingBalance: number
    expectedBalance: number
    difference: number
    closingNotes: number
    tenantId: number
    openedById: number
    closedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CashRegisterAvgAggregateInputType = {
    openingBalance?: true
    closingBalance?: true
    expectedBalance?: true
    difference?: true
  }

  export type CashRegisterSumAggregateInputType = {
    openingBalance?: true
    closingBalance?: true
    expectedBalance?: true
    difference?: true
  }

  export type CashRegisterMinAggregateInputType = {
    id?: true
    name?: true
    isOpen?: true
    openedAt?: true
    closedAt?: true
    openingBalance?: true
    closingBalance?: true
    expectedBalance?: true
    difference?: true
    closingNotes?: true
    tenantId?: true
    openedById?: true
    closedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashRegisterMaxAggregateInputType = {
    id?: true
    name?: true
    isOpen?: true
    openedAt?: true
    closedAt?: true
    openingBalance?: true
    closingBalance?: true
    expectedBalance?: true
    difference?: true
    closingNotes?: true
    tenantId?: true
    openedById?: true
    closedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CashRegisterCountAggregateInputType = {
    id?: true
    name?: true
    isOpen?: true
    openedAt?: true
    closedAt?: true
    openingBalance?: true
    closingBalance?: true
    expectedBalance?: true
    difference?: true
    closingNotes?: true
    tenantId?: true
    openedById?: true
    closedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CashRegisterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashRegister to aggregate.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashRegisters
    **/
    _count?: true | CashRegisterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashRegisterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashRegisterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashRegisterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashRegisterMaxAggregateInputType
  }

  export type GetCashRegisterAggregateType<T extends CashRegisterAggregateArgs> = {
        [P in keyof T & keyof AggregateCashRegister]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashRegister[P]>
      : GetScalarType<T[P], AggregateCashRegister[P]>
  }




  export type CashRegisterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashRegisterWhereInput
    orderBy?: CashRegisterOrderByWithAggregationInput | CashRegisterOrderByWithAggregationInput[]
    by: CashRegisterScalarFieldEnum[] | CashRegisterScalarFieldEnum
    having?: CashRegisterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashRegisterCountAggregateInputType | true
    _avg?: CashRegisterAvgAggregateInputType
    _sum?: CashRegisterSumAggregateInputType
    _min?: CashRegisterMinAggregateInputType
    _max?: CashRegisterMaxAggregateInputType
  }

  export type CashRegisterGroupByOutputType = {
    id: string
    name: string
    isOpen: boolean
    openedAt: Date | null
    closedAt: Date | null
    openingBalance: Decimal
    closingBalance: Decimal
    expectedBalance: Decimal
    difference: Decimal
    closingNotes: string | null
    tenantId: string
    openedById: string | null
    closedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: CashRegisterCountAggregateOutputType | null
    _avg: CashRegisterAvgAggregateOutputType | null
    _sum: CashRegisterSumAggregateOutputType | null
    _min: CashRegisterMinAggregateOutputType | null
    _max: CashRegisterMaxAggregateOutputType | null
  }

  type GetCashRegisterGroupByPayload<T extends CashRegisterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashRegisterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashRegisterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashRegisterGroupByOutputType[P]>
            : GetScalarType<T[P], CashRegisterGroupByOutputType[P]>
        }
      >
    >


  export type CashRegisterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isOpen?: boolean
    openedAt?: boolean
    closedAt?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    expectedBalance?: boolean
    difference?: boolean
    closingNotes?: boolean
    tenantId?: boolean
    openedById?: boolean
    closedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedBy?: boolean | CashRegister$closedByArgs<ExtArgs>
    openedBy?: boolean | CashRegister$openedByArgs<ExtArgs>
    posSales?: boolean | CashRegister$posSalesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | CashRegister$transactionsArgs<ExtArgs>
    _count?: boolean | CashRegisterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashRegister"]>

  export type CashRegisterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isOpen?: boolean
    openedAt?: boolean
    closedAt?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    expectedBalance?: boolean
    difference?: boolean
    closingNotes?: boolean
    tenantId?: boolean
    openedById?: boolean
    closedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedBy?: boolean | CashRegister$closedByArgs<ExtArgs>
    openedBy?: boolean | CashRegister$openedByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashRegister"]>

  export type CashRegisterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isOpen?: boolean
    openedAt?: boolean
    closedAt?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    expectedBalance?: boolean
    difference?: boolean
    closingNotes?: boolean
    tenantId?: boolean
    openedById?: boolean
    closedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedBy?: boolean | CashRegister$closedByArgs<ExtArgs>
    openedBy?: boolean | CashRegister$openedByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashRegister"]>

  export type CashRegisterSelectScalar = {
    id?: boolean
    name?: boolean
    isOpen?: boolean
    openedAt?: boolean
    closedAt?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    expectedBalance?: boolean
    difference?: boolean
    closingNotes?: boolean
    tenantId?: boolean
    openedById?: boolean
    closedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CashRegisterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isOpen" | "openedAt" | "closedAt" | "openingBalance" | "closingBalance" | "expectedBalance" | "difference" | "closingNotes" | "tenantId" | "openedById" | "closedById" | "createdAt" | "updatedAt", ExtArgs["result"]["cashRegister"]>
  export type CashRegisterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closedBy?: boolean | CashRegister$closedByArgs<ExtArgs>
    openedBy?: boolean | CashRegister$openedByArgs<ExtArgs>
    posSales?: boolean | CashRegister$posSalesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | CashRegister$transactionsArgs<ExtArgs>
    _count?: boolean | CashRegisterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CashRegisterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closedBy?: boolean | CashRegister$closedByArgs<ExtArgs>
    openedBy?: boolean | CashRegister$openedByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CashRegisterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    closedBy?: boolean | CashRegister$closedByArgs<ExtArgs>
    openedBy?: boolean | CashRegister$openedByArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CashRegisterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashRegister"
    objects: {
      closedBy: Prisma.$UserPayload<ExtArgs> | null
      openedBy: Prisma.$UserPayload<ExtArgs> | null
      posSales: Prisma.$POSSalePayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      transactions: Prisma.$CashTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isOpen: boolean
      openedAt: Date | null
      closedAt: Date | null
      openingBalance: Prisma.Decimal
      closingBalance: Prisma.Decimal
      expectedBalance: Prisma.Decimal
      difference: Prisma.Decimal
      closingNotes: string | null
      tenantId: string
      openedById: string | null
      closedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cashRegister"]>
    composites: {}
  }

  type CashRegisterGetPayload<S extends boolean | null | undefined | CashRegisterDefaultArgs> = $Result.GetResult<Prisma.$CashRegisterPayload, S>

  type CashRegisterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashRegisterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashRegisterCountAggregateInputType | true
    }

  export interface CashRegisterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashRegister'], meta: { name: 'CashRegister' } }
    /**
     * Find zero or one CashRegister that matches the filter.
     * @param {CashRegisterFindUniqueArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashRegisterFindUniqueArgs>(args: SelectSubset<T, CashRegisterFindUniqueArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashRegister that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashRegisterFindUniqueOrThrowArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashRegisterFindUniqueOrThrowArgs>(args: SelectSubset<T, CashRegisterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashRegister that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindFirstArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashRegisterFindFirstArgs>(args?: SelectSubset<T, CashRegisterFindFirstArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashRegister that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindFirstOrThrowArgs} args - Arguments to find a CashRegister
     * @example
     * // Get one CashRegister
     * const cashRegister = await prisma.cashRegister.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashRegisterFindFirstOrThrowArgs>(args?: SelectSubset<T, CashRegisterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashRegisters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashRegisters
     * const cashRegisters = await prisma.cashRegister.findMany()
     * 
     * // Get first 10 CashRegisters
     * const cashRegisters = await prisma.cashRegister.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashRegisterWithIdOnly = await prisma.cashRegister.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashRegisterFindManyArgs>(args?: SelectSubset<T, CashRegisterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashRegister.
     * @param {CashRegisterCreateArgs} args - Arguments to create a CashRegister.
     * @example
     * // Create one CashRegister
     * const CashRegister = await prisma.cashRegister.create({
     *   data: {
     *     // ... data to create a CashRegister
     *   }
     * })
     * 
     */
    create<T extends CashRegisterCreateArgs>(args: SelectSubset<T, CashRegisterCreateArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashRegisters.
     * @param {CashRegisterCreateManyArgs} args - Arguments to create many CashRegisters.
     * @example
     * // Create many CashRegisters
     * const cashRegister = await prisma.cashRegister.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashRegisterCreateManyArgs>(args?: SelectSubset<T, CashRegisterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashRegisters and returns the data saved in the database.
     * @param {CashRegisterCreateManyAndReturnArgs} args - Arguments to create many CashRegisters.
     * @example
     * // Create many CashRegisters
     * const cashRegister = await prisma.cashRegister.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashRegisters and only return the `id`
     * const cashRegisterWithIdOnly = await prisma.cashRegister.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashRegisterCreateManyAndReturnArgs>(args?: SelectSubset<T, CashRegisterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashRegister.
     * @param {CashRegisterDeleteArgs} args - Arguments to delete one CashRegister.
     * @example
     * // Delete one CashRegister
     * const CashRegister = await prisma.cashRegister.delete({
     *   where: {
     *     // ... filter to delete one CashRegister
     *   }
     * })
     * 
     */
    delete<T extends CashRegisterDeleteArgs>(args: SelectSubset<T, CashRegisterDeleteArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashRegister.
     * @param {CashRegisterUpdateArgs} args - Arguments to update one CashRegister.
     * @example
     * // Update one CashRegister
     * const cashRegister = await prisma.cashRegister.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashRegisterUpdateArgs>(args: SelectSubset<T, CashRegisterUpdateArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashRegisters.
     * @param {CashRegisterDeleteManyArgs} args - Arguments to filter CashRegisters to delete.
     * @example
     * // Delete a few CashRegisters
     * const { count } = await prisma.cashRegister.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashRegisterDeleteManyArgs>(args?: SelectSubset<T, CashRegisterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashRegisters
     * const cashRegister = await prisma.cashRegister.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashRegisterUpdateManyArgs>(args: SelectSubset<T, CashRegisterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashRegisters and returns the data updated in the database.
     * @param {CashRegisterUpdateManyAndReturnArgs} args - Arguments to update many CashRegisters.
     * @example
     * // Update many CashRegisters
     * const cashRegister = await prisma.cashRegister.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashRegisters and only return the `id`
     * const cashRegisterWithIdOnly = await prisma.cashRegister.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashRegisterUpdateManyAndReturnArgs>(args: SelectSubset<T, CashRegisterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashRegister.
     * @param {CashRegisterUpsertArgs} args - Arguments to update or create a CashRegister.
     * @example
     * // Update or create a CashRegister
     * const cashRegister = await prisma.cashRegister.upsert({
     *   create: {
     *     // ... data to create a CashRegister
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashRegister we want to update
     *   }
     * })
     */
    upsert<T extends CashRegisterUpsertArgs>(args: SelectSubset<T, CashRegisterUpsertArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterCountArgs} args - Arguments to filter CashRegisters to count.
     * @example
     * // Count the number of CashRegisters
     * const count = await prisma.cashRegister.count({
     *   where: {
     *     // ... the filter for the CashRegisters we want to count
     *   }
     * })
    **/
    count<T extends CashRegisterCountArgs>(
      args?: Subset<T, CashRegisterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashRegisterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashRegisterAggregateArgs>(args: Subset<T, CashRegisterAggregateArgs>): Prisma.PrismaPromise<GetCashRegisterAggregateType<T>>

    /**
     * Group by CashRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashRegisterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashRegisterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashRegisterGroupByArgs['orderBy'] }
        : { orderBy?: CashRegisterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashRegisterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashRegisterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashRegister model
   */
  readonly fields: CashRegisterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashRegister.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashRegisterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    closedBy<T extends CashRegister$closedByArgs<ExtArgs> = {}>(args?: Subset<T, CashRegister$closedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    openedBy<T extends CashRegister$openedByArgs<ExtArgs> = {}>(args?: Subset<T, CashRegister$openedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    posSales<T extends CashRegister$posSalesArgs<ExtArgs> = {}>(args?: Subset<T, CashRegister$posSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends CashRegister$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CashRegister$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashRegister model
   */
  interface CashRegisterFieldRefs {
    readonly id: FieldRef<"CashRegister", 'String'>
    readonly name: FieldRef<"CashRegister", 'String'>
    readonly isOpen: FieldRef<"CashRegister", 'Boolean'>
    readonly openedAt: FieldRef<"CashRegister", 'DateTime'>
    readonly closedAt: FieldRef<"CashRegister", 'DateTime'>
    readonly openingBalance: FieldRef<"CashRegister", 'Decimal'>
    readonly closingBalance: FieldRef<"CashRegister", 'Decimal'>
    readonly expectedBalance: FieldRef<"CashRegister", 'Decimal'>
    readonly difference: FieldRef<"CashRegister", 'Decimal'>
    readonly closingNotes: FieldRef<"CashRegister", 'String'>
    readonly tenantId: FieldRef<"CashRegister", 'String'>
    readonly openedById: FieldRef<"CashRegister", 'String'>
    readonly closedById: FieldRef<"CashRegister", 'String'>
    readonly createdAt: FieldRef<"CashRegister", 'DateTime'>
    readonly updatedAt: FieldRef<"CashRegister", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashRegister findUnique
   */
  export type CashRegisterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister findUniqueOrThrow
   */
  export type CashRegisterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister findFirst
   */
  export type CashRegisterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashRegisters.
     */
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister findFirstOrThrow
   */
  export type CashRegisterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegister to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashRegisters.
     */
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister findMany
   */
  export type CashRegisterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter, which CashRegisters to fetch.
     */
    where?: CashRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashRegisters to fetch.
     */
    orderBy?: CashRegisterOrderByWithRelationInput | CashRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashRegisters.
     */
    cursor?: CashRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashRegisters.
     */
    skip?: number
    distinct?: CashRegisterScalarFieldEnum | CashRegisterScalarFieldEnum[]
  }

  /**
   * CashRegister create
   */
  export type CashRegisterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The data needed to create a CashRegister.
     */
    data: XOR<CashRegisterCreateInput, CashRegisterUncheckedCreateInput>
  }

  /**
   * CashRegister createMany
   */
  export type CashRegisterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashRegisters.
     */
    data: CashRegisterCreateManyInput | CashRegisterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashRegister createManyAndReturn
   */
  export type CashRegisterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * The data used to create many CashRegisters.
     */
    data: CashRegisterCreateManyInput | CashRegisterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashRegister update
   */
  export type CashRegisterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The data needed to update a CashRegister.
     */
    data: XOR<CashRegisterUpdateInput, CashRegisterUncheckedUpdateInput>
    /**
     * Choose, which CashRegister to update.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister updateMany
   */
  export type CashRegisterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashRegisters.
     */
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyInput>
    /**
     * Filter which CashRegisters to update
     */
    where?: CashRegisterWhereInput
    /**
     * Limit how many CashRegisters to update.
     */
    limit?: number
  }

  /**
   * CashRegister updateManyAndReturn
   */
  export type CashRegisterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * The data used to update CashRegisters.
     */
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyInput>
    /**
     * Filter which CashRegisters to update
     */
    where?: CashRegisterWhereInput
    /**
     * Limit how many CashRegisters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashRegister upsert
   */
  export type CashRegisterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * The filter to search for the CashRegister to update in case it exists.
     */
    where: CashRegisterWhereUniqueInput
    /**
     * In case the CashRegister found by the `where` argument doesn't exist, create a new CashRegister with this data.
     */
    create: XOR<CashRegisterCreateInput, CashRegisterUncheckedCreateInput>
    /**
     * In case the CashRegister was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashRegisterUpdateInput, CashRegisterUncheckedUpdateInput>
  }

  /**
   * CashRegister delete
   */
  export type CashRegisterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    /**
     * Filter which CashRegister to delete.
     */
    where: CashRegisterWhereUniqueInput
  }

  /**
   * CashRegister deleteMany
   */
  export type CashRegisterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashRegisters to delete
     */
    where?: CashRegisterWhereInput
    /**
     * Limit how many CashRegisters to delete.
     */
    limit?: number
  }

  /**
   * CashRegister.closedBy
   */
  export type CashRegister$closedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CashRegister.openedBy
   */
  export type CashRegister$openedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CashRegister.posSales
   */
  export type CashRegister$posSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    where?: POSSaleWhereInput
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    cursor?: POSSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * CashRegister.transactions
   */
  export type CashRegister$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashRegister without action
   */
  export type CashRegisterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
  }


  /**
   * Model CashTransaction
   */

  export type AggregateCashTransaction = {
    _count: CashTransactionCountAggregateOutputType | null
    _avg: CashTransactionAvgAggregateOutputType | null
    _sum: CashTransactionSumAggregateOutputType | null
    _min: CashTransactionMinAggregateOutputType | null
    _max: CashTransactionMaxAggregateOutputType | null
  }

  export type CashTransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CashTransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CashTransactionMinAggregateOutputType = {
    id: string | null
    type: string | null
    amount: Decimal | null
    description: string | null
    reference: string | null
    cashRegisterId: string | null
    tenantId: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type CashTransactionMaxAggregateOutputType = {
    id: string | null
    type: string | null
    amount: Decimal | null
    description: string | null
    reference: string | null
    cashRegisterId: string | null
    tenantId: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type CashTransactionCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    description: number
    reference: number
    cashRegisterId: number
    tenantId: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type CashTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type CashTransactionSumAggregateInputType = {
    amount?: true
  }

  export type CashTransactionMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    reference?: true
    cashRegisterId?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
  }

  export type CashTransactionMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    reference?: true
    cashRegisterId?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
  }

  export type CashTransactionCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    reference?: true
    cashRegisterId?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type CashTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashTransaction to aggregate.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashTransactions
    **/
    _count?: true | CashTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashTransactionMaxAggregateInputType
  }

  export type GetCashTransactionAggregateType<T extends CashTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCashTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashTransaction[P]>
      : GetScalarType<T[P], AggregateCashTransaction[P]>
  }




  export type CashTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithAggregationInput | CashTransactionOrderByWithAggregationInput[]
    by: CashTransactionScalarFieldEnum[] | CashTransactionScalarFieldEnum
    having?: CashTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashTransactionCountAggregateInputType | true
    _avg?: CashTransactionAvgAggregateInputType
    _sum?: CashTransactionSumAggregateInputType
    _min?: CashTransactionMinAggregateInputType
    _max?: CashTransactionMaxAggregateInputType
  }

  export type CashTransactionGroupByOutputType = {
    id: string
    type: string
    amount: Decimal
    description: string
    reference: string | null
    cashRegisterId: string
    tenantId: string
    createdById: string
    createdAt: Date
    _count: CashTransactionCountAggregateOutputType | null
    _avg: CashTransactionAvgAggregateOutputType | null
    _sum: CashTransactionSumAggregateOutputType | null
    _min: CashTransactionMinAggregateOutputType | null
    _max: CashTransactionMaxAggregateOutputType | null
  }

  type GetCashTransactionGroupByPayload<T extends CashTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CashTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CashTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    reference?: boolean
    cashRegisterId?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    cashRegister?: boolean | CashRegisterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    reference?: boolean
    cashRegisterId?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    cashRegister?: boolean | CashRegisterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    reference?: boolean
    cashRegisterId?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    cashRegister?: boolean | CashRegisterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    reference?: boolean
    cashRegisterId?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type CashTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "amount" | "description" | "reference" | "cashRegisterId" | "tenantId" | "createdById" | "createdAt", ExtArgs["result"]["cashTransaction"]>
  export type CashTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashRegister?: boolean | CashRegisterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CashTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashRegister?: boolean | CashRegisterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CashTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashRegister?: boolean | CashRegisterDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CashTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashTransaction"
    objects: {
      cashRegister: Prisma.$CashRegisterPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      amount: Prisma.Decimal
      description: string
      reference: string | null
      cashRegisterId: string
      tenantId: string
      createdById: string
      createdAt: Date
    }, ExtArgs["result"]["cashTransaction"]>
    composites: {}
  }

  type CashTransactionGetPayload<S extends boolean | null | undefined | CashTransactionDefaultArgs> = $Result.GetResult<Prisma.$CashTransactionPayload, S>

  type CashTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashTransactionCountAggregateInputType | true
    }

  export interface CashTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashTransaction'], meta: { name: 'CashTransaction' } }
    /**
     * Find zero or one CashTransaction that matches the filter.
     * @param {CashTransactionFindUniqueArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashTransactionFindUniqueArgs>(args: SelectSubset<T, CashTransactionFindUniqueArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashTransactionFindUniqueOrThrowArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CashTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindFirstArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashTransactionFindFirstArgs>(args?: SelectSubset<T, CashTransactionFindFirstArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindFirstOrThrowArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CashTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashTransactions
     * const cashTransactions = await prisma.cashTransaction.findMany()
     * 
     * // Get first 10 CashTransactions
     * const cashTransactions = await prisma.cashTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashTransactionWithIdOnly = await prisma.cashTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashTransactionFindManyArgs>(args?: SelectSubset<T, CashTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashTransaction.
     * @param {CashTransactionCreateArgs} args - Arguments to create a CashTransaction.
     * @example
     * // Create one CashTransaction
     * const CashTransaction = await prisma.cashTransaction.create({
     *   data: {
     *     // ... data to create a CashTransaction
     *   }
     * })
     * 
     */
    create<T extends CashTransactionCreateArgs>(args: SelectSubset<T, CashTransactionCreateArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashTransactions.
     * @param {CashTransactionCreateManyArgs} args - Arguments to create many CashTransactions.
     * @example
     * // Create many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashTransactionCreateManyArgs>(args?: SelectSubset<T, CashTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashTransactions and returns the data saved in the database.
     * @param {CashTransactionCreateManyAndReturnArgs} args - Arguments to create many CashTransactions.
     * @example
     * // Create many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashTransactions and only return the `id`
     * const cashTransactionWithIdOnly = await prisma.cashTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CashTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashTransaction.
     * @param {CashTransactionDeleteArgs} args - Arguments to delete one CashTransaction.
     * @example
     * // Delete one CashTransaction
     * const CashTransaction = await prisma.cashTransaction.delete({
     *   where: {
     *     // ... filter to delete one CashTransaction
     *   }
     * })
     * 
     */
    delete<T extends CashTransactionDeleteArgs>(args: SelectSubset<T, CashTransactionDeleteArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashTransaction.
     * @param {CashTransactionUpdateArgs} args - Arguments to update one CashTransaction.
     * @example
     * // Update one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashTransactionUpdateArgs>(args: SelectSubset<T, CashTransactionUpdateArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashTransactions.
     * @param {CashTransactionDeleteManyArgs} args - Arguments to filter CashTransactions to delete.
     * @example
     * // Delete a few CashTransactions
     * const { count } = await prisma.cashTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashTransactionDeleteManyArgs>(args?: SelectSubset<T, CashTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashTransactionUpdateManyArgs>(args: SelectSubset<T, CashTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashTransactions and returns the data updated in the database.
     * @param {CashTransactionUpdateManyAndReturnArgs} args - Arguments to update many CashTransactions.
     * @example
     * // Update many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashTransactions and only return the `id`
     * const cashTransactionWithIdOnly = await prisma.cashTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, CashTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashTransaction.
     * @param {CashTransactionUpsertArgs} args - Arguments to update or create a CashTransaction.
     * @example
     * // Update or create a CashTransaction
     * const cashTransaction = await prisma.cashTransaction.upsert({
     *   create: {
     *     // ... data to create a CashTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CashTransactionUpsertArgs>(args: SelectSubset<T, CashTransactionUpsertArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionCountArgs} args - Arguments to filter CashTransactions to count.
     * @example
     * // Count the number of CashTransactions
     * const count = await prisma.cashTransaction.count({
     *   where: {
     *     // ... the filter for the CashTransactions we want to count
     *   }
     * })
    **/
    count<T extends CashTransactionCountArgs>(
      args?: Subset<T, CashTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashTransactionAggregateArgs>(args: Subset<T, CashTransactionAggregateArgs>): Prisma.PrismaPromise<GetCashTransactionAggregateType<T>>

    /**
     * Group by CashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CashTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashTransaction model
   */
  readonly fields: CashTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cashRegister<T extends CashRegisterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashRegisterDefaultArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashTransaction model
   */
  interface CashTransactionFieldRefs {
    readonly id: FieldRef<"CashTransaction", 'String'>
    readonly type: FieldRef<"CashTransaction", 'String'>
    readonly amount: FieldRef<"CashTransaction", 'Decimal'>
    readonly description: FieldRef<"CashTransaction", 'String'>
    readonly reference: FieldRef<"CashTransaction", 'String'>
    readonly cashRegisterId: FieldRef<"CashTransaction", 'String'>
    readonly tenantId: FieldRef<"CashTransaction", 'String'>
    readonly createdById: FieldRef<"CashTransaction", 'String'>
    readonly createdAt: FieldRef<"CashTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashTransaction findUnique
   */
  export type CashTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction findUniqueOrThrow
   */
  export type CashTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction findFirst
   */
  export type CashTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashTransactions.
     */
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction findFirstOrThrow
   */
  export type CashTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashTransactions.
     */
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction findMany
   */
  export type CashTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransactions to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction create
   */
  export type CashTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CashTransaction.
     */
    data: XOR<CashTransactionCreateInput, CashTransactionUncheckedCreateInput>
  }

  /**
   * CashTransaction createMany
   */
  export type CashTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashTransactions.
     */
    data: CashTransactionCreateManyInput | CashTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashTransaction createManyAndReturn
   */
  export type CashTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many CashTransactions.
     */
    data: CashTransactionCreateManyInput | CashTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashTransaction update
   */
  export type CashTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CashTransaction.
     */
    data: XOR<CashTransactionUpdateInput, CashTransactionUncheckedUpdateInput>
    /**
     * Choose, which CashTransaction to update.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction updateMany
   */
  export type CashTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashTransactions.
     */
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CashTransactions to update
     */
    where?: CashTransactionWhereInput
    /**
     * Limit how many CashTransactions to update.
     */
    limit?: number
  }

  /**
   * CashTransaction updateManyAndReturn
   */
  export type CashTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * The data used to update CashTransactions.
     */
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CashTransactions to update
     */
    where?: CashTransactionWhereInput
    /**
     * Limit how many CashTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashTransaction upsert
   */
  export type CashTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CashTransaction to update in case it exists.
     */
    where: CashTransactionWhereUniqueInput
    /**
     * In case the CashTransaction found by the `where` argument doesn't exist, create a new CashTransaction with this data.
     */
    create: XOR<CashTransactionCreateInput, CashTransactionUncheckedCreateInput>
    /**
     * In case the CashTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashTransactionUpdateInput, CashTransactionUncheckedUpdateInput>
  }

  /**
   * CashTransaction delete
   */
  export type CashTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter which CashTransaction to delete.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction deleteMany
   */
  export type CashTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashTransactions to delete
     */
    where?: CashTransactionWhereInput
    /**
     * Limit how many CashTransactions to delete.
     */
    limit?: number
  }

  /**
   * CashTransaction without action
   */
  export type CashTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
  }


  /**
   * Model TenantSettings
   */

  export type AggregateTenantSettings = {
    _count: TenantSettingsCountAggregateOutputType | null
    _avg: TenantSettingsAvgAggregateOutputType | null
    _sum: TenantSettingsSumAggregateOutputType | null
    _min: TenantSettingsMinAggregateOutputType | null
    _max: TenantSettingsMaxAggregateOutputType | null
  }

  export type TenantSettingsAvgAggregateOutputType = {
    taxRate: Decimal | null
    slaWarningPercent: number | null
    slaCriticalPercent: number | null
  }

  export type TenantSettingsSumAggregateOutputType = {
    taxRate: Decimal | null
    slaWarningPercent: number | null
    slaCriticalPercent: number | null
  }

  export type TenantSettingsMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    businessName: string | null
    businessNIT: string | null
    businessAddress: string | null
    businessPhone: string | null
    businessEmail: string | null
    taxRate: Decimal | null
    taxName: string | null
    currency: string | null
    defaultPaymentTerms: string | null
    invoiceFooter: string | null
    slaWarningPercent: number | null
    slaCriticalPercent: number | null
    slaEmailEnabled: boolean | null
    slaInAppEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantSettingsMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    businessName: string | null
    businessNIT: string | null
    businessAddress: string | null
    businessPhone: string | null
    businessEmail: string | null
    taxRate: Decimal | null
    taxName: string | null
    currency: string | null
    defaultPaymentTerms: string | null
    invoiceFooter: string | null
    slaWarningPercent: number | null
    slaCriticalPercent: number | null
    slaEmailEnabled: boolean | null
    slaInAppEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantSettingsCountAggregateOutputType = {
    id: number
    tenantId: number
    businessName: number
    businessNIT: number
    businessAddress: number
    businessPhone: number
    businessEmail: number
    taxRate: number
    taxName: number
    currency: number
    defaultPaymentTerms: number
    invoiceFooter: number
    slaWarningPercent: number
    slaCriticalPercent: number
    slaEmailEnabled: number
    slaInAppEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantSettingsAvgAggregateInputType = {
    taxRate?: true
    slaWarningPercent?: true
    slaCriticalPercent?: true
  }

  export type TenantSettingsSumAggregateInputType = {
    taxRate?: true
    slaWarningPercent?: true
    slaCriticalPercent?: true
  }

  export type TenantSettingsMinAggregateInputType = {
    id?: true
    tenantId?: true
    businessName?: true
    businessNIT?: true
    businessAddress?: true
    businessPhone?: true
    businessEmail?: true
    taxRate?: true
    taxName?: true
    currency?: true
    defaultPaymentTerms?: true
    invoiceFooter?: true
    slaWarningPercent?: true
    slaCriticalPercent?: true
    slaEmailEnabled?: true
    slaInAppEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantSettingsMaxAggregateInputType = {
    id?: true
    tenantId?: true
    businessName?: true
    businessNIT?: true
    businessAddress?: true
    businessPhone?: true
    businessEmail?: true
    taxRate?: true
    taxName?: true
    currency?: true
    defaultPaymentTerms?: true
    invoiceFooter?: true
    slaWarningPercent?: true
    slaCriticalPercent?: true
    slaEmailEnabled?: true
    slaInAppEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantSettingsCountAggregateInputType = {
    id?: true
    tenantId?: true
    businessName?: true
    businessNIT?: true
    businessAddress?: true
    businessPhone?: true
    businessEmail?: true
    taxRate?: true
    taxName?: true
    currency?: true
    defaultPaymentTerms?: true
    invoiceFooter?: true
    slaWarningPercent?: true
    slaCriticalPercent?: true
    slaEmailEnabled?: true
    slaInAppEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantSettings to aggregate.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantSettings
    **/
    _count?: true | TenantSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantSettingsMaxAggregateInputType
  }

  export type GetTenantSettingsAggregateType<T extends TenantSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantSettings[P]>
      : GetScalarType<T[P], AggregateTenantSettings[P]>
  }




  export type TenantSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantSettingsWhereInput
    orderBy?: TenantSettingsOrderByWithAggregationInput | TenantSettingsOrderByWithAggregationInput[]
    by: TenantSettingsScalarFieldEnum[] | TenantSettingsScalarFieldEnum
    having?: TenantSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantSettingsCountAggregateInputType | true
    _avg?: TenantSettingsAvgAggregateInputType
    _sum?: TenantSettingsSumAggregateInputType
    _min?: TenantSettingsMinAggregateInputType
    _max?: TenantSettingsMaxAggregateInputType
  }

  export type TenantSettingsGroupByOutputType = {
    id: string
    tenantId: string
    businessName: string | null
    businessNIT: string | null
    businessAddress: string | null
    businessPhone: string | null
    businessEmail: string | null
    taxRate: Decimal
    taxName: string
    currency: string
    defaultPaymentTerms: string | null
    invoiceFooter: string | null
    slaWarningPercent: number
    slaCriticalPercent: number
    slaEmailEnabled: boolean
    slaInAppEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantSettingsCountAggregateOutputType | null
    _avg: TenantSettingsAvgAggregateOutputType | null
    _sum: TenantSettingsSumAggregateOutputType | null
    _min: TenantSettingsMinAggregateOutputType | null
    _max: TenantSettingsMaxAggregateOutputType | null
  }

  type GetTenantSettingsGroupByPayload<T extends TenantSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], TenantSettingsGroupByOutputType[P]>
        }
      >
    >


  export type TenantSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    businessName?: boolean
    businessNIT?: boolean
    businessAddress?: boolean
    businessPhone?: boolean
    businessEmail?: boolean
    taxRate?: boolean
    taxName?: boolean
    currency?: boolean
    defaultPaymentTerms?: boolean
    invoiceFooter?: boolean
    slaWarningPercent?: boolean
    slaCriticalPercent?: boolean
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantSettings"]>

  export type TenantSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    businessName?: boolean
    businessNIT?: boolean
    businessAddress?: boolean
    businessPhone?: boolean
    businessEmail?: boolean
    taxRate?: boolean
    taxName?: boolean
    currency?: boolean
    defaultPaymentTerms?: boolean
    invoiceFooter?: boolean
    slaWarningPercent?: boolean
    slaCriticalPercent?: boolean
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantSettings"]>

  export type TenantSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    businessName?: boolean
    businessNIT?: boolean
    businessAddress?: boolean
    businessPhone?: boolean
    businessEmail?: boolean
    taxRate?: boolean
    taxName?: boolean
    currency?: boolean
    defaultPaymentTerms?: boolean
    invoiceFooter?: boolean
    slaWarningPercent?: boolean
    slaCriticalPercent?: boolean
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantSettings"]>

  export type TenantSettingsSelectScalar = {
    id?: boolean
    tenantId?: boolean
    businessName?: boolean
    businessNIT?: boolean
    businessAddress?: boolean
    businessPhone?: boolean
    businessEmail?: boolean
    taxRate?: boolean
    taxName?: boolean
    currency?: boolean
    defaultPaymentTerms?: boolean
    invoiceFooter?: boolean
    slaWarningPercent?: boolean
    slaCriticalPercent?: boolean
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "businessName" | "businessNIT" | "businessAddress" | "businessPhone" | "businessEmail" | "taxRate" | "taxName" | "currency" | "defaultPaymentTerms" | "invoiceFooter" | "slaWarningPercent" | "slaCriticalPercent" | "slaEmailEnabled" | "slaInAppEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantSettings"]>
  export type TenantSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantSettings"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      businessName: string | null
      businessNIT: string | null
      businessAddress: string | null
      businessPhone: string | null
      businessEmail: string | null
      taxRate: Prisma.Decimal
      taxName: string
      currency: string
      defaultPaymentTerms: string | null
      invoiceFooter: string | null
      slaWarningPercent: number
      slaCriticalPercent: number
      slaEmailEnabled: boolean
      slaInAppEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantSettings"]>
    composites: {}
  }

  type TenantSettingsGetPayload<S extends boolean | null | undefined | TenantSettingsDefaultArgs> = $Result.GetResult<Prisma.$TenantSettingsPayload, S>

  type TenantSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantSettingsCountAggregateInputType | true
    }

  export interface TenantSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantSettings'], meta: { name: 'TenantSettings' } }
    /**
     * Find zero or one TenantSettings that matches the filter.
     * @param {TenantSettingsFindUniqueArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantSettingsFindUniqueArgs>(args: SelectSubset<T, TenantSettingsFindUniqueArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantSettingsFindUniqueOrThrowArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindFirstArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantSettingsFindFirstArgs>(args?: SelectSubset<T, TenantSettingsFindFirstArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindFirstOrThrowArgs} args - Arguments to find a TenantSettings
     * @example
     * // Get one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findMany()
     * 
     * // Get first 10 TenantSettings
     * const tenantSettings = await prisma.tenantSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantSettingsWithIdOnly = await prisma.tenantSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantSettingsFindManyArgs>(args?: SelectSubset<T, TenantSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantSettings.
     * @param {TenantSettingsCreateArgs} args - Arguments to create a TenantSettings.
     * @example
     * // Create one TenantSettings
     * const TenantSettings = await prisma.tenantSettings.create({
     *   data: {
     *     // ... data to create a TenantSettings
     *   }
     * })
     * 
     */
    create<T extends TenantSettingsCreateArgs>(args: SelectSubset<T, TenantSettingsCreateArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantSettings.
     * @param {TenantSettingsCreateManyArgs} args - Arguments to create many TenantSettings.
     * @example
     * // Create many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantSettingsCreateManyArgs>(args?: SelectSubset<T, TenantSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantSettings and returns the data saved in the database.
     * @param {TenantSettingsCreateManyAndReturnArgs} args - Arguments to create many TenantSettings.
     * @example
     * // Create many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantSettings and only return the `id`
     * const tenantSettingsWithIdOnly = await prisma.tenantSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantSettings.
     * @param {TenantSettingsDeleteArgs} args - Arguments to delete one TenantSettings.
     * @example
     * // Delete one TenantSettings
     * const TenantSettings = await prisma.tenantSettings.delete({
     *   where: {
     *     // ... filter to delete one TenantSettings
     *   }
     * })
     * 
     */
    delete<T extends TenantSettingsDeleteArgs>(args: SelectSubset<T, TenantSettingsDeleteArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantSettings.
     * @param {TenantSettingsUpdateArgs} args - Arguments to update one TenantSettings.
     * @example
     * // Update one TenantSettings
     * const tenantSettings = await prisma.tenantSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantSettingsUpdateArgs>(args: SelectSubset<T, TenantSettingsUpdateArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantSettings.
     * @param {TenantSettingsDeleteManyArgs} args - Arguments to filter TenantSettings to delete.
     * @example
     * // Delete a few TenantSettings
     * const { count } = await prisma.tenantSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantSettingsDeleteManyArgs>(args?: SelectSubset<T, TenantSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantSettingsUpdateManyArgs>(args: SelectSubset<T, TenantSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantSettings and returns the data updated in the database.
     * @param {TenantSettingsUpdateManyAndReturnArgs} args - Arguments to update many TenantSettings.
     * @example
     * // Update many TenantSettings
     * const tenantSettings = await prisma.tenantSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantSettings and only return the `id`
     * const tenantSettingsWithIdOnly = await prisma.tenantSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantSettings.
     * @param {TenantSettingsUpsertArgs} args - Arguments to update or create a TenantSettings.
     * @example
     * // Update or create a TenantSettings
     * const tenantSettings = await prisma.tenantSettings.upsert({
     *   create: {
     *     // ... data to create a TenantSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantSettings we want to update
     *   }
     * })
     */
    upsert<T extends TenantSettingsUpsertArgs>(args: SelectSubset<T, TenantSettingsUpsertArgs<ExtArgs>>): Prisma__TenantSettingsClient<$Result.GetResult<Prisma.$TenantSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsCountArgs} args - Arguments to filter TenantSettings to count.
     * @example
     * // Count the number of TenantSettings
     * const count = await prisma.tenantSettings.count({
     *   where: {
     *     // ... the filter for the TenantSettings we want to count
     *   }
     * })
    **/
    count<T extends TenantSettingsCountArgs>(
      args?: Subset<T, TenantSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantSettingsAggregateArgs>(args: Subset<T, TenantSettingsAggregateArgs>): Prisma.PrismaPromise<GetTenantSettingsAggregateType<T>>

    /**
     * Group by TenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantSettingsGroupByArgs['orderBy'] }
        : { orderBy?: TenantSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantSettings model
   */
  readonly fields: TenantSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantSettings model
   */
  interface TenantSettingsFieldRefs {
    readonly id: FieldRef<"TenantSettings", 'String'>
    readonly tenantId: FieldRef<"TenantSettings", 'String'>
    readonly businessName: FieldRef<"TenantSettings", 'String'>
    readonly businessNIT: FieldRef<"TenantSettings", 'String'>
    readonly businessAddress: FieldRef<"TenantSettings", 'String'>
    readonly businessPhone: FieldRef<"TenantSettings", 'String'>
    readonly businessEmail: FieldRef<"TenantSettings", 'String'>
    readonly taxRate: FieldRef<"TenantSettings", 'Decimal'>
    readonly taxName: FieldRef<"TenantSettings", 'String'>
    readonly currency: FieldRef<"TenantSettings", 'String'>
    readonly defaultPaymentTerms: FieldRef<"TenantSettings", 'String'>
    readonly invoiceFooter: FieldRef<"TenantSettings", 'String'>
    readonly slaWarningPercent: FieldRef<"TenantSettings", 'Int'>
    readonly slaCriticalPercent: FieldRef<"TenantSettings", 'Int'>
    readonly slaEmailEnabled: FieldRef<"TenantSettings", 'Boolean'>
    readonly slaInAppEnabled: FieldRef<"TenantSettings", 'Boolean'>
    readonly createdAt: FieldRef<"TenantSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantSettings findUnique
   */
  export type TenantSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings findUniqueOrThrow
   */
  export type TenantSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings findFirst
   */
  export type TenantSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantSettings.
     */
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings findFirstOrThrow
   */
  export type TenantSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantSettings.
     */
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings findMany
   */
  export type TenantSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantSettings to fetch.
     */
    where?: TenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSettings to fetch.
     */
    orderBy?: TenantSettingsOrderByWithRelationInput | TenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantSettings.
     */
    cursor?: TenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSettings.
     */
    skip?: number
    distinct?: TenantSettingsScalarFieldEnum | TenantSettingsScalarFieldEnum[]
  }

  /**
   * TenantSettings create
   */
  export type TenantSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantSettings.
     */
    data: XOR<TenantSettingsCreateInput, TenantSettingsUncheckedCreateInput>
  }

  /**
   * TenantSettings createMany
   */
  export type TenantSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantSettings.
     */
    data: TenantSettingsCreateManyInput | TenantSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantSettings createManyAndReturn
   */
  export type TenantSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many TenantSettings.
     */
    data: TenantSettingsCreateManyInput | TenantSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantSettings update
   */
  export type TenantSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantSettings.
     */
    data: XOR<TenantSettingsUpdateInput, TenantSettingsUncheckedUpdateInput>
    /**
     * Choose, which TenantSettings to update.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings updateMany
   */
  export type TenantSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantSettings.
     */
    data: XOR<TenantSettingsUpdateManyMutationInput, TenantSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TenantSettings to update
     */
    where?: TenantSettingsWhereInput
    /**
     * Limit how many TenantSettings to update.
     */
    limit?: number
  }

  /**
   * TenantSettings updateManyAndReturn
   */
  export type TenantSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * The data used to update TenantSettings.
     */
    data: XOR<TenantSettingsUpdateManyMutationInput, TenantSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TenantSettings to update
     */
    where?: TenantSettingsWhereInput
    /**
     * Limit how many TenantSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantSettings upsert
   */
  export type TenantSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantSettings to update in case it exists.
     */
    where: TenantSettingsWhereUniqueInput
    /**
     * In case the TenantSettings found by the `where` argument doesn't exist, create a new TenantSettings with this data.
     */
    create: XOR<TenantSettingsCreateInput, TenantSettingsUncheckedCreateInput>
    /**
     * In case the TenantSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantSettingsUpdateInput, TenantSettingsUncheckedUpdateInput>
  }

  /**
   * TenantSettings delete
   */
  export type TenantSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
    /**
     * Filter which TenantSettings to delete.
     */
    where: TenantSettingsWhereUniqueInput
  }

  /**
   * TenantSettings deleteMany
   */
  export type TenantSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantSettings to delete
     */
    where?: TenantSettingsWhereInput
    /**
     * Limit how many TenantSettings to delete.
     */
    limit?: number
  }

  /**
   * TenantSettings without action
   */
  export type TenantSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSettings
     */
    select?: TenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantSettings
     */
    omit?: TenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSettingsInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceHistory
   */

  export type AggregateInvoiceHistory = {
    _count: InvoiceHistoryCountAggregateOutputType | null
    _min: InvoiceHistoryMinAggregateOutputType | null
    _max: InvoiceHistoryMaxAggregateOutputType | null
  }

  export type InvoiceHistoryMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    action: string | null
    oldValue: string | null
    newValue: string | null
    notes: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type InvoiceHistoryMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    action: string | null
    oldValue: string | null
    newValue: string | null
    notes: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type InvoiceHistoryCountAggregateOutputType = {
    id: number
    invoiceId: number
    action: number
    oldValue: number
    newValue: number
    notes: number
    userId: number
    createdAt: number
    _all: number
  }


  export type InvoiceHistoryMinAggregateInputType = {
    id?: true
    invoiceId?: true
    action?: true
    oldValue?: true
    newValue?: true
    notes?: true
    userId?: true
    createdAt?: true
  }

  export type InvoiceHistoryMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    action?: true
    oldValue?: true
    newValue?: true
    notes?: true
    userId?: true
    createdAt?: true
  }

  export type InvoiceHistoryCountAggregateInputType = {
    id?: true
    invoiceId?: true
    action?: true
    oldValue?: true
    newValue?: true
    notes?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type InvoiceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceHistory to aggregate.
     */
    where?: InvoiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceHistories to fetch.
     */
    orderBy?: InvoiceHistoryOrderByWithRelationInput | InvoiceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceHistories
    **/
    _count?: true | InvoiceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceHistoryMaxAggregateInputType
  }

  export type GetInvoiceHistoryAggregateType<T extends InvoiceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceHistory[P]>
      : GetScalarType<T[P], AggregateInvoiceHistory[P]>
  }




  export type InvoiceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceHistoryWhereInput
    orderBy?: InvoiceHistoryOrderByWithAggregationInput | InvoiceHistoryOrderByWithAggregationInput[]
    by: InvoiceHistoryScalarFieldEnum[] | InvoiceHistoryScalarFieldEnum
    having?: InvoiceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceHistoryCountAggregateInputType | true
    _min?: InvoiceHistoryMinAggregateInputType
    _max?: InvoiceHistoryMaxAggregateInputType
  }

  export type InvoiceHistoryGroupByOutputType = {
    id: string
    invoiceId: string
    action: string
    oldValue: string | null
    newValue: string | null
    notes: string | null
    userId: string
    createdAt: Date
    _count: InvoiceHistoryCountAggregateOutputType | null
    _min: InvoiceHistoryMinAggregateOutputType | null
    _max: InvoiceHistoryMaxAggregateOutputType | null
  }

  type GetInvoiceHistoryGroupByPayload<T extends InvoiceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    action?: boolean
    oldValue?: boolean
    newValue?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceHistory"]>

  export type InvoiceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    action?: boolean
    oldValue?: boolean
    newValue?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceHistory"]>

  export type InvoiceHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    action?: boolean
    oldValue?: boolean
    newValue?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceHistory"]>

  export type InvoiceHistorySelectScalar = {
    id?: boolean
    invoiceId?: boolean
    action?: boolean
    oldValue?: boolean
    newValue?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type InvoiceHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "action" | "oldValue" | "newValue" | "notes" | "userId" | "createdAt", ExtArgs["result"]["invoiceHistory"]>
  export type InvoiceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoiceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceHistory"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      action: string
      oldValue: string | null
      newValue: string | null
      notes: string | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["invoiceHistory"]>
    composites: {}
  }

  type InvoiceHistoryGetPayload<S extends boolean | null | undefined | InvoiceHistoryDefaultArgs> = $Result.GetResult<Prisma.$InvoiceHistoryPayload, S>

  type InvoiceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceHistoryCountAggregateInputType | true
    }

  export interface InvoiceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceHistory'], meta: { name: 'InvoiceHistory' } }
    /**
     * Find zero or one InvoiceHistory that matches the filter.
     * @param {InvoiceHistoryFindUniqueArgs} args - Arguments to find a InvoiceHistory
     * @example
     * // Get one InvoiceHistory
     * const invoiceHistory = await prisma.invoiceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceHistoryFindUniqueArgs>(args: SelectSubset<T, InvoiceHistoryFindUniqueArgs<ExtArgs>>): Prisma__InvoiceHistoryClient<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceHistoryFindUniqueOrThrowArgs} args - Arguments to find a InvoiceHistory
     * @example
     * // Get one InvoiceHistory
     * const invoiceHistory = await prisma.invoiceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceHistoryClient<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceHistoryFindFirstArgs} args - Arguments to find a InvoiceHistory
     * @example
     * // Get one InvoiceHistory
     * const invoiceHistory = await prisma.invoiceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceHistoryFindFirstArgs>(args?: SelectSubset<T, InvoiceHistoryFindFirstArgs<ExtArgs>>): Prisma__InvoiceHistoryClient<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceHistoryFindFirstOrThrowArgs} args - Arguments to find a InvoiceHistory
     * @example
     * // Get one InvoiceHistory
     * const invoiceHistory = await prisma.invoiceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceHistoryClient<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceHistories
     * const invoiceHistories = await prisma.invoiceHistory.findMany()
     * 
     * // Get first 10 InvoiceHistories
     * const invoiceHistories = await prisma.invoiceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceHistoryWithIdOnly = await prisma.invoiceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceHistoryFindManyArgs>(args?: SelectSubset<T, InvoiceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceHistory.
     * @param {InvoiceHistoryCreateArgs} args - Arguments to create a InvoiceHistory.
     * @example
     * // Create one InvoiceHistory
     * const InvoiceHistory = await prisma.invoiceHistory.create({
     *   data: {
     *     // ... data to create a InvoiceHistory
     *   }
     * })
     * 
     */
    create<T extends InvoiceHistoryCreateArgs>(args: SelectSubset<T, InvoiceHistoryCreateArgs<ExtArgs>>): Prisma__InvoiceHistoryClient<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceHistories.
     * @param {InvoiceHistoryCreateManyArgs} args - Arguments to create many InvoiceHistories.
     * @example
     * // Create many InvoiceHistories
     * const invoiceHistory = await prisma.invoiceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceHistoryCreateManyArgs>(args?: SelectSubset<T, InvoiceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceHistories and returns the data saved in the database.
     * @param {InvoiceHistoryCreateManyAndReturnArgs} args - Arguments to create many InvoiceHistories.
     * @example
     * // Create many InvoiceHistories
     * const invoiceHistory = await prisma.invoiceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceHistories and only return the `id`
     * const invoiceHistoryWithIdOnly = await prisma.invoiceHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceHistory.
     * @param {InvoiceHistoryDeleteArgs} args - Arguments to delete one InvoiceHistory.
     * @example
     * // Delete one InvoiceHistory
     * const InvoiceHistory = await prisma.invoiceHistory.delete({
     *   where: {
     *     // ... filter to delete one InvoiceHistory
     *   }
     * })
     * 
     */
    delete<T extends InvoiceHistoryDeleteArgs>(args: SelectSubset<T, InvoiceHistoryDeleteArgs<ExtArgs>>): Prisma__InvoiceHistoryClient<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceHistory.
     * @param {InvoiceHistoryUpdateArgs} args - Arguments to update one InvoiceHistory.
     * @example
     * // Update one InvoiceHistory
     * const invoiceHistory = await prisma.invoiceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceHistoryUpdateArgs>(args: SelectSubset<T, InvoiceHistoryUpdateArgs<ExtArgs>>): Prisma__InvoiceHistoryClient<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceHistories.
     * @param {InvoiceHistoryDeleteManyArgs} args - Arguments to filter InvoiceHistories to delete.
     * @example
     * // Delete a few InvoiceHistories
     * const { count } = await prisma.invoiceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceHistoryDeleteManyArgs>(args?: SelectSubset<T, InvoiceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceHistories
     * const invoiceHistory = await prisma.invoiceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceHistoryUpdateManyArgs>(args: SelectSubset<T, InvoiceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceHistories and returns the data updated in the database.
     * @param {InvoiceHistoryUpdateManyAndReturnArgs} args - Arguments to update many InvoiceHistories.
     * @example
     * // Update many InvoiceHistories
     * const invoiceHistory = await prisma.invoiceHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceHistories and only return the `id`
     * const invoiceHistoryWithIdOnly = await prisma.invoiceHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceHistory.
     * @param {InvoiceHistoryUpsertArgs} args - Arguments to update or create a InvoiceHistory.
     * @example
     * // Update or create a InvoiceHistory
     * const invoiceHistory = await prisma.invoiceHistory.upsert({
     *   create: {
     *     // ... data to create a InvoiceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceHistory we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceHistoryUpsertArgs>(args: SelectSubset<T, InvoiceHistoryUpsertArgs<ExtArgs>>): Prisma__InvoiceHistoryClient<$Result.GetResult<Prisma.$InvoiceHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceHistoryCountArgs} args - Arguments to filter InvoiceHistories to count.
     * @example
     * // Count the number of InvoiceHistories
     * const count = await prisma.invoiceHistory.count({
     *   where: {
     *     // ... the filter for the InvoiceHistories we want to count
     *   }
     * })
    **/
    count<T extends InvoiceHistoryCountArgs>(
      args?: Subset<T, InvoiceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceHistoryAggregateArgs>(args: Subset<T, InvoiceHistoryAggregateArgs>): Prisma.PrismaPromise<GetInvoiceHistoryAggregateType<T>>

    /**
     * Group by InvoiceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceHistory model
   */
  readonly fields: InvoiceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceHistory model
   */
  interface InvoiceHistoryFieldRefs {
    readonly id: FieldRef<"InvoiceHistory", 'String'>
    readonly invoiceId: FieldRef<"InvoiceHistory", 'String'>
    readonly action: FieldRef<"InvoiceHistory", 'String'>
    readonly oldValue: FieldRef<"InvoiceHistory", 'String'>
    readonly newValue: FieldRef<"InvoiceHistory", 'String'>
    readonly notes: FieldRef<"InvoiceHistory", 'String'>
    readonly userId: FieldRef<"InvoiceHistory", 'String'>
    readonly createdAt: FieldRef<"InvoiceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceHistory findUnique
   */
  export type InvoiceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceHistory to fetch.
     */
    where: InvoiceHistoryWhereUniqueInput
  }

  /**
   * InvoiceHistory findUniqueOrThrow
   */
  export type InvoiceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceHistory to fetch.
     */
    where: InvoiceHistoryWhereUniqueInput
  }

  /**
   * InvoiceHistory findFirst
   */
  export type InvoiceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceHistory to fetch.
     */
    where?: InvoiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceHistories to fetch.
     */
    orderBy?: InvoiceHistoryOrderByWithRelationInput | InvoiceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceHistories.
     */
    cursor?: InvoiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceHistories.
     */
    distinct?: InvoiceHistoryScalarFieldEnum | InvoiceHistoryScalarFieldEnum[]
  }

  /**
   * InvoiceHistory findFirstOrThrow
   */
  export type InvoiceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceHistory to fetch.
     */
    where?: InvoiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceHistories to fetch.
     */
    orderBy?: InvoiceHistoryOrderByWithRelationInput | InvoiceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceHistories.
     */
    cursor?: InvoiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceHistories.
     */
    distinct?: InvoiceHistoryScalarFieldEnum | InvoiceHistoryScalarFieldEnum[]
  }

  /**
   * InvoiceHistory findMany
   */
  export type InvoiceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceHistories to fetch.
     */
    where?: InvoiceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceHistories to fetch.
     */
    orderBy?: InvoiceHistoryOrderByWithRelationInput | InvoiceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceHistories.
     */
    cursor?: InvoiceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceHistories.
     */
    skip?: number
    distinct?: InvoiceHistoryScalarFieldEnum | InvoiceHistoryScalarFieldEnum[]
  }

  /**
   * InvoiceHistory create
   */
  export type InvoiceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceHistory.
     */
    data: XOR<InvoiceHistoryCreateInput, InvoiceHistoryUncheckedCreateInput>
  }

  /**
   * InvoiceHistory createMany
   */
  export type InvoiceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceHistories.
     */
    data: InvoiceHistoryCreateManyInput | InvoiceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceHistory createManyAndReturn
   */
  export type InvoiceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceHistories.
     */
    data: InvoiceHistoryCreateManyInput | InvoiceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceHistory update
   */
  export type InvoiceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceHistory.
     */
    data: XOR<InvoiceHistoryUpdateInput, InvoiceHistoryUncheckedUpdateInput>
    /**
     * Choose, which InvoiceHistory to update.
     */
    where: InvoiceHistoryWhereUniqueInput
  }

  /**
   * InvoiceHistory updateMany
   */
  export type InvoiceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceHistories.
     */
    data: XOR<InvoiceHistoryUpdateManyMutationInput, InvoiceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceHistories to update
     */
    where?: InvoiceHistoryWhereInput
    /**
     * Limit how many InvoiceHistories to update.
     */
    limit?: number
  }

  /**
   * InvoiceHistory updateManyAndReturn
   */
  export type InvoiceHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceHistories.
     */
    data: XOR<InvoiceHistoryUpdateManyMutationInput, InvoiceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceHistories to update
     */
    where?: InvoiceHistoryWhereInput
    /**
     * Limit how many InvoiceHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceHistory upsert
   */
  export type InvoiceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceHistory to update in case it exists.
     */
    where: InvoiceHistoryWhereUniqueInput
    /**
     * In case the InvoiceHistory found by the `where` argument doesn't exist, create a new InvoiceHistory with this data.
     */
    create: XOR<InvoiceHistoryCreateInput, InvoiceHistoryUncheckedCreateInput>
    /**
     * In case the InvoiceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceHistoryUpdateInput, InvoiceHistoryUncheckedUpdateInput>
  }

  /**
   * InvoiceHistory delete
   */
  export type InvoiceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
    /**
     * Filter which InvoiceHistory to delete.
     */
    where: InvoiceHistoryWhereUniqueInput
  }

  /**
   * InvoiceHistory deleteMany
   */
  export type InvoiceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceHistories to delete
     */
    where?: InvoiceHistoryWhereInput
    /**
     * Limit how many InvoiceHistories to delete.
     */
    limit?: number
  }

  /**
   * InvoiceHistory without action
   */
  export type InvoiceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceHistory
     */
    select?: InvoiceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceHistory
     */
    omit?: InvoiceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model POSSale
   */

  export type AggregatePOSSale = {
    _count: POSSaleCountAggregateOutputType | null
    _avg: POSSaleAvgAggregateOutputType | null
    _sum: POSSaleSumAggregateOutputType | null
    _min: POSSaleMinAggregateOutputType | null
    _max: POSSaleMaxAggregateOutputType | null
  }

  export type POSSaleAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    amountPaid: Decimal | null
    changeGiven: Decimal | null
  }

  export type POSSaleSumAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    amountPaid: Decimal | null
    changeGiven: Decimal | null
  }

  export type POSSaleMinAggregateOutputType = {
    id: string | null
    saleNumber: string | null
    customerId: string | null
    customerName: string | null
    customerPhone: string | null
    customerEmail: string | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    amountPaid: Decimal | null
    changeGiven: Decimal | null
    status: $Enums.POSSaleStatus | null
    notes: string | null
    tenantId: string | null
    cashRegisterId: string | null
    createdById: string | null
    quotationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type POSSaleMaxAggregateOutputType = {
    id: string | null
    saleNumber: string | null
    customerId: string | null
    customerName: string | null
    customerPhone: string | null
    customerEmail: string | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    amountPaid: Decimal | null
    changeGiven: Decimal | null
    status: $Enums.POSSaleStatus | null
    notes: string | null
    tenantId: string | null
    cashRegisterId: string | null
    createdById: string | null
    quotationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type POSSaleCountAggregateOutputType = {
    id: number
    saleNumber: number
    customerId: number
    customerName: number
    customerPhone: number
    customerEmail: number
    subtotal: number
    taxRate: number
    taxAmount: number
    discountAmount: number
    total: number
    amountPaid: number
    changeGiven: number
    status: number
    notes: number
    tenantId: number
    cashRegisterId: number
    createdById: number
    quotationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type POSSaleAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    amountPaid?: true
    changeGiven?: true
  }

  export type POSSaleSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    amountPaid?: true
    changeGiven?: true
  }

  export type POSSaleMinAggregateInputType = {
    id?: true
    saleNumber?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerEmail?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    amountPaid?: true
    changeGiven?: true
    status?: true
    notes?: true
    tenantId?: true
    cashRegisterId?: true
    createdById?: true
    quotationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type POSSaleMaxAggregateInputType = {
    id?: true
    saleNumber?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerEmail?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    amountPaid?: true
    changeGiven?: true
    status?: true
    notes?: true
    tenantId?: true
    cashRegisterId?: true
    createdById?: true
    quotationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type POSSaleCountAggregateInputType = {
    id?: true
    saleNumber?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerEmail?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    amountPaid?: true
    changeGiven?: true
    status?: true
    notes?: true
    tenantId?: true
    cashRegisterId?: true
    createdById?: true
    quotationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type POSSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSale to aggregate.
     */
    where?: POSSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSales to fetch.
     */
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSSales
    **/
    _count?: true | POSSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POSSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POSSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSSaleMaxAggregateInputType
  }

  export type GetPOSSaleAggregateType<T extends POSSaleAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSSale[P]>
      : GetScalarType<T[P], AggregatePOSSale[P]>
  }




  export type POSSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleWhereInput
    orderBy?: POSSaleOrderByWithAggregationInput | POSSaleOrderByWithAggregationInput[]
    by: POSSaleScalarFieldEnum[] | POSSaleScalarFieldEnum
    having?: POSSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSSaleCountAggregateInputType | true
    _avg?: POSSaleAvgAggregateInputType
    _sum?: POSSaleSumAggregateInputType
    _min?: POSSaleMinAggregateInputType
    _max?: POSSaleMaxAggregateInputType
  }

  export type POSSaleGroupByOutputType = {
    id: string
    saleNumber: string
    customerId: string | null
    customerName: string
    customerPhone: string | null
    customerEmail: string | null
    subtotal: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    discountAmount: Decimal
    total: Decimal
    amountPaid: Decimal
    changeGiven: Decimal
    status: $Enums.POSSaleStatus
    notes: string | null
    tenantId: string
    cashRegisterId: string | null
    createdById: string
    quotationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: POSSaleCountAggregateOutputType | null
    _avg: POSSaleAvgAggregateOutputType | null
    _sum: POSSaleSumAggregateOutputType | null
    _min: POSSaleMinAggregateOutputType | null
    _max: POSSaleMaxAggregateOutputType | null
  }

  type GetPOSSaleGroupByPayload<T extends POSSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSSaleGroupByOutputType[P]>
            : GetScalarType<T[P], POSSaleGroupByOutputType[P]>
        }
      >
    >


  export type POSSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    amountPaid?: boolean
    changeGiven?: boolean
    status?: boolean
    notes?: boolean
    tenantId?: boolean
    cashRegisterId?: boolean
    createdById?: boolean
    quotationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cashRegister?: boolean | POSSale$cashRegisterArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    creditNotes?: boolean | POSSale$creditNotesArgs<ExtArgs>
    customer?: boolean | POSSale$customerArgs<ExtArgs>
    items?: boolean | POSSale$itemsArgs<ExtArgs>
    payments?: boolean | POSSale$paymentsArgs<ExtArgs>
    quotation?: boolean | POSSale$quotationArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | POSSaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSale"]>

  export type POSSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    amountPaid?: boolean
    changeGiven?: boolean
    status?: boolean
    notes?: boolean
    tenantId?: boolean
    cashRegisterId?: boolean
    createdById?: boolean
    quotationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cashRegister?: boolean | POSSale$cashRegisterArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSSale$customerArgs<ExtArgs>
    quotation?: boolean | POSSale$quotationArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSale"]>

  export type POSSaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    amountPaid?: boolean
    changeGiven?: boolean
    status?: boolean
    notes?: boolean
    tenantId?: boolean
    cashRegisterId?: boolean
    createdById?: boolean
    quotationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cashRegister?: boolean | POSSale$cashRegisterArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSSale$customerArgs<ExtArgs>
    quotation?: boolean | POSSale$quotationArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSale"]>

  export type POSSaleSelectScalar = {
    id?: boolean
    saleNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    amountPaid?: boolean
    changeGiven?: boolean
    status?: boolean
    notes?: boolean
    tenantId?: boolean
    cashRegisterId?: boolean
    createdById?: boolean
    quotationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type POSSaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleNumber" | "customerId" | "customerName" | "customerPhone" | "customerEmail" | "subtotal" | "taxRate" | "taxAmount" | "discountAmount" | "total" | "amountPaid" | "changeGiven" | "status" | "notes" | "tenantId" | "cashRegisterId" | "createdById" | "quotationId" | "createdAt" | "updatedAt", ExtArgs["result"]["pOSSale"]>
  export type POSSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashRegister?: boolean | POSSale$cashRegisterArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    creditNotes?: boolean | POSSale$creditNotesArgs<ExtArgs>
    customer?: boolean | POSSale$customerArgs<ExtArgs>
    items?: boolean | POSSale$itemsArgs<ExtArgs>
    payments?: boolean | POSSale$paymentsArgs<ExtArgs>
    quotation?: boolean | POSSale$quotationArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | POSSaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type POSSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashRegister?: boolean | POSSale$cashRegisterArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSSale$customerArgs<ExtArgs>
    quotation?: boolean | POSSale$quotationArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type POSSaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashRegister?: boolean | POSSale$cashRegisterArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSSale$customerArgs<ExtArgs>
    quotation?: boolean | POSSale$quotationArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $POSSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSSale"
    objects: {
      cashRegister: Prisma.$CashRegisterPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      creditNotes: Prisma.$CreditNotePayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$POSSaleItemPayload<ExtArgs>[]
      payments: Prisma.$POSSalePaymentPayload<ExtArgs>[]
      quotation: Prisma.$POSQuotationPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleNumber: string
      customerId: string | null
      customerName: string
      customerPhone: string | null
      customerEmail: string | null
      subtotal: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      total: Prisma.Decimal
      amountPaid: Prisma.Decimal
      changeGiven: Prisma.Decimal
      status: $Enums.POSSaleStatus
      notes: string | null
      tenantId: string
      cashRegisterId: string | null
      createdById: string
      quotationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pOSSale"]>
    composites: {}
  }

  type POSSaleGetPayload<S extends boolean | null | undefined | POSSaleDefaultArgs> = $Result.GetResult<Prisma.$POSSalePayload, S>

  type POSSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POSSaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POSSaleCountAggregateInputType | true
    }

  export interface POSSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSSale'], meta: { name: 'POSSale' } }
    /**
     * Find zero or one POSSale that matches the filter.
     * @param {POSSaleFindUniqueArgs} args - Arguments to find a POSSale
     * @example
     * // Get one POSSale
     * const pOSSale = await prisma.pOSSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSSaleFindUniqueArgs>(args: SelectSubset<T, POSSaleFindUniqueArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one POSSale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POSSaleFindUniqueOrThrowArgs} args - Arguments to find a POSSale
     * @example
     * // Get one POSSale
     * const pOSSale = await prisma.pOSSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, POSSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleFindFirstArgs} args - Arguments to find a POSSale
     * @example
     * // Get one POSSale
     * const pOSSale = await prisma.pOSSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSSaleFindFirstArgs>(args?: SelectSubset<T, POSSaleFindFirstArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleFindFirstOrThrowArgs} args - Arguments to find a POSSale
     * @example
     * // Get one POSSale
     * const pOSSale = await prisma.pOSSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, POSSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSSales
     * const pOSSales = await prisma.pOSSale.findMany()
     * 
     * // Get first 10 POSSales
     * const pOSSales = await prisma.pOSSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSSaleWithIdOnly = await prisma.pOSSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSSaleFindManyArgs>(args?: SelectSubset<T, POSSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a POSSale.
     * @param {POSSaleCreateArgs} args - Arguments to create a POSSale.
     * @example
     * // Create one POSSale
     * const POSSale = await prisma.pOSSale.create({
     *   data: {
     *     // ... data to create a POSSale
     *   }
     * })
     * 
     */
    create<T extends POSSaleCreateArgs>(args: SelectSubset<T, POSSaleCreateArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many POSSales.
     * @param {POSSaleCreateManyArgs} args - Arguments to create many POSSales.
     * @example
     * // Create many POSSales
     * const pOSSale = await prisma.pOSSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSSaleCreateManyArgs>(args?: SelectSubset<T, POSSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POSSales and returns the data saved in the database.
     * @param {POSSaleCreateManyAndReturnArgs} args - Arguments to create many POSSales.
     * @example
     * // Create many POSSales
     * const pOSSale = await prisma.pOSSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POSSales and only return the `id`
     * const pOSSaleWithIdOnly = await prisma.pOSSale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POSSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, POSSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a POSSale.
     * @param {POSSaleDeleteArgs} args - Arguments to delete one POSSale.
     * @example
     * // Delete one POSSale
     * const POSSale = await prisma.pOSSale.delete({
     *   where: {
     *     // ... filter to delete one POSSale
     *   }
     * })
     * 
     */
    delete<T extends POSSaleDeleteArgs>(args: SelectSubset<T, POSSaleDeleteArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one POSSale.
     * @param {POSSaleUpdateArgs} args - Arguments to update one POSSale.
     * @example
     * // Update one POSSale
     * const pOSSale = await prisma.pOSSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSSaleUpdateArgs>(args: SelectSubset<T, POSSaleUpdateArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more POSSales.
     * @param {POSSaleDeleteManyArgs} args - Arguments to filter POSSales to delete.
     * @example
     * // Delete a few POSSales
     * const { count } = await prisma.pOSSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSSaleDeleteManyArgs>(args?: SelectSubset<T, POSSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSSales
     * const pOSSale = await prisma.pOSSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSSaleUpdateManyArgs>(args: SelectSubset<T, POSSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSSales and returns the data updated in the database.
     * @param {POSSaleUpdateManyAndReturnArgs} args - Arguments to update many POSSales.
     * @example
     * // Update many POSSales
     * const pOSSale = await prisma.pOSSale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more POSSales and only return the `id`
     * const pOSSaleWithIdOnly = await prisma.pOSSale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends POSSaleUpdateManyAndReturnArgs>(args: SelectSubset<T, POSSaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one POSSale.
     * @param {POSSaleUpsertArgs} args - Arguments to update or create a POSSale.
     * @example
     * // Update or create a POSSale
     * const pOSSale = await prisma.pOSSale.upsert({
     *   create: {
     *     // ... data to create a POSSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSSale we want to update
     *   }
     * })
     */
    upsert<T extends POSSaleUpsertArgs>(args: SelectSubset<T, POSSaleUpsertArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of POSSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleCountArgs} args - Arguments to filter POSSales to count.
     * @example
     * // Count the number of POSSales
     * const count = await prisma.pOSSale.count({
     *   where: {
     *     // ... the filter for the POSSales we want to count
     *   }
     * })
    **/
    count<T extends POSSaleCountArgs>(
      args?: Subset<T, POSSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSSaleAggregateArgs>(args: Subset<T, POSSaleAggregateArgs>): Prisma.PrismaPromise<GetPOSSaleAggregateType<T>>

    /**
     * Group by POSSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSSaleGroupByArgs['orderBy'] }
        : { orderBy?: POSSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSSale model
   */
  readonly fields: POSSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cashRegister<T extends POSSale$cashRegisterArgs<ExtArgs> = {}>(args?: Subset<T, POSSale$cashRegisterArgs<ExtArgs>>): Prisma__CashRegisterClient<$Result.GetResult<Prisma.$CashRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creditNotes<T extends POSSale$creditNotesArgs<ExtArgs> = {}>(args?: Subset<T, POSSale$creditNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends POSSale$customerArgs<ExtArgs> = {}>(args?: Subset<T, POSSale$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends POSSale$itemsArgs<ExtArgs> = {}>(args?: Subset<T, POSSale$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends POSSale$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, POSSale$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotation<T extends POSSale$quotationArgs<ExtArgs> = {}>(args?: Subset<T, POSSale$quotationArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSSale model
   */
  interface POSSaleFieldRefs {
    readonly id: FieldRef<"POSSale", 'String'>
    readonly saleNumber: FieldRef<"POSSale", 'String'>
    readonly customerId: FieldRef<"POSSale", 'String'>
    readonly customerName: FieldRef<"POSSale", 'String'>
    readonly customerPhone: FieldRef<"POSSale", 'String'>
    readonly customerEmail: FieldRef<"POSSale", 'String'>
    readonly subtotal: FieldRef<"POSSale", 'Decimal'>
    readonly taxRate: FieldRef<"POSSale", 'Decimal'>
    readonly taxAmount: FieldRef<"POSSale", 'Decimal'>
    readonly discountAmount: FieldRef<"POSSale", 'Decimal'>
    readonly total: FieldRef<"POSSale", 'Decimal'>
    readonly amountPaid: FieldRef<"POSSale", 'Decimal'>
    readonly changeGiven: FieldRef<"POSSale", 'Decimal'>
    readonly status: FieldRef<"POSSale", 'POSSaleStatus'>
    readonly notes: FieldRef<"POSSale", 'String'>
    readonly tenantId: FieldRef<"POSSale", 'String'>
    readonly cashRegisterId: FieldRef<"POSSale", 'String'>
    readonly createdById: FieldRef<"POSSale", 'String'>
    readonly quotationId: FieldRef<"POSSale", 'String'>
    readonly createdAt: FieldRef<"POSSale", 'DateTime'>
    readonly updatedAt: FieldRef<"POSSale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * POSSale findUnique
   */
  export type POSSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSale to fetch.
     */
    where: POSSaleWhereUniqueInput
  }

  /**
   * POSSale findUniqueOrThrow
   */
  export type POSSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSale to fetch.
     */
    where: POSSaleWhereUniqueInput
  }

  /**
   * POSSale findFirst
   */
  export type POSSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSale to fetch.
     */
    where?: POSSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSales to fetch.
     */
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSales.
     */
    cursor?: POSSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSales.
     */
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * POSSale findFirstOrThrow
   */
  export type POSSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSale to fetch.
     */
    where?: POSSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSales to fetch.
     */
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSales.
     */
    cursor?: POSSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSales.
     */
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * POSSale findMany
   */
  export type POSSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter, which POSSales to fetch.
     */
    where?: POSSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSales to fetch.
     */
    orderBy?: POSSaleOrderByWithRelationInput | POSSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSSales.
     */
    cursor?: POSSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSales.
     */
    skip?: number
    distinct?: POSSaleScalarFieldEnum | POSSaleScalarFieldEnum[]
  }

  /**
   * POSSale create
   */
  export type POSSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a POSSale.
     */
    data: XOR<POSSaleCreateInput, POSSaleUncheckedCreateInput>
  }

  /**
   * POSSale createMany
   */
  export type POSSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSSales.
     */
    data: POSSaleCreateManyInput | POSSaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POSSale createManyAndReturn
   */
  export type POSSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * The data used to create many POSSales.
     */
    data: POSSaleCreateManyInput | POSSaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSSale update
   */
  export type POSSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a POSSale.
     */
    data: XOR<POSSaleUpdateInput, POSSaleUncheckedUpdateInput>
    /**
     * Choose, which POSSale to update.
     */
    where: POSSaleWhereUniqueInput
  }

  /**
   * POSSale updateMany
   */
  export type POSSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSSales.
     */
    data: XOR<POSSaleUpdateManyMutationInput, POSSaleUncheckedUpdateManyInput>
    /**
     * Filter which POSSales to update
     */
    where?: POSSaleWhereInput
    /**
     * Limit how many POSSales to update.
     */
    limit?: number
  }

  /**
   * POSSale updateManyAndReturn
   */
  export type POSSaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * The data used to update POSSales.
     */
    data: XOR<POSSaleUpdateManyMutationInput, POSSaleUncheckedUpdateManyInput>
    /**
     * Filter which POSSales to update
     */
    where?: POSSaleWhereInput
    /**
     * Limit how many POSSales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSSale upsert
   */
  export type POSSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the POSSale to update in case it exists.
     */
    where: POSSaleWhereUniqueInput
    /**
     * In case the POSSale found by the `where` argument doesn't exist, create a new POSSale with this data.
     */
    create: XOR<POSSaleCreateInput, POSSaleUncheckedCreateInput>
    /**
     * In case the POSSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSSaleUpdateInput, POSSaleUncheckedUpdateInput>
  }

  /**
   * POSSale delete
   */
  export type POSSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    /**
     * Filter which POSSale to delete.
     */
    where: POSSaleWhereUniqueInput
  }

  /**
   * POSSale deleteMany
   */
  export type POSSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSales to delete
     */
    where?: POSSaleWhereInput
    /**
     * Limit how many POSSales to delete.
     */
    limit?: number
  }

  /**
   * POSSale.cashRegister
   */
  export type POSSale$cashRegisterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashRegister
     */
    select?: CashRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashRegister
     */
    omit?: CashRegisterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashRegisterInclude<ExtArgs> | null
    where?: CashRegisterWhereInput
  }

  /**
   * POSSale.creditNotes
   */
  export type POSSale$creditNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    where?: CreditNoteWhereInput
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    cursor?: CreditNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteScalarFieldEnum | CreditNoteScalarFieldEnum[]
  }

  /**
   * POSSale.customer
   */
  export type POSSale$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * POSSale.items
   */
  export type POSSale$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    where?: POSSaleItemWhereInput
    orderBy?: POSSaleItemOrderByWithRelationInput | POSSaleItemOrderByWithRelationInput[]
    cursor?: POSSaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSaleItemScalarFieldEnum | POSSaleItemScalarFieldEnum[]
  }

  /**
   * POSSale.payments
   */
  export type POSSale$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    where?: POSSalePaymentWhereInput
    orderBy?: POSSalePaymentOrderByWithRelationInput | POSSalePaymentOrderByWithRelationInput[]
    cursor?: POSSalePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSSalePaymentScalarFieldEnum | POSSalePaymentScalarFieldEnum[]
  }

  /**
   * POSSale.quotation
   */
  export type POSSale$quotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    where?: POSQuotationWhereInput
  }

  /**
   * POSSale without action
   */
  export type POSSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
  }


  /**
   * Model POSSaleItem
   */

  export type AggregatePOSSaleItem = {
    _count: POSSaleItemCountAggregateOutputType | null
    _avg: POSSaleItemAvgAggregateOutputType | null
    _sum: POSSaleItemSumAggregateOutputType | null
    _min: POSSaleItemMinAggregateOutputType | null
    _max: POSSaleItemMaxAggregateOutputType | null
  }

  export type POSSaleItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
  }

  export type POSSaleItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
  }

  export type POSSaleItemMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    partId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
  }

  export type POSSaleItemMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    partId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
  }

  export type POSSaleItemCountAggregateOutputType = {
    id: number
    saleId: number
    partId: number
    quantity: number
    unitPrice: number
    discount: number
    _all: number
  }


  export type POSSaleItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discount?: true
  }

  export type POSSaleItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discount?: true
  }

  export type POSSaleItemMinAggregateInputType = {
    id?: true
    saleId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    discount?: true
  }

  export type POSSaleItemMaxAggregateInputType = {
    id?: true
    saleId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    discount?: true
  }

  export type POSSaleItemCountAggregateInputType = {
    id?: true
    saleId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    _all?: true
  }

  export type POSSaleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSaleItem to aggregate.
     */
    where?: POSSaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSaleItems to fetch.
     */
    orderBy?: POSSaleItemOrderByWithRelationInput | POSSaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSSaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSSaleItems
    **/
    _count?: true | POSSaleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POSSaleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POSSaleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSSaleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSSaleItemMaxAggregateInputType
  }

  export type GetPOSSaleItemAggregateType<T extends POSSaleItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSSaleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSSaleItem[P]>
      : GetScalarType<T[P], AggregatePOSSaleItem[P]>
  }




  export type POSSaleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSaleItemWhereInput
    orderBy?: POSSaleItemOrderByWithAggregationInput | POSSaleItemOrderByWithAggregationInput[]
    by: POSSaleItemScalarFieldEnum[] | POSSaleItemScalarFieldEnum
    having?: POSSaleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSSaleItemCountAggregateInputType | true
    _avg?: POSSaleItemAvgAggregateInputType
    _sum?: POSSaleItemSumAggregateInputType
    _min?: POSSaleItemMinAggregateInputType
    _max?: POSSaleItemMaxAggregateInputType
  }

  export type POSSaleItemGroupByOutputType = {
    id: string
    saleId: string
    partId: string
    quantity: number
    unitPrice: Decimal
    discount: Decimal
    _count: POSSaleItemCountAggregateOutputType | null
    _avg: POSSaleItemAvgAggregateOutputType | null
    _sum: POSSaleItemSumAggregateOutputType | null
    _min: POSSaleItemMinAggregateOutputType | null
    _max: POSSaleItemMaxAggregateOutputType | null
  }

  type GetPOSSaleItemGroupByPayload<T extends POSSaleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSSaleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSSaleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSSaleItemGroupByOutputType[P]>
            : GetScalarType<T[P], POSSaleItemGroupByOutputType[P]>
        }
      >
    >


  export type POSSaleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSaleItem"]>

  export type POSSaleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSaleItem"]>

  export type POSSaleItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSaleItem"]>

  export type POSSaleItemSelectScalar = {
    id?: boolean
    saleId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
  }

  export type POSSaleItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "partId" | "quantity" | "unitPrice" | "discount", ExtArgs["result"]["pOSSaleItem"]>
  export type POSSaleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }
  export type POSSaleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }
  export type POSSaleItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }

  export type $POSSaleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSSaleItem"
    objects: {
      part: Prisma.$PartPayload<ExtArgs>
      sale: Prisma.$POSSalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      partId: string
      quantity: number
      unitPrice: Prisma.Decimal
      discount: Prisma.Decimal
    }, ExtArgs["result"]["pOSSaleItem"]>
    composites: {}
  }

  type POSSaleItemGetPayload<S extends boolean | null | undefined | POSSaleItemDefaultArgs> = $Result.GetResult<Prisma.$POSSaleItemPayload, S>

  type POSSaleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POSSaleItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POSSaleItemCountAggregateInputType | true
    }

  export interface POSSaleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSSaleItem'], meta: { name: 'POSSaleItem' } }
    /**
     * Find zero or one POSSaleItem that matches the filter.
     * @param {POSSaleItemFindUniqueArgs} args - Arguments to find a POSSaleItem
     * @example
     * // Get one POSSaleItem
     * const pOSSaleItem = await prisma.pOSSaleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSSaleItemFindUniqueArgs>(args: SelectSubset<T, POSSaleItemFindUniqueArgs<ExtArgs>>): Prisma__POSSaleItemClient<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one POSSaleItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POSSaleItemFindUniqueOrThrowArgs} args - Arguments to find a POSSaleItem
     * @example
     * // Get one POSSaleItem
     * const pOSSaleItem = await prisma.pOSSaleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSSaleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, POSSaleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSSaleItemClient<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSaleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleItemFindFirstArgs} args - Arguments to find a POSSaleItem
     * @example
     * // Get one POSSaleItem
     * const pOSSaleItem = await prisma.pOSSaleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSSaleItemFindFirstArgs>(args?: SelectSubset<T, POSSaleItemFindFirstArgs<ExtArgs>>): Prisma__POSSaleItemClient<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSaleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleItemFindFirstOrThrowArgs} args - Arguments to find a POSSaleItem
     * @example
     * // Get one POSSaleItem
     * const pOSSaleItem = await prisma.pOSSaleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSSaleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, POSSaleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSSaleItemClient<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSSaleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSSaleItems
     * const pOSSaleItems = await prisma.pOSSaleItem.findMany()
     * 
     * // Get first 10 POSSaleItems
     * const pOSSaleItems = await prisma.pOSSaleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSSaleItemWithIdOnly = await prisma.pOSSaleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSSaleItemFindManyArgs>(args?: SelectSubset<T, POSSaleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a POSSaleItem.
     * @param {POSSaleItemCreateArgs} args - Arguments to create a POSSaleItem.
     * @example
     * // Create one POSSaleItem
     * const POSSaleItem = await prisma.pOSSaleItem.create({
     *   data: {
     *     // ... data to create a POSSaleItem
     *   }
     * })
     * 
     */
    create<T extends POSSaleItemCreateArgs>(args: SelectSubset<T, POSSaleItemCreateArgs<ExtArgs>>): Prisma__POSSaleItemClient<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many POSSaleItems.
     * @param {POSSaleItemCreateManyArgs} args - Arguments to create many POSSaleItems.
     * @example
     * // Create many POSSaleItems
     * const pOSSaleItem = await prisma.pOSSaleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSSaleItemCreateManyArgs>(args?: SelectSubset<T, POSSaleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POSSaleItems and returns the data saved in the database.
     * @param {POSSaleItemCreateManyAndReturnArgs} args - Arguments to create many POSSaleItems.
     * @example
     * // Create many POSSaleItems
     * const pOSSaleItem = await prisma.pOSSaleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POSSaleItems and only return the `id`
     * const pOSSaleItemWithIdOnly = await prisma.pOSSaleItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POSSaleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, POSSaleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a POSSaleItem.
     * @param {POSSaleItemDeleteArgs} args - Arguments to delete one POSSaleItem.
     * @example
     * // Delete one POSSaleItem
     * const POSSaleItem = await prisma.pOSSaleItem.delete({
     *   where: {
     *     // ... filter to delete one POSSaleItem
     *   }
     * })
     * 
     */
    delete<T extends POSSaleItemDeleteArgs>(args: SelectSubset<T, POSSaleItemDeleteArgs<ExtArgs>>): Prisma__POSSaleItemClient<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one POSSaleItem.
     * @param {POSSaleItemUpdateArgs} args - Arguments to update one POSSaleItem.
     * @example
     * // Update one POSSaleItem
     * const pOSSaleItem = await prisma.pOSSaleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSSaleItemUpdateArgs>(args: SelectSubset<T, POSSaleItemUpdateArgs<ExtArgs>>): Prisma__POSSaleItemClient<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more POSSaleItems.
     * @param {POSSaleItemDeleteManyArgs} args - Arguments to filter POSSaleItems to delete.
     * @example
     * // Delete a few POSSaleItems
     * const { count } = await prisma.pOSSaleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSSaleItemDeleteManyArgs>(args?: SelectSubset<T, POSSaleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSSaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSSaleItems
     * const pOSSaleItem = await prisma.pOSSaleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSSaleItemUpdateManyArgs>(args: SelectSubset<T, POSSaleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSSaleItems and returns the data updated in the database.
     * @param {POSSaleItemUpdateManyAndReturnArgs} args - Arguments to update many POSSaleItems.
     * @example
     * // Update many POSSaleItems
     * const pOSSaleItem = await prisma.pOSSaleItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more POSSaleItems and only return the `id`
     * const pOSSaleItemWithIdOnly = await prisma.pOSSaleItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends POSSaleItemUpdateManyAndReturnArgs>(args: SelectSubset<T, POSSaleItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one POSSaleItem.
     * @param {POSSaleItemUpsertArgs} args - Arguments to update or create a POSSaleItem.
     * @example
     * // Update or create a POSSaleItem
     * const pOSSaleItem = await prisma.pOSSaleItem.upsert({
     *   create: {
     *     // ... data to create a POSSaleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSSaleItem we want to update
     *   }
     * })
     */
    upsert<T extends POSSaleItemUpsertArgs>(args: SelectSubset<T, POSSaleItemUpsertArgs<ExtArgs>>): Prisma__POSSaleItemClient<$Result.GetResult<Prisma.$POSSaleItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of POSSaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleItemCountArgs} args - Arguments to filter POSSaleItems to count.
     * @example
     * // Count the number of POSSaleItems
     * const count = await prisma.pOSSaleItem.count({
     *   where: {
     *     // ... the filter for the POSSaleItems we want to count
     *   }
     * })
    **/
    count<T extends POSSaleItemCountArgs>(
      args?: Subset<T, POSSaleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSSaleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSSaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSSaleItemAggregateArgs>(args: Subset<T, POSSaleItemAggregateArgs>): Prisma.PrismaPromise<GetPOSSaleItemAggregateType<T>>

    /**
     * Group by POSSaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSaleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSSaleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSSaleItemGroupByArgs['orderBy'] }
        : { orderBy?: POSSaleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSSaleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSSaleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSSaleItem model
   */
  readonly fields: POSSaleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSSaleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSSaleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    part<T extends PartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartDefaultArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sale<T extends POSSaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, POSSaleDefaultArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSSaleItem model
   */
  interface POSSaleItemFieldRefs {
    readonly id: FieldRef<"POSSaleItem", 'String'>
    readonly saleId: FieldRef<"POSSaleItem", 'String'>
    readonly partId: FieldRef<"POSSaleItem", 'String'>
    readonly quantity: FieldRef<"POSSaleItem", 'Int'>
    readonly unitPrice: FieldRef<"POSSaleItem", 'Decimal'>
    readonly discount: FieldRef<"POSSaleItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * POSSaleItem findUnique
   */
  export type POSSaleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleItem to fetch.
     */
    where: POSSaleItemWhereUniqueInput
  }

  /**
   * POSSaleItem findUniqueOrThrow
   */
  export type POSSaleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleItem to fetch.
     */
    where: POSSaleItemWhereUniqueInput
  }

  /**
   * POSSaleItem findFirst
   */
  export type POSSaleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleItem to fetch.
     */
    where?: POSSaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSaleItems to fetch.
     */
    orderBy?: POSSaleItemOrderByWithRelationInput | POSSaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSaleItems.
     */
    cursor?: POSSaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSaleItems.
     */
    distinct?: POSSaleItemScalarFieldEnum | POSSaleItemScalarFieldEnum[]
  }

  /**
   * POSSaleItem findFirstOrThrow
   */
  export type POSSaleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleItem to fetch.
     */
    where?: POSSaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSaleItems to fetch.
     */
    orderBy?: POSSaleItemOrderByWithRelationInput | POSSaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSaleItems.
     */
    cursor?: POSSaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSaleItems.
     */
    distinct?: POSSaleItemScalarFieldEnum | POSSaleItemScalarFieldEnum[]
  }

  /**
   * POSSaleItem findMany
   */
  export type POSSaleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * Filter, which POSSaleItems to fetch.
     */
    where?: POSSaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSaleItems to fetch.
     */
    orderBy?: POSSaleItemOrderByWithRelationInput | POSSaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSSaleItems.
     */
    cursor?: POSSaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSaleItems.
     */
    skip?: number
    distinct?: POSSaleItemScalarFieldEnum | POSSaleItemScalarFieldEnum[]
  }

  /**
   * POSSaleItem create
   */
  export type POSSaleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a POSSaleItem.
     */
    data: XOR<POSSaleItemCreateInput, POSSaleItemUncheckedCreateInput>
  }

  /**
   * POSSaleItem createMany
   */
  export type POSSaleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSSaleItems.
     */
    data: POSSaleItemCreateManyInput | POSSaleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POSSaleItem createManyAndReturn
   */
  export type POSSaleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * The data used to create many POSSaleItems.
     */
    data: POSSaleItemCreateManyInput | POSSaleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSSaleItem update
   */
  export type POSSaleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a POSSaleItem.
     */
    data: XOR<POSSaleItemUpdateInput, POSSaleItemUncheckedUpdateInput>
    /**
     * Choose, which POSSaleItem to update.
     */
    where: POSSaleItemWhereUniqueInput
  }

  /**
   * POSSaleItem updateMany
   */
  export type POSSaleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSSaleItems.
     */
    data: XOR<POSSaleItemUpdateManyMutationInput, POSSaleItemUncheckedUpdateManyInput>
    /**
     * Filter which POSSaleItems to update
     */
    where?: POSSaleItemWhereInput
    /**
     * Limit how many POSSaleItems to update.
     */
    limit?: number
  }

  /**
   * POSSaleItem updateManyAndReturn
   */
  export type POSSaleItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * The data used to update POSSaleItems.
     */
    data: XOR<POSSaleItemUpdateManyMutationInput, POSSaleItemUncheckedUpdateManyInput>
    /**
     * Filter which POSSaleItems to update
     */
    where?: POSSaleItemWhereInput
    /**
     * Limit how many POSSaleItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSSaleItem upsert
   */
  export type POSSaleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the POSSaleItem to update in case it exists.
     */
    where: POSSaleItemWhereUniqueInput
    /**
     * In case the POSSaleItem found by the `where` argument doesn't exist, create a new POSSaleItem with this data.
     */
    create: XOR<POSSaleItemCreateInput, POSSaleItemUncheckedCreateInput>
    /**
     * In case the POSSaleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSSaleItemUpdateInput, POSSaleItemUncheckedUpdateInput>
  }

  /**
   * POSSaleItem delete
   */
  export type POSSaleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
    /**
     * Filter which POSSaleItem to delete.
     */
    where: POSSaleItemWhereUniqueInput
  }

  /**
   * POSSaleItem deleteMany
   */
  export type POSSaleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSaleItems to delete
     */
    where?: POSSaleItemWhereInput
    /**
     * Limit how many POSSaleItems to delete.
     */
    limit?: number
  }

  /**
   * POSSaleItem without action
   */
  export type POSSaleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSaleItem
     */
    select?: POSSaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSaleItem
     */
    omit?: POSSaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleItemInclude<ExtArgs> | null
  }


  /**
   * Model POSSalePayment
   */

  export type AggregatePOSSalePayment = {
    _count: POSSalePaymentCountAggregateOutputType | null
    _avg: POSSalePaymentAvgAggregateOutputType | null
    _sum: POSSalePaymentSumAggregateOutputType | null
    _min: POSSalePaymentMinAggregateOutputType | null
    _max: POSSalePaymentMaxAggregateOutputType | null
  }

  export type POSSalePaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type POSSalePaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type POSSalePaymentMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    reference: string | null
    createdAt: Date | null
  }

  export type POSSalePaymentMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    reference: string | null
    createdAt: Date | null
  }

  export type POSSalePaymentCountAggregateOutputType = {
    id: number
    saleId: number
    amount: number
    method: number
    reference: number
    createdAt: number
    _all: number
  }


  export type POSSalePaymentAvgAggregateInputType = {
    amount?: true
  }

  export type POSSalePaymentSumAggregateInputType = {
    amount?: true
  }

  export type POSSalePaymentMinAggregateInputType = {
    id?: true
    saleId?: true
    amount?: true
    method?: true
    reference?: true
    createdAt?: true
  }

  export type POSSalePaymentMaxAggregateInputType = {
    id?: true
    saleId?: true
    amount?: true
    method?: true
    reference?: true
    createdAt?: true
  }

  export type POSSalePaymentCountAggregateInputType = {
    id?: true
    saleId?: true
    amount?: true
    method?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type POSSalePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSalePayment to aggregate.
     */
    where?: POSSalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSalePayments to fetch.
     */
    orderBy?: POSSalePaymentOrderByWithRelationInput | POSSalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSSalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSSalePayments
    **/
    _count?: true | POSSalePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POSSalePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POSSalePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSSalePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSSalePaymentMaxAggregateInputType
  }

  export type GetPOSSalePaymentAggregateType<T extends POSSalePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSSalePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSSalePayment[P]>
      : GetScalarType<T[P], AggregatePOSSalePayment[P]>
  }




  export type POSSalePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSSalePaymentWhereInput
    orderBy?: POSSalePaymentOrderByWithAggregationInput | POSSalePaymentOrderByWithAggregationInput[]
    by: POSSalePaymentScalarFieldEnum[] | POSSalePaymentScalarFieldEnum
    having?: POSSalePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSSalePaymentCountAggregateInputType | true
    _avg?: POSSalePaymentAvgAggregateInputType
    _sum?: POSSalePaymentSumAggregateInputType
    _min?: POSSalePaymentMinAggregateInputType
    _max?: POSSalePaymentMaxAggregateInputType
  }

  export type POSSalePaymentGroupByOutputType = {
    id: string
    saleId: string
    amount: Decimal
    method: $Enums.PaymentMethod
    reference: string | null
    createdAt: Date
    _count: POSSalePaymentCountAggregateOutputType | null
    _avg: POSSalePaymentAvgAggregateOutputType | null
    _sum: POSSalePaymentSumAggregateOutputType | null
    _min: POSSalePaymentMinAggregateOutputType | null
    _max: POSSalePaymentMaxAggregateOutputType | null
  }

  type GetPOSSalePaymentGroupByPayload<T extends POSSalePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSSalePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSSalePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSSalePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], POSSalePaymentGroupByOutputType[P]>
        }
      >
    >


  export type POSSalePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    amount?: boolean
    method?: boolean
    reference?: boolean
    createdAt?: boolean
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSalePayment"]>

  export type POSSalePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    amount?: boolean
    method?: boolean
    reference?: boolean
    createdAt?: boolean
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSalePayment"]>

  export type POSSalePaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    amount?: boolean
    method?: boolean
    reference?: boolean
    createdAt?: boolean
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSSalePayment"]>

  export type POSSalePaymentSelectScalar = {
    id?: boolean
    saleId?: boolean
    amount?: boolean
    method?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type POSSalePaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleId" | "amount" | "method" | "reference" | "createdAt", ExtArgs["result"]["pOSSalePayment"]>
  export type POSSalePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }
  export type POSSalePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }
  export type POSSalePaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | POSSaleDefaultArgs<ExtArgs>
  }

  export type $POSSalePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSSalePayment"
    objects: {
      sale: Prisma.$POSSalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      amount: Prisma.Decimal
      method: $Enums.PaymentMethod
      reference: string | null
      createdAt: Date
    }, ExtArgs["result"]["pOSSalePayment"]>
    composites: {}
  }

  type POSSalePaymentGetPayload<S extends boolean | null | undefined | POSSalePaymentDefaultArgs> = $Result.GetResult<Prisma.$POSSalePaymentPayload, S>

  type POSSalePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POSSalePaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POSSalePaymentCountAggregateInputType | true
    }

  export interface POSSalePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSSalePayment'], meta: { name: 'POSSalePayment' } }
    /**
     * Find zero or one POSSalePayment that matches the filter.
     * @param {POSSalePaymentFindUniqueArgs} args - Arguments to find a POSSalePayment
     * @example
     * // Get one POSSalePayment
     * const pOSSalePayment = await prisma.pOSSalePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSSalePaymentFindUniqueArgs>(args: SelectSubset<T, POSSalePaymentFindUniqueArgs<ExtArgs>>): Prisma__POSSalePaymentClient<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one POSSalePayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POSSalePaymentFindUniqueOrThrowArgs} args - Arguments to find a POSSalePayment
     * @example
     * // Get one POSSalePayment
     * const pOSSalePayment = await prisma.pOSSalePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSSalePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, POSSalePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSSalePaymentClient<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSalePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSalePaymentFindFirstArgs} args - Arguments to find a POSSalePayment
     * @example
     * // Get one POSSalePayment
     * const pOSSalePayment = await prisma.pOSSalePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSSalePaymentFindFirstArgs>(args?: SelectSubset<T, POSSalePaymentFindFirstArgs<ExtArgs>>): Prisma__POSSalePaymentClient<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSSalePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSalePaymentFindFirstOrThrowArgs} args - Arguments to find a POSSalePayment
     * @example
     * // Get one POSSalePayment
     * const pOSSalePayment = await prisma.pOSSalePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSSalePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, POSSalePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSSalePaymentClient<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSSalePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSalePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSSalePayments
     * const pOSSalePayments = await prisma.pOSSalePayment.findMany()
     * 
     * // Get first 10 POSSalePayments
     * const pOSSalePayments = await prisma.pOSSalePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSSalePaymentWithIdOnly = await prisma.pOSSalePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSSalePaymentFindManyArgs>(args?: SelectSubset<T, POSSalePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a POSSalePayment.
     * @param {POSSalePaymentCreateArgs} args - Arguments to create a POSSalePayment.
     * @example
     * // Create one POSSalePayment
     * const POSSalePayment = await prisma.pOSSalePayment.create({
     *   data: {
     *     // ... data to create a POSSalePayment
     *   }
     * })
     * 
     */
    create<T extends POSSalePaymentCreateArgs>(args: SelectSubset<T, POSSalePaymentCreateArgs<ExtArgs>>): Prisma__POSSalePaymentClient<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many POSSalePayments.
     * @param {POSSalePaymentCreateManyArgs} args - Arguments to create many POSSalePayments.
     * @example
     * // Create many POSSalePayments
     * const pOSSalePayment = await prisma.pOSSalePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSSalePaymentCreateManyArgs>(args?: SelectSubset<T, POSSalePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POSSalePayments and returns the data saved in the database.
     * @param {POSSalePaymentCreateManyAndReturnArgs} args - Arguments to create many POSSalePayments.
     * @example
     * // Create many POSSalePayments
     * const pOSSalePayment = await prisma.pOSSalePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POSSalePayments and only return the `id`
     * const pOSSalePaymentWithIdOnly = await prisma.pOSSalePayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POSSalePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, POSSalePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a POSSalePayment.
     * @param {POSSalePaymentDeleteArgs} args - Arguments to delete one POSSalePayment.
     * @example
     * // Delete one POSSalePayment
     * const POSSalePayment = await prisma.pOSSalePayment.delete({
     *   where: {
     *     // ... filter to delete one POSSalePayment
     *   }
     * })
     * 
     */
    delete<T extends POSSalePaymentDeleteArgs>(args: SelectSubset<T, POSSalePaymentDeleteArgs<ExtArgs>>): Prisma__POSSalePaymentClient<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one POSSalePayment.
     * @param {POSSalePaymentUpdateArgs} args - Arguments to update one POSSalePayment.
     * @example
     * // Update one POSSalePayment
     * const pOSSalePayment = await prisma.pOSSalePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSSalePaymentUpdateArgs>(args: SelectSubset<T, POSSalePaymentUpdateArgs<ExtArgs>>): Prisma__POSSalePaymentClient<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more POSSalePayments.
     * @param {POSSalePaymentDeleteManyArgs} args - Arguments to filter POSSalePayments to delete.
     * @example
     * // Delete a few POSSalePayments
     * const { count } = await prisma.pOSSalePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSSalePaymentDeleteManyArgs>(args?: SelectSubset<T, POSSalePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSSalePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSalePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSSalePayments
     * const pOSSalePayment = await prisma.pOSSalePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSSalePaymentUpdateManyArgs>(args: SelectSubset<T, POSSalePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSSalePayments and returns the data updated in the database.
     * @param {POSSalePaymentUpdateManyAndReturnArgs} args - Arguments to update many POSSalePayments.
     * @example
     * // Update many POSSalePayments
     * const pOSSalePayment = await prisma.pOSSalePayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more POSSalePayments and only return the `id`
     * const pOSSalePaymentWithIdOnly = await prisma.pOSSalePayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends POSSalePaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, POSSalePaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one POSSalePayment.
     * @param {POSSalePaymentUpsertArgs} args - Arguments to update or create a POSSalePayment.
     * @example
     * // Update or create a POSSalePayment
     * const pOSSalePayment = await prisma.pOSSalePayment.upsert({
     *   create: {
     *     // ... data to create a POSSalePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSSalePayment we want to update
     *   }
     * })
     */
    upsert<T extends POSSalePaymentUpsertArgs>(args: SelectSubset<T, POSSalePaymentUpsertArgs<ExtArgs>>): Prisma__POSSalePaymentClient<$Result.GetResult<Prisma.$POSSalePaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of POSSalePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSalePaymentCountArgs} args - Arguments to filter POSSalePayments to count.
     * @example
     * // Count the number of POSSalePayments
     * const count = await prisma.pOSSalePayment.count({
     *   where: {
     *     // ... the filter for the POSSalePayments we want to count
     *   }
     * })
    **/
    count<T extends POSSalePaymentCountArgs>(
      args?: Subset<T, POSSalePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSSalePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSSalePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSalePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSSalePaymentAggregateArgs>(args: Subset<T, POSSalePaymentAggregateArgs>): Prisma.PrismaPromise<GetPOSSalePaymentAggregateType<T>>

    /**
     * Group by POSSalePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSSalePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSSalePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSSalePaymentGroupByArgs['orderBy'] }
        : { orderBy?: POSSalePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSSalePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSSalePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSSalePayment model
   */
  readonly fields: POSSalePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSSalePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSSalePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends POSSaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, POSSaleDefaultArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSSalePayment model
   */
  interface POSSalePaymentFieldRefs {
    readonly id: FieldRef<"POSSalePayment", 'String'>
    readonly saleId: FieldRef<"POSSalePayment", 'String'>
    readonly amount: FieldRef<"POSSalePayment", 'Decimal'>
    readonly method: FieldRef<"POSSalePayment", 'PaymentMethod'>
    readonly reference: FieldRef<"POSSalePayment", 'String'>
    readonly createdAt: FieldRef<"POSSalePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * POSSalePayment findUnique
   */
  export type POSSalePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which POSSalePayment to fetch.
     */
    where: POSSalePaymentWhereUniqueInput
  }

  /**
   * POSSalePayment findUniqueOrThrow
   */
  export type POSSalePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which POSSalePayment to fetch.
     */
    where: POSSalePaymentWhereUniqueInput
  }

  /**
   * POSSalePayment findFirst
   */
  export type POSSalePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which POSSalePayment to fetch.
     */
    where?: POSSalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSalePayments to fetch.
     */
    orderBy?: POSSalePaymentOrderByWithRelationInput | POSSalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSalePayments.
     */
    cursor?: POSSalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSalePayments.
     */
    distinct?: POSSalePaymentScalarFieldEnum | POSSalePaymentScalarFieldEnum[]
  }

  /**
   * POSSalePayment findFirstOrThrow
   */
  export type POSSalePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which POSSalePayment to fetch.
     */
    where?: POSSalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSalePayments to fetch.
     */
    orderBy?: POSSalePaymentOrderByWithRelationInput | POSSalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSSalePayments.
     */
    cursor?: POSSalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSSalePayments.
     */
    distinct?: POSSalePaymentScalarFieldEnum | POSSalePaymentScalarFieldEnum[]
  }

  /**
   * POSSalePayment findMany
   */
  export type POSSalePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which POSSalePayments to fetch.
     */
    where?: POSSalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSSalePayments to fetch.
     */
    orderBy?: POSSalePaymentOrderByWithRelationInput | POSSalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSSalePayments.
     */
    cursor?: POSSalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSSalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSSalePayments.
     */
    skip?: number
    distinct?: POSSalePaymentScalarFieldEnum | POSSalePaymentScalarFieldEnum[]
  }

  /**
   * POSSalePayment create
   */
  export type POSSalePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a POSSalePayment.
     */
    data: XOR<POSSalePaymentCreateInput, POSSalePaymentUncheckedCreateInput>
  }

  /**
   * POSSalePayment createMany
   */
  export type POSSalePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSSalePayments.
     */
    data: POSSalePaymentCreateManyInput | POSSalePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POSSalePayment createManyAndReturn
   */
  export type POSSalePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * The data used to create many POSSalePayments.
     */
    data: POSSalePaymentCreateManyInput | POSSalePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSSalePayment update
   */
  export type POSSalePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a POSSalePayment.
     */
    data: XOR<POSSalePaymentUpdateInput, POSSalePaymentUncheckedUpdateInput>
    /**
     * Choose, which POSSalePayment to update.
     */
    where: POSSalePaymentWhereUniqueInput
  }

  /**
   * POSSalePayment updateMany
   */
  export type POSSalePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSSalePayments.
     */
    data: XOR<POSSalePaymentUpdateManyMutationInput, POSSalePaymentUncheckedUpdateManyInput>
    /**
     * Filter which POSSalePayments to update
     */
    where?: POSSalePaymentWhereInput
    /**
     * Limit how many POSSalePayments to update.
     */
    limit?: number
  }

  /**
   * POSSalePayment updateManyAndReturn
   */
  export type POSSalePaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * The data used to update POSSalePayments.
     */
    data: XOR<POSSalePaymentUpdateManyMutationInput, POSSalePaymentUncheckedUpdateManyInput>
    /**
     * Filter which POSSalePayments to update
     */
    where?: POSSalePaymentWhereInput
    /**
     * Limit how many POSSalePayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSSalePayment upsert
   */
  export type POSSalePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the POSSalePayment to update in case it exists.
     */
    where: POSSalePaymentWhereUniqueInput
    /**
     * In case the POSSalePayment found by the `where` argument doesn't exist, create a new POSSalePayment with this data.
     */
    create: XOR<POSSalePaymentCreateInput, POSSalePaymentUncheckedCreateInput>
    /**
     * In case the POSSalePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSSalePaymentUpdateInput, POSSalePaymentUncheckedUpdateInput>
  }

  /**
   * POSSalePayment delete
   */
  export type POSSalePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
    /**
     * Filter which POSSalePayment to delete.
     */
    where: POSSalePaymentWhereUniqueInput
  }

  /**
   * POSSalePayment deleteMany
   */
  export type POSSalePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSSalePayments to delete
     */
    where?: POSSalePaymentWhereInput
    /**
     * Limit how many POSSalePayments to delete.
     */
    limit?: number
  }

  /**
   * POSSalePayment without action
   */
  export type POSSalePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSalePayment
     */
    select?: POSSalePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSalePayment
     */
    omit?: POSSalePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSalePaymentInclude<ExtArgs> | null
  }


  /**
   * Model POSQuotation
   */

  export type AggregatePOSQuotation = {
    _count: POSQuotationCountAggregateOutputType | null
    _avg: POSQuotationAvgAggregateOutputType | null
    _sum: POSQuotationSumAggregateOutputType | null
    _min: POSQuotationMinAggregateOutputType | null
    _max: POSQuotationMaxAggregateOutputType | null
  }

  export type POSQuotationAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
  }

  export type POSQuotationSumAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
  }

  export type POSQuotationMinAggregateOutputType = {
    id: string | null
    quotationNumber: string | null
    customerId: string | null
    customerName: string | null
    customerPhone: string | null
    customerEmail: string | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    status: $Enums.QuotationStatus | null
    validUntil: Date | null
    notes: string | null
    tenantId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type POSQuotationMaxAggregateOutputType = {
    id: string | null
    quotationNumber: string | null
    customerId: string | null
    customerName: string | null
    customerPhone: string | null
    customerEmail: string | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    status: $Enums.QuotationStatus | null
    validUntil: Date | null
    notes: string | null
    tenantId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type POSQuotationCountAggregateOutputType = {
    id: number
    quotationNumber: number
    customerId: number
    customerName: number
    customerPhone: number
    customerEmail: number
    subtotal: number
    taxRate: number
    taxAmount: number
    discountAmount: number
    total: number
    status: number
    validUntil: number
    notes: number
    tenantId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type POSQuotationAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
  }

  export type POSQuotationSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
  }

  export type POSQuotationMinAggregateInputType = {
    id?: true
    quotationNumber?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerEmail?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    status?: true
    validUntil?: true
    notes?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type POSQuotationMaxAggregateInputType = {
    id?: true
    quotationNumber?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerEmail?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    status?: true
    validUntil?: true
    notes?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type POSQuotationCountAggregateInputType = {
    id?: true
    quotationNumber?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerEmail?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    status?: true
    validUntil?: true
    notes?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type POSQuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSQuotation to aggregate.
     */
    where?: POSQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSQuotations to fetch.
     */
    orderBy?: POSQuotationOrderByWithRelationInput | POSQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSQuotations
    **/
    _count?: true | POSQuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POSQuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POSQuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSQuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSQuotationMaxAggregateInputType
  }

  export type GetPOSQuotationAggregateType<T extends POSQuotationAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSQuotation[P]>
      : GetScalarType<T[P], AggregatePOSQuotation[P]>
  }




  export type POSQuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSQuotationWhereInput
    orderBy?: POSQuotationOrderByWithAggregationInput | POSQuotationOrderByWithAggregationInput[]
    by: POSQuotationScalarFieldEnum[] | POSQuotationScalarFieldEnum
    having?: POSQuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSQuotationCountAggregateInputType | true
    _avg?: POSQuotationAvgAggregateInputType
    _sum?: POSQuotationSumAggregateInputType
    _min?: POSQuotationMinAggregateInputType
    _max?: POSQuotationMaxAggregateInputType
  }

  export type POSQuotationGroupByOutputType = {
    id: string
    quotationNumber: string
    customerId: string | null
    customerName: string
    customerPhone: string | null
    customerEmail: string | null
    subtotal: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    discountAmount: Decimal
    total: Decimal
    status: $Enums.QuotationStatus
    validUntil: Date | null
    notes: string | null
    tenantId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: POSQuotationCountAggregateOutputType | null
    _avg: POSQuotationAvgAggregateOutputType | null
    _sum: POSQuotationSumAggregateOutputType | null
    _min: POSQuotationMinAggregateOutputType | null
    _max: POSQuotationMaxAggregateOutputType | null
  }

  type GetPOSQuotationGroupByPayload<T extends POSQuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSQuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSQuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSQuotationGroupByOutputType[P]>
            : GetScalarType<T[P], POSQuotationGroupByOutputType[P]>
        }
      >
    >


  export type POSQuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    status?: boolean
    validUntil?: boolean
    notes?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSQuotation$customerArgs<ExtArgs>
    items?: boolean | POSQuotation$itemsArgs<ExtArgs>
    convertedToSale?: boolean | POSQuotation$convertedToSaleArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | POSQuotationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSQuotation"]>

  export type POSQuotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    status?: boolean
    validUntil?: boolean
    notes?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSQuotation$customerArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSQuotation"]>

  export type POSQuotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    status?: boolean
    validUntil?: boolean
    notes?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSQuotation$customerArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSQuotation"]>

  export type POSQuotationSelectScalar = {
    id?: boolean
    quotationNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    status?: boolean
    validUntil?: boolean
    notes?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type POSQuotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quotationNumber" | "customerId" | "customerName" | "customerPhone" | "customerEmail" | "subtotal" | "taxRate" | "taxAmount" | "discountAmount" | "total" | "status" | "validUntil" | "notes" | "tenantId" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["pOSQuotation"]>
  export type POSQuotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSQuotation$customerArgs<ExtArgs>
    items?: boolean | POSQuotation$itemsArgs<ExtArgs>
    convertedToSale?: boolean | POSQuotation$convertedToSaleArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | POSQuotationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type POSQuotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSQuotation$customerArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type POSQuotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | POSQuotation$customerArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $POSQuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSQuotation"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$POSQuotationItemPayload<ExtArgs>[]
      convertedToSale: Prisma.$POSSalePayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quotationNumber: string
      customerId: string | null
      customerName: string
      customerPhone: string | null
      customerEmail: string | null
      subtotal: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      total: Prisma.Decimal
      status: $Enums.QuotationStatus
      validUntil: Date | null
      notes: string | null
      tenantId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pOSQuotation"]>
    composites: {}
  }

  type POSQuotationGetPayload<S extends boolean | null | undefined | POSQuotationDefaultArgs> = $Result.GetResult<Prisma.$POSQuotationPayload, S>

  type POSQuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POSQuotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POSQuotationCountAggregateInputType | true
    }

  export interface POSQuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSQuotation'], meta: { name: 'POSQuotation' } }
    /**
     * Find zero or one POSQuotation that matches the filter.
     * @param {POSQuotationFindUniqueArgs} args - Arguments to find a POSQuotation
     * @example
     * // Get one POSQuotation
     * const pOSQuotation = await prisma.pOSQuotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSQuotationFindUniqueArgs>(args: SelectSubset<T, POSQuotationFindUniqueArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one POSQuotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POSQuotationFindUniqueOrThrowArgs} args - Arguments to find a POSQuotation
     * @example
     * // Get one POSQuotation
     * const pOSQuotation = await prisma.pOSQuotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSQuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, POSQuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSQuotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationFindFirstArgs} args - Arguments to find a POSQuotation
     * @example
     * // Get one POSQuotation
     * const pOSQuotation = await prisma.pOSQuotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSQuotationFindFirstArgs>(args?: SelectSubset<T, POSQuotationFindFirstArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSQuotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationFindFirstOrThrowArgs} args - Arguments to find a POSQuotation
     * @example
     * // Get one POSQuotation
     * const pOSQuotation = await prisma.pOSQuotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSQuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, POSQuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSQuotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSQuotations
     * const pOSQuotations = await prisma.pOSQuotation.findMany()
     * 
     * // Get first 10 POSQuotations
     * const pOSQuotations = await prisma.pOSQuotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSQuotationWithIdOnly = await prisma.pOSQuotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSQuotationFindManyArgs>(args?: SelectSubset<T, POSQuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a POSQuotation.
     * @param {POSQuotationCreateArgs} args - Arguments to create a POSQuotation.
     * @example
     * // Create one POSQuotation
     * const POSQuotation = await prisma.pOSQuotation.create({
     *   data: {
     *     // ... data to create a POSQuotation
     *   }
     * })
     * 
     */
    create<T extends POSQuotationCreateArgs>(args: SelectSubset<T, POSQuotationCreateArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many POSQuotations.
     * @param {POSQuotationCreateManyArgs} args - Arguments to create many POSQuotations.
     * @example
     * // Create many POSQuotations
     * const pOSQuotation = await prisma.pOSQuotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSQuotationCreateManyArgs>(args?: SelectSubset<T, POSQuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POSQuotations and returns the data saved in the database.
     * @param {POSQuotationCreateManyAndReturnArgs} args - Arguments to create many POSQuotations.
     * @example
     * // Create many POSQuotations
     * const pOSQuotation = await prisma.pOSQuotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POSQuotations and only return the `id`
     * const pOSQuotationWithIdOnly = await prisma.pOSQuotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POSQuotationCreateManyAndReturnArgs>(args?: SelectSubset<T, POSQuotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a POSQuotation.
     * @param {POSQuotationDeleteArgs} args - Arguments to delete one POSQuotation.
     * @example
     * // Delete one POSQuotation
     * const POSQuotation = await prisma.pOSQuotation.delete({
     *   where: {
     *     // ... filter to delete one POSQuotation
     *   }
     * })
     * 
     */
    delete<T extends POSQuotationDeleteArgs>(args: SelectSubset<T, POSQuotationDeleteArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one POSQuotation.
     * @param {POSQuotationUpdateArgs} args - Arguments to update one POSQuotation.
     * @example
     * // Update one POSQuotation
     * const pOSQuotation = await prisma.pOSQuotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSQuotationUpdateArgs>(args: SelectSubset<T, POSQuotationUpdateArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more POSQuotations.
     * @param {POSQuotationDeleteManyArgs} args - Arguments to filter POSQuotations to delete.
     * @example
     * // Delete a few POSQuotations
     * const { count } = await prisma.pOSQuotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSQuotationDeleteManyArgs>(args?: SelectSubset<T, POSQuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSQuotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSQuotations
     * const pOSQuotation = await prisma.pOSQuotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSQuotationUpdateManyArgs>(args: SelectSubset<T, POSQuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSQuotations and returns the data updated in the database.
     * @param {POSQuotationUpdateManyAndReturnArgs} args - Arguments to update many POSQuotations.
     * @example
     * // Update many POSQuotations
     * const pOSQuotation = await prisma.pOSQuotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more POSQuotations and only return the `id`
     * const pOSQuotationWithIdOnly = await prisma.pOSQuotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends POSQuotationUpdateManyAndReturnArgs>(args: SelectSubset<T, POSQuotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one POSQuotation.
     * @param {POSQuotationUpsertArgs} args - Arguments to update or create a POSQuotation.
     * @example
     * // Update or create a POSQuotation
     * const pOSQuotation = await prisma.pOSQuotation.upsert({
     *   create: {
     *     // ... data to create a POSQuotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSQuotation we want to update
     *   }
     * })
     */
    upsert<T extends POSQuotationUpsertArgs>(args: SelectSubset<T, POSQuotationUpsertArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of POSQuotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationCountArgs} args - Arguments to filter POSQuotations to count.
     * @example
     * // Count the number of POSQuotations
     * const count = await prisma.pOSQuotation.count({
     *   where: {
     *     // ... the filter for the POSQuotations we want to count
     *   }
     * })
    **/
    count<T extends POSQuotationCountArgs>(
      args?: Subset<T, POSQuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSQuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSQuotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSQuotationAggregateArgs>(args: Subset<T, POSQuotationAggregateArgs>): Prisma.PrismaPromise<GetPOSQuotationAggregateType<T>>

    /**
     * Group by POSQuotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSQuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSQuotationGroupByArgs['orderBy'] }
        : { orderBy?: POSQuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSQuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSQuotation model
   */
  readonly fields: POSQuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSQuotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSQuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends POSQuotation$customerArgs<ExtArgs> = {}>(args?: Subset<T, POSQuotation$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends POSQuotation$itemsArgs<ExtArgs> = {}>(args?: Subset<T, POSQuotation$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    convertedToSale<T extends POSQuotation$convertedToSaleArgs<ExtArgs> = {}>(args?: Subset<T, POSQuotation$convertedToSaleArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSQuotation model
   */
  interface POSQuotationFieldRefs {
    readonly id: FieldRef<"POSQuotation", 'String'>
    readonly quotationNumber: FieldRef<"POSQuotation", 'String'>
    readonly customerId: FieldRef<"POSQuotation", 'String'>
    readonly customerName: FieldRef<"POSQuotation", 'String'>
    readonly customerPhone: FieldRef<"POSQuotation", 'String'>
    readonly customerEmail: FieldRef<"POSQuotation", 'String'>
    readonly subtotal: FieldRef<"POSQuotation", 'Decimal'>
    readonly taxRate: FieldRef<"POSQuotation", 'Decimal'>
    readonly taxAmount: FieldRef<"POSQuotation", 'Decimal'>
    readonly discountAmount: FieldRef<"POSQuotation", 'Decimal'>
    readonly total: FieldRef<"POSQuotation", 'Decimal'>
    readonly status: FieldRef<"POSQuotation", 'QuotationStatus'>
    readonly validUntil: FieldRef<"POSQuotation", 'DateTime'>
    readonly notes: FieldRef<"POSQuotation", 'String'>
    readonly tenantId: FieldRef<"POSQuotation", 'String'>
    readonly createdById: FieldRef<"POSQuotation", 'String'>
    readonly createdAt: FieldRef<"POSQuotation", 'DateTime'>
    readonly updatedAt: FieldRef<"POSQuotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * POSQuotation findUnique
   */
  export type POSQuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotation to fetch.
     */
    where: POSQuotationWhereUniqueInput
  }

  /**
   * POSQuotation findUniqueOrThrow
   */
  export type POSQuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotation to fetch.
     */
    where: POSQuotationWhereUniqueInput
  }

  /**
   * POSQuotation findFirst
   */
  export type POSQuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotation to fetch.
     */
    where?: POSQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSQuotations to fetch.
     */
    orderBy?: POSQuotationOrderByWithRelationInput | POSQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSQuotations.
     */
    cursor?: POSQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSQuotations.
     */
    distinct?: POSQuotationScalarFieldEnum | POSQuotationScalarFieldEnum[]
  }

  /**
   * POSQuotation findFirstOrThrow
   */
  export type POSQuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotation to fetch.
     */
    where?: POSQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSQuotations to fetch.
     */
    orderBy?: POSQuotationOrderByWithRelationInput | POSQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSQuotations.
     */
    cursor?: POSQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSQuotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSQuotations.
     */
    distinct?: POSQuotationScalarFieldEnum | POSQuotationScalarFieldEnum[]
  }

  /**
   * POSQuotation findMany
   */
  export type POSQuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotations to fetch.
     */
    where?: POSQuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSQuotations to fetch.
     */
    orderBy?: POSQuotationOrderByWithRelationInput | POSQuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSQuotations.
     */
    cursor?: POSQuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSQuotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSQuotations.
     */
    skip?: number
    distinct?: POSQuotationScalarFieldEnum | POSQuotationScalarFieldEnum[]
  }

  /**
   * POSQuotation create
   */
  export type POSQuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * The data needed to create a POSQuotation.
     */
    data: XOR<POSQuotationCreateInput, POSQuotationUncheckedCreateInput>
  }

  /**
   * POSQuotation createMany
   */
  export type POSQuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSQuotations.
     */
    data: POSQuotationCreateManyInput | POSQuotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POSQuotation createManyAndReturn
   */
  export type POSQuotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * The data used to create many POSQuotations.
     */
    data: POSQuotationCreateManyInput | POSQuotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSQuotation update
   */
  export type POSQuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * The data needed to update a POSQuotation.
     */
    data: XOR<POSQuotationUpdateInput, POSQuotationUncheckedUpdateInput>
    /**
     * Choose, which POSQuotation to update.
     */
    where: POSQuotationWhereUniqueInput
  }

  /**
   * POSQuotation updateMany
   */
  export type POSQuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSQuotations.
     */
    data: XOR<POSQuotationUpdateManyMutationInput, POSQuotationUncheckedUpdateManyInput>
    /**
     * Filter which POSQuotations to update
     */
    where?: POSQuotationWhereInput
    /**
     * Limit how many POSQuotations to update.
     */
    limit?: number
  }

  /**
   * POSQuotation updateManyAndReturn
   */
  export type POSQuotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * The data used to update POSQuotations.
     */
    data: XOR<POSQuotationUpdateManyMutationInput, POSQuotationUncheckedUpdateManyInput>
    /**
     * Filter which POSQuotations to update
     */
    where?: POSQuotationWhereInput
    /**
     * Limit how many POSQuotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSQuotation upsert
   */
  export type POSQuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * The filter to search for the POSQuotation to update in case it exists.
     */
    where: POSQuotationWhereUniqueInput
    /**
     * In case the POSQuotation found by the `where` argument doesn't exist, create a new POSQuotation with this data.
     */
    create: XOR<POSQuotationCreateInput, POSQuotationUncheckedCreateInput>
    /**
     * In case the POSQuotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSQuotationUpdateInput, POSQuotationUncheckedUpdateInput>
  }

  /**
   * POSQuotation delete
   */
  export type POSQuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
    /**
     * Filter which POSQuotation to delete.
     */
    where: POSQuotationWhereUniqueInput
  }

  /**
   * POSQuotation deleteMany
   */
  export type POSQuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSQuotations to delete
     */
    where?: POSQuotationWhereInput
    /**
     * Limit how many POSQuotations to delete.
     */
    limit?: number
  }

  /**
   * POSQuotation.customer
   */
  export type POSQuotation$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * POSQuotation.items
   */
  export type POSQuotation$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    where?: POSQuotationItemWhereInput
    orderBy?: POSQuotationItemOrderByWithRelationInput | POSQuotationItemOrderByWithRelationInput[]
    cursor?: POSQuotationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POSQuotationItemScalarFieldEnum | POSQuotationItemScalarFieldEnum[]
  }

  /**
   * POSQuotation.convertedToSale
   */
  export type POSQuotation$convertedToSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSSale
     */
    select?: POSSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSSale
     */
    omit?: POSSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSSaleInclude<ExtArgs> | null
    where?: POSSaleWhereInput
  }

  /**
   * POSQuotation without action
   */
  export type POSQuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotation
     */
    select?: POSQuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotation
     */
    omit?: POSQuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationInclude<ExtArgs> | null
  }


  /**
   * Model POSQuotationItem
   */

  export type AggregatePOSQuotationItem = {
    _count: POSQuotationItemCountAggregateOutputType | null
    _avg: POSQuotationItemAvgAggregateOutputType | null
    _sum: POSQuotationItemSumAggregateOutputType | null
    _min: POSQuotationItemMinAggregateOutputType | null
    _max: POSQuotationItemMaxAggregateOutputType | null
  }

  export type POSQuotationItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
  }

  export type POSQuotationItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
  }

  export type POSQuotationItemMinAggregateOutputType = {
    id: string | null
    quotationId: string | null
    partId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
  }

  export type POSQuotationItemMaxAggregateOutputType = {
    id: string | null
    quotationId: string | null
    partId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
  }

  export type POSQuotationItemCountAggregateOutputType = {
    id: number
    quotationId: number
    partId: number
    quantity: number
    unitPrice: number
    discount: number
    _all: number
  }


  export type POSQuotationItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discount?: true
  }

  export type POSQuotationItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discount?: true
  }

  export type POSQuotationItemMinAggregateInputType = {
    id?: true
    quotationId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    discount?: true
  }

  export type POSQuotationItemMaxAggregateInputType = {
    id?: true
    quotationId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    discount?: true
  }

  export type POSQuotationItemCountAggregateInputType = {
    id?: true
    quotationId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    _all?: true
  }

  export type POSQuotationItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSQuotationItem to aggregate.
     */
    where?: POSQuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSQuotationItems to fetch.
     */
    orderBy?: POSQuotationItemOrderByWithRelationInput | POSQuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POSQuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSQuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSQuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POSQuotationItems
    **/
    _count?: true | POSQuotationItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POSQuotationItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POSQuotationItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POSQuotationItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POSQuotationItemMaxAggregateInputType
  }

  export type GetPOSQuotationItemAggregateType<T extends POSQuotationItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePOSQuotationItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOSQuotationItem[P]>
      : GetScalarType<T[P], AggregatePOSQuotationItem[P]>
  }




  export type POSQuotationItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POSQuotationItemWhereInput
    orderBy?: POSQuotationItemOrderByWithAggregationInput | POSQuotationItemOrderByWithAggregationInput[]
    by: POSQuotationItemScalarFieldEnum[] | POSQuotationItemScalarFieldEnum
    having?: POSQuotationItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POSQuotationItemCountAggregateInputType | true
    _avg?: POSQuotationItemAvgAggregateInputType
    _sum?: POSQuotationItemSumAggregateInputType
    _min?: POSQuotationItemMinAggregateInputType
    _max?: POSQuotationItemMaxAggregateInputType
  }

  export type POSQuotationItemGroupByOutputType = {
    id: string
    quotationId: string
    partId: string
    quantity: number
    unitPrice: Decimal
    discount: Decimal
    _count: POSQuotationItemCountAggregateOutputType | null
    _avg: POSQuotationItemAvgAggregateOutputType | null
    _sum: POSQuotationItemSumAggregateOutputType | null
    _min: POSQuotationItemMinAggregateOutputType | null
    _max: POSQuotationItemMaxAggregateOutputType | null
  }

  type GetPOSQuotationItemGroupByPayload<T extends POSQuotationItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POSQuotationItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POSQuotationItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POSQuotationItemGroupByOutputType[P]>
            : GetScalarType<T[P], POSQuotationItemGroupByOutputType[P]>
        }
      >
    >


  export type POSQuotationItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    quotation?: boolean | POSQuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSQuotationItem"]>

  export type POSQuotationItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    quotation?: boolean | POSQuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSQuotationItem"]>

  export type POSQuotationItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quotationId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    part?: boolean | PartDefaultArgs<ExtArgs>
    quotation?: boolean | POSQuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOSQuotationItem"]>

  export type POSQuotationItemSelectScalar = {
    id?: boolean
    quotationId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
  }

  export type POSQuotationItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quotationId" | "partId" | "quantity" | "unitPrice" | "discount", ExtArgs["result"]["pOSQuotationItem"]>
  export type POSQuotationItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    quotation?: boolean | POSQuotationDefaultArgs<ExtArgs>
  }
  export type POSQuotationItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    quotation?: boolean | POSQuotationDefaultArgs<ExtArgs>
  }
  export type POSQuotationItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    part?: boolean | PartDefaultArgs<ExtArgs>
    quotation?: boolean | POSQuotationDefaultArgs<ExtArgs>
  }

  export type $POSQuotationItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POSQuotationItem"
    objects: {
      part: Prisma.$PartPayload<ExtArgs>
      quotation: Prisma.$POSQuotationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quotationId: string
      partId: string
      quantity: number
      unitPrice: Prisma.Decimal
      discount: Prisma.Decimal
    }, ExtArgs["result"]["pOSQuotationItem"]>
    composites: {}
  }

  type POSQuotationItemGetPayload<S extends boolean | null | undefined | POSQuotationItemDefaultArgs> = $Result.GetResult<Prisma.$POSQuotationItemPayload, S>

  type POSQuotationItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POSQuotationItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POSQuotationItemCountAggregateInputType | true
    }

  export interface POSQuotationItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POSQuotationItem'], meta: { name: 'POSQuotationItem' } }
    /**
     * Find zero or one POSQuotationItem that matches the filter.
     * @param {POSQuotationItemFindUniqueArgs} args - Arguments to find a POSQuotationItem
     * @example
     * // Get one POSQuotationItem
     * const pOSQuotationItem = await prisma.pOSQuotationItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POSQuotationItemFindUniqueArgs>(args: SelectSubset<T, POSQuotationItemFindUniqueArgs<ExtArgs>>): Prisma__POSQuotationItemClient<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one POSQuotationItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POSQuotationItemFindUniqueOrThrowArgs} args - Arguments to find a POSQuotationItem
     * @example
     * // Get one POSQuotationItem
     * const pOSQuotationItem = await prisma.pOSQuotationItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POSQuotationItemFindUniqueOrThrowArgs>(args: SelectSubset<T, POSQuotationItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POSQuotationItemClient<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSQuotationItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationItemFindFirstArgs} args - Arguments to find a POSQuotationItem
     * @example
     * // Get one POSQuotationItem
     * const pOSQuotationItem = await prisma.pOSQuotationItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POSQuotationItemFindFirstArgs>(args?: SelectSubset<T, POSQuotationItemFindFirstArgs<ExtArgs>>): Prisma__POSQuotationItemClient<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first POSQuotationItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationItemFindFirstOrThrowArgs} args - Arguments to find a POSQuotationItem
     * @example
     * // Get one POSQuotationItem
     * const pOSQuotationItem = await prisma.pOSQuotationItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POSQuotationItemFindFirstOrThrowArgs>(args?: SelectSubset<T, POSQuotationItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__POSQuotationItemClient<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more POSQuotationItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POSQuotationItems
     * const pOSQuotationItems = await prisma.pOSQuotationItem.findMany()
     * 
     * // Get first 10 POSQuotationItems
     * const pOSQuotationItems = await prisma.pOSQuotationItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pOSQuotationItemWithIdOnly = await prisma.pOSQuotationItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends POSQuotationItemFindManyArgs>(args?: SelectSubset<T, POSQuotationItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a POSQuotationItem.
     * @param {POSQuotationItemCreateArgs} args - Arguments to create a POSQuotationItem.
     * @example
     * // Create one POSQuotationItem
     * const POSQuotationItem = await prisma.pOSQuotationItem.create({
     *   data: {
     *     // ... data to create a POSQuotationItem
     *   }
     * })
     * 
     */
    create<T extends POSQuotationItemCreateArgs>(args: SelectSubset<T, POSQuotationItemCreateArgs<ExtArgs>>): Prisma__POSQuotationItemClient<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many POSQuotationItems.
     * @param {POSQuotationItemCreateManyArgs} args - Arguments to create many POSQuotationItems.
     * @example
     * // Create many POSQuotationItems
     * const pOSQuotationItem = await prisma.pOSQuotationItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POSQuotationItemCreateManyArgs>(args?: SelectSubset<T, POSQuotationItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POSQuotationItems and returns the data saved in the database.
     * @param {POSQuotationItemCreateManyAndReturnArgs} args - Arguments to create many POSQuotationItems.
     * @example
     * // Create many POSQuotationItems
     * const pOSQuotationItem = await prisma.pOSQuotationItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POSQuotationItems and only return the `id`
     * const pOSQuotationItemWithIdOnly = await prisma.pOSQuotationItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POSQuotationItemCreateManyAndReturnArgs>(args?: SelectSubset<T, POSQuotationItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a POSQuotationItem.
     * @param {POSQuotationItemDeleteArgs} args - Arguments to delete one POSQuotationItem.
     * @example
     * // Delete one POSQuotationItem
     * const POSQuotationItem = await prisma.pOSQuotationItem.delete({
     *   where: {
     *     // ... filter to delete one POSQuotationItem
     *   }
     * })
     * 
     */
    delete<T extends POSQuotationItemDeleteArgs>(args: SelectSubset<T, POSQuotationItemDeleteArgs<ExtArgs>>): Prisma__POSQuotationItemClient<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one POSQuotationItem.
     * @param {POSQuotationItemUpdateArgs} args - Arguments to update one POSQuotationItem.
     * @example
     * // Update one POSQuotationItem
     * const pOSQuotationItem = await prisma.pOSQuotationItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POSQuotationItemUpdateArgs>(args: SelectSubset<T, POSQuotationItemUpdateArgs<ExtArgs>>): Prisma__POSQuotationItemClient<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more POSQuotationItems.
     * @param {POSQuotationItemDeleteManyArgs} args - Arguments to filter POSQuotationItems to delete.
     * @example
     * // Delete a few POSQuotationItems
     * const { count } = await prisma.pOSQuotationItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POSQuotationItemDeleteManyArgs>(args?: SelectSubset<T, POSQuotationItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSQuotationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POSQuotationItems
     * const pOSQuotationItem = await prisma.pOSQuotationItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POSQuotationItemUpdateManyArgs>(args: SelectSubset<T, POSQuotationItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POSQuotationItems and returns the data updated in the database.
     * @param {POSQuotationItemUpdateManyAndReturnArgs} args - Arguments to update many POSQuotationItems.
     * @example
     * // Update many POSQuotationItems
     * const pOSQuotationItem = await prisma.pOSQuotationItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more POSQuotationItems and only return the `id`
     * const pOSQuotationItemWithIdOnly = await prisma.pOSQuotationItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends POSQuotationItemUpdateManyAndReturnArgs>(args: SelectSubset<T, POSQuotationItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one POSQuotationItem.
     * @param {POSQuotationItemUpsertArgs} args - Arguments to update or create a POSQuotationItem.
     * @example
     * // Update or create a POSQuotationItem
     * const pOSQuotationItem = await prisma.pOSQuotationItem.upsert({
     *   create: {
     *     // ... data to create a POSQuotationItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POSQuotationItem we want to update
     *   }
     * })
     */
    upsert<T extends POSQuotationItemUpsertArgs>(args: SelectSubset<T, POSQuotationItemUpsertArgs<ExtArgs>>): Prisma__POSQuotationItemClient<$Result.GetResult<Prisma.$POSQuotationItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of POSQuotationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationItemCountArgs} args - Arguments to filter POSQuotationItems to count.
     * @example
     * // Count the number of POSQuotationItems
     * const count = await prisma.pOSQuotationItem.count({
     *   where: {
     *     // ... the filter for the POSQuotationItems we want to count
     *   }
     * })
    **/
    count<T extends POSQuotationItemCountArgs>(
      args?: Subset<T, POSQuotationItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POSQuotationItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POSQuotationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POSQuotationItemAggregateArgs>(args: Subset<T, POSQuotationItemAggregateArgs>): Prisma.PrismaPromise<GetPOSQuotationItemAggregateType<T>>

    /**
     * Group by POSQuotationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POSQuotationItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POSQuotationItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POSQuotationItemGroupByArgs['orderBy'] }
        : { orderBy?: POSQuotationItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POSQuotationItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOSQuotationItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POSQuotationItem model
   */
  readonly fields: POSQuotationItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POSQuotationItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POSQuotationItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    part<T extends PartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartDefaultArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quotation<T extends POSQuotationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, POSQuotationDefaultArgs<ExtArgs>>): Prisma__POSQuotationClient<$Result.GetResult<Prisma.$POSQuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POSQuotationItem model
   */
  interface POSQuotationItemFieldRefs {
    readonly id: FieldRef<"POSQuotationItem", 'String'>
    readonly quotationId: FieldRef<"POSQuotationItem", 'String'>
    readonly partId: FieldRef<"POSQuotationItem", 'String'>
    readonly quantity: FieldRef<"POSQuotationItem", 'Int'>
    readonly unitPrice: FieldRef<"POSQuotationItem", 'Decimal'>
    readonly discount: FieldRef<"POSQuotationItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * POSQuotationItem findUnique
   */
  export type POSQuotationItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotationItem to fetch.
     */
    where: POSQuotationItemWhereUniqueInput
  }

  /**
   * POSQuotationItem findUniqueOrThrow
   */
  export type POSQuotationItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotationItem to fetch.
     */
    where: POSQuotationItemWhereUniqueInput
  }

  /**
   * POSQuotationItem findFirst
   */
  export type POSQuotationItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotationItem to fetch.
     */
    where?: POSQuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSQuotationItems to fetch.
     */
    orderBy?: POSQuotationItemOrderByWithRelationInput | POSQuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSQuotationItems.
     */
    cursor?: POSQuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSQuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSQuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSQuotationItems.
     */
    distinct?: POSQuotationItemScalarFieldEnum | POSQuotationItemScalarFieldEnum[]
  }

  /**
   * POSQuotationItem findFirstOrThrow
   */
  export type POSQuotationItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotationItem to fetch.
     */
    where?: POSQuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSQuotationItems to fetch.
     */
    orderBy?: POSQuotationItemOrderByWithRelationInput | POSQuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POSQuotationItems.
     */
    cursor?: POSQuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSQuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSQuotationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POSQuotationItems.
     */
    distinct?: POSQuotationItemScalarFieldEnum | POSQuotationItemScalarFieldEnum[]
  }

  /**
   * POSQuotationItem findMany
   */
  export type POSQuotationItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * Filter, which POSQuotationItems to fetch.
     */
    where?: POSQuotationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POSQuotationItems to fetch.
     */
    orderBy?: POSQuotationItemOrderByWithRelationInput | POSQuotationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POSQuotationItems.
     */
    cursor?: POSQuotationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POSQuotationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POSQuotationItems.
     */
    skip?: number
    distinct?: POSQuotationItemScalarFieldEnum | POSQuotationItemScalarFieldEnum[]
  }

  /**
   * POSQuotationItem create
   */
  export type POSQuotationItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * The data needed to create a POSQuotationItem.
     */
    data: XOR<POSQuotationItemCreateInput, POSQuotationItemUncheckedCreateInput>
  }

  /**
   * POSQuotationItem createMany
   */
  export type POSQuotationItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POSQuotationItems.
     */
    data: POSQuotationItemCreateManyInput | POSQuotationItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POSQuotationItem createManyAndReturn
   */
  export type POSQuotationItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * The data used to create many POSQuotationItems.
     */
    data: POSQuotationItemCreateManyInput | POSQuotationItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSQuotationItem update
   */
  export type POSQuotationItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * The data needed to update a POSQuotationItem.
     */
    data: XOR<POSQuotationItemUpdateInput, POSQuotationItemUncheckedUpdateInput>
    /**
     * Choose, which POSQuotationItem to update.
     */
    where: POSQuotationItemWhereUniqueInput
  }

  /**
   * POSQuotationItem updateMany
   */
  export type POSQuotationItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POSQuotationItems.
     */
    data: XOR<POSQuotationItemUpdateManyMutationInput, POSQuotationItemUncheckedUpdateManyInput>
    /**
     * Filter which POSQuotationItems to update
     */
    where?: POSQuotationItemWhereInput
    /**
     * Limit how many POSQuotationItems to update.
     */
    limit?: number
  }

  /**
   * POSQuotationItem updateManyAndReturn
   */
  export type POSQuotationItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * The data used to update POSQuotationItems.
     */
    data: XOR<POSQuotationItemUpdateManyMutationInput, POSQuotationItemUncheckedUpdateManyInput>
    /**
     * Filter which POSQuotationItems to update
     */
    where?: POSQuotationItemWhereInput
    /**
     * Limit how many POSQuotationItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * POSQuotationItem upsert
   */
  export type POSQuotationItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * The filter to search for the POSQuotationItem to update in case it exists.
     */
    where: POSQuotationItemWhereUniqueInput
    /**
     * In case the POSQuotationItem found by the `where` argument doesn't exist, create a new POSQuotationItem with this data.
     */
    create: XOR<POSQuotationItemCreateInput, POSQuotationItemUncheckedCreateInput>
    /**
     * In case the POSQuotationItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POSQuotationItemUpdateInput, POSQuotationItemUncheckedUpdateInput>
  }

  /**
   * POSQuotationItem delete
   */
  export type POSQuotationItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
    /**
     * Filter which POSQuotationItem to delete.
     */
    where: POSQuotationItemWhereUniqueInput
  }

  /**
   * POSQuotationItem deleteMany
   */
  export type POSQuotationItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POSQuotationItems to delete
     */
    where?: POSQuotationItemWhereInput
    /**
     * Limit how many POSQuotationItems to delete.
     */
    limit?: number
  }

  /**
   * POSQuotationItem without action
   */
  export type POSQuotationItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POSQuotationItem
     */
    select?: POSQuotationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POSQuotationItem
     */
    omit?: POSQuotationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POSQuotationItemInclude<ExtArgs> | null
  }


  /**
   * Model CreditNote
   */

  export type AggregateCreditNote = {
    _count: CreditNoteCountAggregateOutputType | null
    _avg: CreditNoteAvgAggregateOutputType | null
    _sum: CreditNoteSumAggregateOutputType | null
    _min: CreditNoteMinAggregateOutputType | null
    _max: CreditNoteMaxAggregateOutputType | null
  }

  export type CreditNoteAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type CreditNoteSumAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type CreditNoteMinAggregateOutputType = {
    id: string | null
    creditNoteNumber: string | null
    posSaleId: string | null
    customerId: string | null
    reason: string | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    status: $Enums.CreditNoteStatus | null
    refundMethod: $Enums.PaymentMethod | null
    refundReference: string | null
    notes: string | null
    processedAt: Date | null
    processedById: string | null
    tenantId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditNoteMaxAggregateOutputType = {
    id: string | null
    creditNoteNumber: string | null
    posSaleId: string | null
    customerId: string | null
    reason: string | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    status: $Enums.CreditNoteStatus | null
    refundMethod: $Enums.PaymentMethod | null
    refundReference: string | null
    notes: string | null
    processedAt: Date | null
    processedById: string | null
    tenantId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditNoteCountAggregateOutputType = {
    id: number
    creditNoteNumber: number
    posSaleId: number
    customerId: number
    reason: number
    subtotal: number
    taxRate: number
    taxAmount: number
    total: number
    status: number
    refundMethod: number
    refundReference: number
    notes: number
    processedAt: number
    processedById: number
    tenantId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreditNoteAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
  }

  export type CreditNoteSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
  }

  export type CreditNoteMinAggregateInputType = {
    id?: true
    creditNoteNumber?: true
    posSaleId?: true
    customerId?: true
    reason?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    status?: true
    refundMethod?: true
    refundReference?: true
    notes?: true
    processedAt?: true
    processedById?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditNoteMaxAggregateInputType = {
    id?: true
    creditNoteNumber?: true
    posSaleId?: true
    customerId?: true
    reason?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    status?: true
    refundMethod?: true
    refundReference?: true
    notes?: true
    processedAt?: true
    processedById?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditNoteCountAggregateInputType = {
    id?: true
    creditNoteNumber?: true
    posSaleId?: true
    customerId?: true
    reason?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    status?: true
    refundMethod?: true
    refundReference?: true
    notes?: true
    processedAt?: true
    processedById?: true
    tenantId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreditNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditNote to aggregate.
     */
    where?: CreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNotes to fetch.
     */
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditNotes
    **/
    _count?: true | CreditNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditNoteMaxAggregateInputType
  }

  export type GetCreditNoteAggregateType<T extends CreditNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditNote[P]>
      : GetScalarType<T[P], AggregateCreditNote[P]>
  }




  export type CreditNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteWhereInput
    orderBy?: CreditNoteOrderByWithAggregationInput | CreditNoteOrderByWithAggregationInput[]
    by: CreditNoteScalarFieldEnum[] | CreditNoteScalarFieldEnum
    having?: CreditNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditNoteCountAggregateInputType | true
    _avg?: CreditNoteAvgAggregateInputType
    _sum?: CreditNoteSumAggregateInputType
    _min?: CreditNoteMinAggregateInputType
    _max?: CreditNoteMaxAggregateInputType
  }

  export type CreditNoteGroupByOutputType = {
    id: string
    creditNoteNumber: string
    posSaleId: string
    customerId: string | null
    reason: string
    subtotal: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    total: Decimal
    status: $Enums.CreditNoteStatus
    refundMethod: $Enums.PaymentMethod | null
    refundReference: string | null
    notes: string | null
    processedAt: Date | null
    processedById: string | null
    tenantId: string
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: CreditNoteCountAggregateOutputType | null
    _avg: CreditNoteAvgAggregateOutputType | null
    _sum: CreditNoteSumAggregateOutputType | null
    _min: CreditNoteMinAggregateOutputType | null
    _max: CreditNoteMaxAggregateOutputType | null
  }

  type GetCreditNoteGroupByPayload<T extends CreditNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditNoteGroupByOutputType[P]>
            : GetScalarType<T[P], CreditNoteGroupByOutputType[P]>
        }
      >
    >


  export type CreditNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditNoteNumber?: boolean
    posSaleId?: boolean
    customerId?: boolean
    reason?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    status?: boolean
    refundMethod?: boolean
    refundReference?: boolean
    notes?: boolean
    processedAt?: boolean
    processedById?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    processedBy?: boolean | CreditNote$processedByArgs<ExtArgs>
    customer?: boolean | CreditNote$customerArgs<ExtArgs>
    items?: boolean | CreditNote$itemsArgs<ExtArgs>
    posSale?: boolean | POSSaleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | CreditNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNote"]>

  export type CreditNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditNoteNumber?: boolean
    posSaleId?: boolean
    customerId?: boolean
    reason?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    status?: boolean
    refundMethod?: boolean
    refundReference?: boolean
    notes?: boolean
    processedAt?: boolean
    processedById?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    processedBy?: boolean | CreditNote$processedByArgs<ExtArgs>
    customer?: boolean | CreditNote$customerArgs<ExtArgs>
    posSale?: boolean | POSSaleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNote"]>

  export type CreditNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditNoteNumber?: boolean
    posSaleId?: boolean
    customerId?: boolean
    reason?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    status?: boolean
    refundMethod?: boolean
    refundReference?: boolean
    notes?: boolean
    processedAt?: boolean
    processedById?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    processedBy?: boolean | CreditNote$processedByArgs<ExtArgs>
    customer?: boolean | CreditNote$customerArgs<ExtArgs>
    posSale?: boolean | POSSaleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNote"]>

  export type CreditNoteSelectScalar = {
    id?: boolean
    creditNoteNumber?: boolean
    posSaleId?: boolean
    customerId?: boolean
    reason?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    status?: boolean
    refundMethod?: boolean
    refundReference?: boolean
    notes?: boolean
    processedAt?: boolean
    processedById?: boolean
    tenantId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreditNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditNoteNumber" | "posSaleId" | "customerId" | "reason" | "subtotal" | "taxRate" | "taxAmount" | "total" | "status" | "refundMethod" | "refundReference" | "notes" | "processedAt" | "processedById" | "tenantId" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["creditNote"]>
  export type CreditNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    processedBy?: boolean | CreditNote$processedByArgs<ExtArgs>
    customer?: boolean | CreditNote$customerArgs<ExtArgs>
    items?: boolean | CreditNote$itemsArgs<ExtArgs>
    posSale?: boolean | POSSaleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | CreditNoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreditNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    processedBy?: boolean | CreditNote$processedByArgs<ExtArgs>
    customer?: boolean | CreditNote$customerArgs<ExtArgs>
    posSale?: boolean | POSSaleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CreditNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    processedBy?: boolean | CreditNote$processedByArgs<ExtArgs>
    customer?: boolean | CreditNote$customerArgs<ExtArgs>
    posSale?: boolean | POSSaleDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CreditNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditNote"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      processedBy: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      items: Prisma.$CreditNoteItemPayload<ExtArgs>[]
      posSale: Prisma.$POSSalePayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditNoteNumber: string
      posSaleId: string
      customerId: string | null
      reason: string
      subtotal: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
      status: $Enums.CreditNoteStatus
      refundMethod: $Enums.PaymentMethod | null
      refundReference: string | null
      notes: string | null
      processedAt: Date | null
      processedById: string | null
      tenantId: string
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creditNote"]>
    composites: {}
  }

  type CreditNoteGetPayload<S extends boolean | null | undefined | CreditNoteDefaultArgs> = $Result.GetResult<Prisma.$CreditNotePayload, S>

  type CreditNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditNoteCountAggregateInputType | true
    }

  export interface CreditNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditNote'], meta: { name: 'CreditNote' } }
    /**
     * Find zero or one CreditNote that matches the filter.
     * @param {CreditNoteFindUniqueArgs} args - Arguments to find a CreditNote
     * @example
     * // Get one CreditNote
     * const creditNote = await prisma.creditNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditNoteFindUniqueArgs>(args: SelectSubset<T, CreditNoteFindUniqueArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditNoteFindUniqueOrThrowArgs} args - Arguments to find a CreditNote
     * @example
     * // Get one CreditNote
     * const creditNote = await prisma.creditNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteFindFirstArgs} args - Arguments to find a CreditNote
     * @example
     * // Get one CreditNote
     * const creditNote = await prisma.creditNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditNoteFindFirstArgs>(args?: SelectSubset<T, CreditNoteFindFirstArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteFindFirstOrThrowArgs} args - Arguments to find a CreditNote
     * @example
     * // Get one CreditNote
     * const creditNote = await prisma.creditNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditNotes
     * const creditNotes = await prisma.creditNote.findMany()
     * 
     * // Get first 10 CreditNotes
     * const creditNotes = await prisma.creditNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditNoteWithIdOnly = await prisma.creditNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditNoteFindManyArgs>(args?: SelectSubset<T, CreditNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditNote.
     * @param {CreditNoteCreateArgs} args - Arguments to create a CreditNote.
     * @example
     * // Create one CreditNote
     * const CreditNote = await prisma.creditNote.create({
     *   data: {
     *     // ... data to create a CreditNote
     *   }
     * })
     * 
     */
    create<T extends CreditNoteCreateArgs>(args: SelectSubset<T, CreditNoteCreateArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditNotes.
     * @param {CreditNoteCreateManyArgs} args - Arguments to create many CreditNotes.
     * @example
     * // Create many CreditNotes
     * const creditNote = await prisma.creditNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditNoteCreateManyArgs>(args?: SelectSubset<T, CreditNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditNotes and returns the data saved in the database.
     * @param {CreditNoteCreateManyAndReturnArgs} args - Arguments to create many CreditNotes.
     * @example
     * // Create many CreditNotes
     * const creditNote = await prisma.creditNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditNotes and only return the `id`
     * const creditNoteWithIdOnly = await prisma.creditNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditNote.
     * @param {CreditNoteDeleteArgs} args - Arguments to delete one CreditNote.
     * @example
     * // Delete one CreditNote
     * const CreditNote = await prisma.creditNote.delete({
     *   where: {
     *     // ... filter to delete one CreditNote
     *   }
     * })
     * 
     */
    delete<T extends CreditNoteDeleteArgs>(args: SelectSubset<T, CreditNoteDeleteArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditNote.
     * @param {CreditNoteUpdateArgs} args - Arguments to update one CreditNote.
     * @example
     * // Update one CreditNote
     * const creditNote = await prisma.creditNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditNoteUpdateArgs>(args: SelectSubset<T, CreditNoteUpdateArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditNotes.
     * @param {CreditNoteDeleteManyArgs} args - Arguments to filter CreditNotes to delete.
     * @example
     * // Delete a few CreditNotes
     * const { count } = await prisma.creditNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditNoteDeleteManyArgs>(args?: SelectSubset<T, CreditNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditNotes
     * const creditNote = await prisma.creditNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditNoteUpdateManyArgs>(args: SelectSubset<T, CreditNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditNotes and returns the data updated in the database.
     * @param {CreditNoteUpdateManyAndReturnArgs} args - Arguments to update many CreditNotes.
     * @example
     * // Update many CreditNotes
     * const creditNote = await prisma.creditNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditNotes and only return the `id`
     * const creditNoteWithIdOnly = await prisma.creditNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditNote.
     * @param {CreditNoteUpsertArgs} args - Arguments to update or create a CreditNote.
     * @example
     * // Update or create a CreditNote
     * const creditNote = await prisma.creditNote.upsert({
     *   create: {
     *     // ... data to create a CreditNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditNote we want to update
     *   }
     * })
     */
    upsert<T extends CreditNoteUpsertArgs>(args: SelectSubset<T, CreditNoteUpsertArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteCountArgs} args - Arguments to filter CreditNotes to count.
     * @example
     * // Count the number of CreditNotes
     * const count = await prisma.creditNote.count({
     *   where: {
     *     // ... the filter for the CreditNotes we want to count
     *   }
     * })
    **/
    count<T extends CreditNoteCountArgs>(
      args?: Subset<T, CreditNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditNoteAggregateArgs>(args: Subset<T, CreditNoteAggregateArgs>): Prisma.PrismaPromise<GetCreditNoteAggregateType<T>>

    /**
     * Group by CreditNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditNoteGroupByArgs['orderBy'] }
        : { orderBy?: CreditNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditNote model
   */
  readonly fields: CreditNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    processedBy<T extends CreditNote$processedByArgs<ExtArgs> = {}>(args?: Subset<T, CreditNote$processedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends CreditNote$customerArgs<ExtArgs> = {}>(args?: Subset<T, CreditNote$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends CreditNote$itemsArgs<ExtArgs> = {}>(args?: Subset<T, CreditNote$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posSale<T extends POSSaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, POSSaleDefaultArgs<ExtArgs>>): Prisma__POSSaleClient<$Result.GetResult<Prisma.$POSSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditNote model
   */
  interface CreditNoteFieldRefs {
    readonly id: FieldRef<"CreditNote", 'String'>
    readonly creditNoteNumber: FieldRef<"CreditNote", 'String'>
    readonly posSaleId: FieldRef<"CreditNote", 'String'>
    readonly customerId: FieldRef<"CreditNote", 'String'>
    readonly reason: FieldRef<"CreditNote", 'String'>
    readonly subtotal: FieldRef<"CreditNote", 'Decimal'>
    readonly taxRate: FieldRef<"CreditNote", 'Decimal'>
    readonly taxAmount: FieldRef<"CreditNote", 'Decimal'>
    readonly total: FieldRef<"CreditNote", 'Decimal'>
    readonly status: FieldRef<"CreditNote", 'CreditNoteStatus'>
    readonly refundMethod: FieldRef<"CreditNote", 'PaymentMethod'>
    readonly refundReference: FieldRef<"CreditNote", 'String'>
    readonly notes: FieldRef<"CreditNote", 'String'>
    readonly processedAt: FieldRef<"CreditNote", 'DateTime'>
    readonly processedById: FieldRef<"CreditNote", 'String'>
    readonly tenantId: FieldRef<"CreditNote", 'String'>
    readonly createdById: FieldRef<"CreditNote", 'String'>
    readonly createdAt: FieldRef<"CreditNote", 'DateTime'>
    readonly updatedAt: FieldRef<"CreditNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditNote findUnique
   */
  export type CreditNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which CreditNote to fetch.
     */
    where: CreditNoteWhereUniqueInput
  }

  /**
   * CreditNote findUniqueOrThrow
   */
  export type CreditNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which CreditNote to fetch.
     */
    where: CreditNoteWhereUniqueInput
  }

  /**
   * CreditNote findFirst
   */
  export type CreditNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which CreditNote to fetch.
     */
    where?: CreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNotes to fetch.
     */
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditNotes.
     */
    cursor?: CreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditNotes.
     */
    distinct?: CreditNoteScalarFieldEnum | CreditNoteScalarFieldEnum[]
  }

  /**
   * CreditNote findFirstOrThrow
   */
  export type CreditNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which CreditNote to fetch.
     */
    where?: CreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNotes to fetch.
     */
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditNotes.
     */
    cursor?: CreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditNotes.
     */
    distinct?: CreditNoteScalarFieldEnum | CreditNoteScalarFieldEnum[]
  }

  /**
   * CreditNote findMany
   */
  export type CreditNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which CreditNotes to fetch.
     */
    where?: CreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNotes to fetch.
     */
    orderBy?: CreditNoteOrderByWithRelationInput | CreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditNotes.
     */
    cursor?: CreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNotes.
     */
    skip?: number
    distinct?: CreditNoteScalarFieldEnum | CreditNoteScalarFieldEnum[]
  }

  /**
   * CreditNote create
   */
  export type CreditNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditNote.
     */
    data: XOR<CreditNoteCreateInput, CreditNoteUncheckedCreateInput>
  }

  /**
   * CreditNote createMany
   */
  export type CreditNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditNotes.
     */
    data: CreditNoteCreateManyInput | CreditNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditNote createManyAndReturn
   */
  export type CreditNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * The data used to create many CreditNotes.
     */
    data: CreditNoteCreateManyInput | CreditNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditNote update
   */
  export type CreditNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditNote.
     */
    data: XOR<CreditNoteUpdateInput, CreditNoteUncheckedUpdateInput>
    /**
     * Choose, which CreditNote to update.
     */
    where: CreditNoteWhereUniqueInput
  }

  /**
   * CreditNote updateMany
   */
  export type CreditNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditNotes.
     */
    data: XOR<CreditNoteUpdateManyMutationInput, CreditNoteUncheckedUpdateManyInput>
    /**
     * Filter which CreditNotes to update
     */
    where?: CreditNoteWhereInput
    /**
     * Limit how many CreditNotes to update.
     */
    limit?: number
  }

  /**
   * CreditNote updateManyAndReturn
   */
  export type CreditNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * The data used to update CreditNotes.
     */
    data: XOR<CreditNoteUpdateManyMutationInput, CreditNoteUncheckedUpdateManyInput>
    /**
     * Filter which CreditNotes to update
     */
    where?: CreditNoteWhereInput
    /**
     * Limit how many CreditNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditNote upsert
   */
  export type CreditNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditNote to update in case it exists.
     */
    where: CreditNoteWhereUniqueInput
    /**
     * In case the CreditNote found by the `where` argument doesn't exist, create a new CreditNote with this data.
     */
    create: XOR<CreditNoteCreateInput, CreditNoteUncheckedCreateInput>
    /**
     * In case the CreditNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditNoteUpdateInput, CreditNoteUncheckedUpdateInput>
  }

  /**
   * CreditNote delete
   */
  export type CreditNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
    /**
     * Filter which CreditNote to delete.
     */
    where: CreditNoteWhereUniqueInput
  }

  /**
   * CreditNote deleteMany
   */
  export type CreditNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditNotes to delete
     */
    where?: CreditNoteWhereInput
    /**
     * Limit how many CreditNotes to delete.
     */
    limit?: number
  }

  /**
   * CreditNote.processedBy
   */
  export type CreditNote$processedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CreditNote.customer
   */
  export type CreditNote$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * CreditNote.items
   */
  export type CreditNote$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    where?: CreditNoteItemWhereInput
    orderBy?: CreditNoteItemOrderByWithRelationInput | CreditNoteItemOrderByWithRelationInput[]
    cursor?: CreditNoteItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteItemScalarFieldEnum | CreditNoteItemScalarFieldEnum[]
  }

  /**
   * CreditNote without action
   */
  export type CreditNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNote
     */
    select?: CreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNote
     */
    omit?: CreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteInclude<ExtArgs> | null
  }


  /**
   * Model CreditNoteItem
   */

  export type AggregateCreditNoteItem = {
    _count: CreditNoteItemCountAggregateOutputType | null
    _avg: CreditNoteItemAvgAggregateOutputType | null
    _sum: CreditNoteItemSumAggregateOutputType | null
    _min: CreditNoteItemMinAggregateOutputType | null
    _max: CreditNoteItemMaxAggregateOutputType | null
  }

  export type CreditNoteItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
  }

  export type CreditNoteItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
  }

  export type CreditNoteItemMinAggregateOutputType = {
    id: string | null
    creditNoteId: string | null
    partId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    reason: string | null
  }

  export type CreditNoteItemMaxAggregateOutputType = {
    id: string | null
    creditNoteId: string | null
    partId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    reason: string | null
  }

  export type CreditNoteItemCountAggregateOutputType = {
    id: number
    creditNoteId: number
    partId: number
    quantity: number
    unitPrice: number
    reason: number
    _all: number
  }


  export type CreditNoteItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
  }

  export type CreditNoteItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
  }

  export type CreditNoteItemMinAggregateInputType = {
    id?: true
    creditNoteId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    reason?: true
  }

  export type CreditNoteItemMaxAggregateInputType = {
    id?: true
    creditNoteId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    reason?: true
  }

  export type CreditNoteItemCountAggregateInputType = {
    id?: true
    creditNoteId?: true
    partId?: true
    quantity?: true
    unitPrice?: true
    reason?: true
    _all?: true
  }

  export type CreditNoteItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditNoteItem to aggregate.
     */
    where?: CreditNoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteItems to fetch.
     */
    orderBy?: CreditNoteItemOrderByWithRelationInput | CreditNoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditNoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditNoteItems
    **/
    _count?: true | CreditNoteItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditNoteItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditNoteItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditNoteItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditNoteItemMaxAggregateInputType
  }

  export type GetCreditNoteItemAggregateType<T extends CreditNoteItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditNoteItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditNoteItem[P]>
      : GetScalarType<T[P], AggregateCreditNoteItem[P]>
  }




  export type CreditNoteItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteItemWhereInput
    orderBy?: CreditNoteItemOrderByWithAggregationInput | CreditNoteItemOrderByWithAggregationInput[]
    by: CreditNoteItemScalarFieldEnum[] | CreditNoteItemScalarFieldEnum
    having?: CreditNoteItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditNoteItemCountAggregateInputType | true
    _avg?: CreditNoteItemAvgAggregateInputType
    _sum?: CreditNoteItemSumAggregateInputType
    _min?: CreditNoteItemMinAggregateInputType
    _max?: CreditNoteItemMaxAggregateInputType
  }

  export type CreditNoteItemGroupByOutputType = {
    id: string
    creditNoteId: string
    partId: string
    quantity: number
    unitPrice: Decimal
    reason: string | null
    _count: CreditNoteItemCountAggregateOutputType | null
    _avg: CreditNoteItemAvgAggregateOutputType | null
    _sum: CreditNoteItemSumAggregateOutputType | null
    _min: CreditNoteItemMinAggregateOutputType | null
    _max: CreditNoteItemMaxAggregateOutputType | null
  }

  type GetCreditNoteItemGroupByPayload<T extends CreditNoteItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditNoteItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditNoteItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditNoteItemGroupByOutputType[P]>
            : GetScalarType<T[P], CreditNoteItemGroupByOutputType[P]>
        }
      >
    >


  export type CreditNoteItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditNoteId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    reason?: boolean
    creditNote?: boolean | CreditNoteDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteItem"]>

  export type CreditNoteItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditNoteId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    reason?: boolean
    creditNote?: boolean | CreditNoteDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteItem"]>

  export type CreditNoteItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creditNoteId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    reason?: boolean
    creditNote?: boolean | CreditNoteDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteItem"]>

  export type CreditNoteItemSelectScalar = {
    id?: boolean
    creditNoteId?: boolean
    partId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    reason?: boolean
  }

  export type CreditNoteItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creditNoteId" | "partId" | "quantity" | "unitPrice" | "reason", ExtArgs["result"]["creditNoteItem"]>
  export type CreditNoteItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | CreditNoteDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
  }
  export type CreditNoteItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | CreditNoteDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
  }
  export type CreditNoteItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | CreditNoteDefaultArgs<ExtArgs>
    part?: boolean | PartDefaultArgs<ExtArgs>
  }

  export type $CreditNoteItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditNoteItem"
    objects: {
      creditNote: Prisma.$CreditNotePayload<ExtArgs>
      part: Prisma.$PartPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creditNoteId: string
      partId: string
      quantity: number
      unitPrice: Prisma.Decimal
      reason: string | null
    }, ExtArgs["result"]["creditNoteItem"]>
    composites: {}
  }

  type CreditNoteItemGetPayload<S extends boolean | null | undefined | CreditNoteItemDefaultArgs> = $Result.GetResult<Prisma.$CreditNoteItemPayload, S>

  type CreditNoteItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditNoteItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditNoteItemCountAggregateInputType | true
    }

  export interface CreditNoteItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditNoteItem'], meta: { name: 'CreditNoteItem' } }
    /**
     * Find zero or one CreditNoteItem that matches the filter.
     * @param {CreditNoteItemFindUniqueArgs} args - Arguments to find a CreditNoteItem
     * @example
     * // Get one CreditNoteItem
     * const creditNoteItem = await prisma.creditNoteItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditNoteItemFindUniqueArgs>(args: SelectSubset<T, CreditNoteItemFindUniqueArgs<ExtArgs>>): Prisma__CreditNoteItemClient<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditNoteItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditNoteItemFindUniqueOrThrowArgs} args - Arguments to find a CreditNoteItem
     * @example
     * // Get one CreditNoteItem
     * const creditNoteItem = await prisma.creditNoteItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditNoteItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditNoteItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditNoteItemClient<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditNoteItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteItemFindFirstArgs} args - Arguments to find a CreditNoteItem
     * @example
     * // Get one CreditNoteItem
     * const creditNoteItem = await prisma.creditNoteItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditNoteItemFindFirstArgs>(args?: SelectSubset<T, CreditNoteItemFindFirstArgs<ExtArgs>>): Prisma__CreditNoteItemClient<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditNoteItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteItemFindFirstOrThrowArgs} args - Arguments to find a CreditNoteItem
     * @example
     * // Get one CreditNoteItem
     * const creditNoteItem = await prisma.creditNoteItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditNoteItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditNoteItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditNoteItemClient<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditNoteItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditNoteItems
     * const creditNoteItems = await prisma.creditNoteItem.findMany()
     * 
     * // Get first 10 CreditNoteItems
     * const creditNoteItems = await prisma.creditNoteItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditNoteItemWithIdOnly = await prisma.creditNoteItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditNoteItemFindManyArgs>(args?: SelectSubset<T, CreditNoteItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditNoteItem.
     * @param {CreditNoteItemCreateArgs} args - Arguments to create a CreditNoteItem.
     * @example
     * // Create one CreditNoteItem
     * const CreditNoteItem = await prisma.creditNoteItem.create({
     *   data: {
     *     // ... data to create a CreditNoteItem
     *   }
     * })
     * 
     */
    create<T extends CreditNoteItemCreateArgs>(args: SelectSubset<T, CreditNoteItemCreateArgs<ExtArgs>>): Prisma__CreditNoteItemClient<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditNoteItems.
     * @param {CreditNoteItemCreateManyArgs} args - Arguments to create many CreditNoteItems.
     * @example
     * // Create many CreditNoteItems
     * const creditNoteItem = await prisma.creditNoteItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditNoteItemCreateManyArgs>(args?: SelectSubset<T, CreditNoteItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditNoteItems and returns the data saved in the database.
     * @param {CreditNoteItemCreateManyAndReturnArgs} args - Arguments to create many CreditNoteItems.
     * @example
     * // Create many CreditNoteItems
     * const creditNoteItem = await prisma.creditNoteItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditNoteItems and only return the `id`
     * const creditNoteItemWithIdOnly = await prisma.creditNoteItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditNoteItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditNoteItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditNoteItem.
     * @param {CreditNoteItemDeleteArgs} args - Arguments to delete one CreditNoteItem.
     * @example
     * // Delete one CreditNoteItem
     * const CreditNoteItem = await prisma.creditNoteItem.delete({
     *   where: {
     *     // ... filter to delete one CreditNoteItem
     *   }
     * })
     * 
     */
    delete<T extends CreditNoteItemDeleteArgs>(args: SelectSubset<T, CreditNoteItemDeleteArgs<ExtArgs>>): Prisma__CreditNoteItemClient<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditNoteItem.
     * @param {CreditNoteItemUpdateArgs} args - Arguments to update one CreditNoteItem.
     * @example
     * // Update one CreditNoteItem
     * const creditNoteItem = await prisma.creditNoteItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditNoteItemUpdateArgs>(args: SelectSubset<T, CreditNoteItemUpdateArgs<ExtArgs>>): Prisma__CreditNoteItemClient<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditNoteItems.
     * @param {CreditNoteItemDeleteManyArgs} args - Arguments to filter CreditNoteItems to delete.
     * @example
     * // Delete a few CreditNoteItems
     * const { count } = await prisma.creditNoteItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditNoteItemDeleteManyArgs>(args?: SelectSubset<T, CreditNoteItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditNoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditNoteItems
     * const creditNoteItem = await prisma.creditNoteItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditNoteItemUpdateManyArgs>(args: SelectSubset<T, CreditNoteItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditNoteItems and returns the data updated in the database.
     * @param {CreditNoteItemUpdateManyAndReturnArgs} args - Arguments to update many CreditNoteItems.
     * @example
     * // Update many CreditNoteItems
     * const creditNoteItem = await prisma.creditNoteItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditNoteItems and only return the `id`
     * const creditNoteItemWithIdOnly = await prisma.creditNoteItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditNoteItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditNoteItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditNoteItem.
     * @param {CreditNoteItemUpsertArgs} args - Arguments to update or create a CreditNoteItem.
     * @example
     * // Update or create a CreditNoteItem
     * const creditNoteItem = await prisma.creditNoteItem.upsert({
     *   create: {
     *     // ... data to create a CreditNoteItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditNoteItem we want to update
     *   }
     * })
     */
    upsert<T extends CreditNoteItemUpsertArgs>(args: SelectSubset<T, CreditNoteItemUpsertArgs<ExtArgs>>): Prisma__CreditNoteItemClient<$Result.GetResult<Prisma.$CreditNoteItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditNoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteItemCountArgs} args - Arguments to filter CreditNoteItems to count.
     * @example
     * // Count the number of CreditNoteItems
     * const count = await prisma.creditNoteItem.count({
     *   where: {
     *     // ... the filter for the CreditNoteItems we want to count
     *   }
     * })
    **/
    count<T extends CreditNoteItemCountArgs>(
      args?: Subset<T, CreditNoteItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditNoteItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditNoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditNoteItemAggregateArgs>(args: Subset<T, CreditNoteItemAggregateArgs>): Prisma.PrismaPromise<GetCreditNoteItemAggregateType<T>>

    /**
     * Group by CreditNoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditNoteItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditNoteItemGroupByArgs['orderBy'] }
        : { orderBy?: CreditNoteItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditNoteItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditNoteItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditNoteItem model
   */
  readonly fields: CreditNoteItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditNoteItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditNoteItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditNote<T extends CreditNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreditNoteDefaultArgs<ExtArgs>>): Prisma__CreditNoteClient<$Result.GetResult<Prisma.$CreditNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    part<T extends PartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartDefaultArgs<ExtArgs>>): Prisma__PartClient<$Result.GetResult<Prisma.$PartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditNoteItem model
   */
  interface CreditNoteItemFieldRefs {
    readonly id: FieldRef<"CreditNoteItem", 'String'>
    readonly creditNoteId: FieldRef<"CreditNoteItem", 'String'>
    readonly partId: FieldRef<"CreditNoteItem", 'String'>
    readonly quantity: FieldRef<"CreditNoteItem", 'Int'>
    readonly unitPrice: FieldRef<"CreditNoteItem", 'Decimal'>
    readonly reason: FieldRef<"CreditNoteItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreditNoteItem findUnique
   */
  export type CreditNoteItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteItem to fetch.
     */
    where: CreditNoteItemWhereUniqueInput
  }

  /**
   * CreditNoteItem findUniqueOrThrow
   */
  export type CreditNoteItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteItem to fetch.
     */
    where: CreditNoteItemWhereUniqueInput
  }

  /**
   * CreditNoteItem findFirst
   */
  export type CreditNoteItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteItem to fetch.
     */
    where?: CreditNoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteItems to fetch.
     */
    orderBy?: CreditNoteItemOrderByWithRelationInput | CreditNoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditNoteItems.
     */
    cursor?: CreditNoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditNoteItems.
     */
    distinct?: CreditNoteItemScalarFieldEnum | CreditNoteItemScalarFieldEnum[]
  }

  /**
   * CreditNoteItem findFirstOrThrow
   */
  export type CreditNoteItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteItem to fetch.
     */
    where?: CreditNoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteItems to fetch.
     */
    orderBy?: CreditNoteItemOrderByWithRelationInput | CreditNoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditNoteItems.
     */
    cursor?: CreditNoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditNoteItems.
     */
    distinct?: CreditNoteItemScalarFieldEnum | CreditNoteItemScalarFieldEnum[]
  }

  /**
   * CreditNoteItem findMany
   */
  export type CreditNoteItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteItems to fetch.
     */
    where?: CreditNoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteItems to fetch.
     */
    orderBy?: CreditNoteItemOrderByWithRelationInput | CreditNoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditNoteItems.
     */
    cursor?: CreditNoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteItems.
     */
    skip?: number
    distinct?: CreditNoteItemScalarFieldEnum | CreditNoteItemScalarFieldEnum[]
  }

  /**
   * CreditNoteItem create
   */
  export type CreditNoteItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditNoteItem.
     */
    data: XOR<CreditNoteItemCreateInput, CreditNoteItemUncheckedCreateInput>
  }

  /**
   * CreditNoteItem createMany
   */
  export type CreditNoteItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditNoteItems.
     */
    data: CreditNoteItemCreateManyInput | CreditNoteItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditNoteItem createManyAndReturn
   */
  export type CreditNoteItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * The data used to create many CreditNoteItems.
     */
    data: CreditNoteItemCreateManyInput | CreditNoteItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditNoteItem update
   */
  export type CreditNoteItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditNoteItem.
     */
    data: XOR<CreditNoteItemUpdateInput, CreditNoteItemUncheckedUpdateInput>
    /**
     * Choose, which CreditNoteItem to update.
     */
    where: CreditNoteItemWhereUniqueInput
  }

  /**
   * CreditNoteItem updateMany
   */
  export type CreditNoteItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditNoteItems.
     */
    data: XOR<CreditNoteItemUpdateManyMutationInput, CreditNoteItemUncheckedUpdateManyInput>
    /**
     * Filter which CreditNoteItems to update
     */
    where?: CreditNoteItemWhereInput
    /**
     * Limit how many CreditNoteItems to update.
     */
    limit?: number
  }

  /**
   * CreditNoteItem updateManyAndReturn
   */
  export type CreditNoteItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * The data used to update CreditNoteItems.
     */
    data: XOR<CreditNoteItemUpdateManyMutationInput, CreditNoteItemUncheckedUpdateManyInput>
    /**
     * Filter which CreditNoteItems to update
     */
    where?: CreditNoteItemWhereInput
    /**
     * Limit how many CreditNoteItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditNoteItem upsert
   */
  export type CreditNoteItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditNoteItem to update in case it exists.
     */
    where: CreditNoteItemWhereUniqueInput
    /**
     * In case the CreditNoteItem found by the `where` argument doesn't exist, create a new CreditNoteItem with this data.
     */
    create: XOR<CreditNoteItemCreateInput, CreditNoteItemUncheckedCreateInput>
    /**
     * In case the CreditNoteItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditNoteItemUpdateInput, CreditNoteItemUncheckedUpdateInput>
  }

  /**
   * CreditNoteItem delete
   */
  export type CreditNoteItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
    /**
     * Filter which CreditNoteItem to delete.
     */
    where: CreditNoteItemWhereUniqueInput
  }

  /**
   * CreditNoteItem deleteMany
   */
  export type CreditNoteItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditNoteItems to delete
     */
    where?: CreditNoteItemWhereInput
    /**
     * Limit how many CreditNoteItems to delete.
     */
    limit?: number
  }

  /**
   * CreditNoteItem without action
   */
  export type CreditNoteItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteItem
     */
    select?: CreditNoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteItem
     */
    omit?: CreditNoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteItemInclude<ExtArgs> | null
  }


  /**
   * Model SessionLog
   */

  export type AggregateSessionLog = {
    _count: SessionLogCountAggregateOutputType | null
    _min: SessionLogMinAggregateOutputType | null
    _max: SessionLogMaxAggregateOutputType | null
  }

  export type SessionLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    sessionToken: string | null
    ipAddress: string | null
    userAgent: string | null
    loginAt: Date | null
    lastActivityAt: Date | null
    logoutAt: Date | null
    status: $Enums.SessionStatus | null
  }

  export type SessionLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    sessionToken: string | null
    ipAddress: string | null
    userAgent: string | null
    loginAt: Date | null
    lastActivityAt: Date | null
    logoutAt: Date | null
    status: $Enums.SessionStatus | null
  }

  export type SessionLogCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    sessionToken: number
    ipAddress: number
    userAgent: number
    loginAt: number
    lastActivityAt: number
    logoutAt: number
    status: number
    metadata: number
    _all: number
  }


  export type SessionLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    sessionToken?: true
    ipAddress?: true
    userAgent?: true
    loginAt?: true
    lastActivityAt?: true
    logoutAt?: true
    status?: true
  }

  export type SessionLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    sessionToken?: true
    ipAddress?: true
    userAgent?: true
    loginAt?: true
    lastActivityAt?: true
    logoutAt?: true
    status?: true
  }

  export type SessionLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    sessionToken?: true
    ipAddress?: true
    userAgent?: true
    loginAt?: true
    lastActivityAt?: true
    logoutAt?: true
    status?: true
    metadata?: true
    _all?: true
  }

  export type SessionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionLog to aggregate.
     */
    where?: SessionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLogs to fetch.
     */
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionLogs
    **/
    _count?: true | SessionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionLogMaxAggregateInputType
  }

  export type GetSessionLogAggregateType<T extends SessionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionLog[P]>
      : GetScalarType<T[P], AggregateSessionLog[P]>
  }




  export type SessionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionLogWhereInput
    orderBy?: SessionLogOrderByWithAggregationInput | SessionLogOrderByWithAggregationInput[]
    by: SessionLogScalarFieldEnum[] | SessionLogScalarFieldEnum
    having?: SessionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionLogCountAggregateInputType | true
    _min?: SessionLogMinAggregateInputType
    _max?: SessionLogMaxAggregateInputType
  }

  export type SessionLogGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    sessionToken: string
    ipAddress: string | null
    userAgent: string | null
    loginAt: Date
    lastActivityAt: Date
    logoutAt: Date | null
    status: $Enums.SessionStatus
    metadata: JsonValue | null
    _count: SessionLogCountAggregateOutputType | null
    _min: SessionLogMinAggregateOutputType | null
    _max: SessionLogMaxAggregateOutputType | null
  }

  type GetSessionLogGroupByPayload<T extends SessionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionLogGroupByOutputType[P]>
            : GetScalarType<T[P], SessionLogGroupByOutputType[P]>
        }
      >
    >


  export type SessionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    sessionToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    loginAt?: boolean
    lastActivityAt?: boolean
    logoutAt?: boolean
    status?: boolean
    metadata?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionLog"]>

  export type SessionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    sessionToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    loginAt?: boolean
    lastActivityAt?: boolean
    logoutAt?: boolean
    status?: boolean
    metadata?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionLog"]>

  export type SessionLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    sessionToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    loginAt?: boolean
    lastActivityAt?: boolean
    logoutAt?: boolean
    status?: boolean
    metadata?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionLog"]>

  export type SessionLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    sessionToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    loginAt?: boolean
    lastActivityAt?: boolean
    logoutAt?: boolean
    status?: boolean
    metadata?: boolean
  }

  export type SessionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "sessionToken" | "ipAddress" | "userAgent" | "loginAt" | "lastActivityAt" | "logoutAt" | "status" | "metadata", ExtArgs["result"]["sessionLog"]>
  export type SessionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      sessionToken: string
      ipAddress: string | null
      userAgent: string | null
      loginAt: Date
      lastActivityAt: Date
      logoutAt: Date | null
      status: $Enums.SessionStatus
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["sessionLog"]>
    composites: {}
  }

  type SessionLogGetPayload<S extends boolean | null | undefined | SessionLogDefaultArgs> = $Result.GetResult<Prisma.$SessionLogPayload, S>

  type SessionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionLogCountAggregateInputType | true
    }

  export interface SessionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionLog'], meta: { name: 'SessionLog' } }
    /**
     * Find zero or one SessionLog that matches the filter.
     * @param {SessionLogFindUniqueArgs} args - Arguments to find a SessionLog
     * @example
     * // Get one SessionLog
     * const sessionLog = await prisma.sessionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionLogFindUniqueArgs>(args: SelectSubset<T, SessionLogFindUniqueArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionLogFindUniqueOrThrowArgs} args - Arguments to find a SessionLog
     * @example
     * // Get one SessionLog
     * const sessionLog = await prisma.sessionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogFindFirstArgs} args - Arguments to find a SessionLog
     * @example
     * // Get one SessionLog
     * const sessionLog = await prisma.sessionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionLogFindFirstArgs>(args?: SelectSubset<T, SessionLogFindFirstArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogFindFirstOrThrowArgs} args - Arguments to find a SessionLog
     * @example
     * // Get one SessionLog
     * const sessionLog = await prisma.sessionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionLogs
     * const sessionLogs = await prisma.sessionLog.findMany()
     * 
     * // Get first 10 SessionLogs
     * const sessionLogs = await prisma.sessionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionLogWithIdOnly = await prisma.sessionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionLogFindManyArgs>(args?: SelectSubset<T, SessionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionLog.
     * @param {SessionLogCreateArgs} args - Arguments to create a SessionLog.
     * @example
     * // Create one SessionLog
     * const SessionLog = await prisma.sessionLog.create({
     *   data: {
     *     // ... data to create a SessionLog
     *   }
     * })
     * 
     */
    create<T extends SessionLogCreateArgs>(args: SelectSubset<T, SessionLogCreateArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionLogs.
     * @param {SessionLogCreateManyArgs} args - Arguments to create many SessionLogs.
     * @example
     * // Create many SessionLogs
     * const sessionLog = await prisma.sessionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionLogCreateManyArgs>(args?: SelectSubset<T, SessionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionLogs and returns the data saved in the database.
     * @param {SessionLogCreateManyAndReturnArgs} args - Arguments to create many SessionLogs.
     * @example
     * // Create many SessionLogs
     * const sessionLog = await prisma.sessionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionLogs and only return the `id`
     * const sessionLogWithIdOnly = await prisma.sessionLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionLog.
     * @param {SessionLogDeleteArgs} args - Arguments to delete one SessionLog.
     * @example
     * // Delete one SessionLog
     * const SessionLog = await prisma.sessionLog.delete({
     *   where: {
     *     // ... filter to delete one SessionLog
     *   }
     * })
     * 
     */
    delete<T extends SessionLogDeleteArgs>(args: SelectSubset<T, SessionLogDeleteArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionLog.
     * @param {SessionLogUpdateArgs} args - Arguments to update one SessionLog.
     * @example
     * // Update one SessionLog
     * const sessionLog = await prisma.sessionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionLogUpdateArgs>(args: SelectSubset<T, SessionLogUpdateArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionLogs.
     * @param {SessionLogDeleteManyArgs} args - Arguments to filter SessionLogs to delete.
     * @example
     * // Delete a few SessionLogs
     * const { count } = await prisma.sessionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionLogDeleteManyArgs>(args?: SelectSubset<T, SessionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionLogs
     * const sessionLog = await prisma.sessionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionLogUpdateManyArgs>(args: SelectSubset<T, SessionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionLogs and returns the data updated in the database.
     * @param {SessionLogUpdateManyAndReturnArgs} args - Arguments to update many SessionLogs.
     * @example
     * // Update many SessionLogs
     * const sessionLog = await prisma.sessionLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionLogs and only return the `id`
     * const sessionLogWithIdOnly = await prisma.sessionLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionLog.
     * @param {SessionLogUpsertArgs} args - Arguments to update or create a SessionLog.
     * @example
     * // Update or create a SessionLog
     * const sessionLog = await prisma.sessionLog.upsert({
     *   create: {
     *     // ... data to create a SessionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionLog we want to update
     *   }
     * })
     */
    upsert<T extends SessionLogUpsertArgs>(args: SelectSubset<T, SessionLogUpsertArgs<ExtArgs>>): Prisma__SessionLogClient<$Result.GetResult<Prisma.$SessionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogCountArgs} args - Arguments to filter SessionLogs to count.
     * @example
     * // Count the number of SessionLogs
     * const count = await prisma.sessionLog.count({
     *   where: {
     *     // ... the filter for the SessionLogs we want to count
     *   }
     * })
    **/
    count<T extends SessionLogCountArgs>(
      args?: Subset<T, SessionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionLogAggregateArgs>(args: Subset<T, SessionLogAggregateArgs>): Prisma.PrismaPromise<GetSessionLogAggregateType<T>>

    /**
     * Group by SessionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionLogGroupByArgs['orderBy'] }
        : { orderBy?: SessionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionLog model
   */
  readonly fields: SessionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionLog model
   */
  interface SessionLogFieldRefs {
    readonly id: FieldRef<"SessionLog", 'String'>
    readonly tenantId: FieldRef<"SessionLog", 'String'>
    readonly userId: FieldRef<"SessionLog", 'String'>
    readonly sessionToken: FieldRef<"SessionLog", 'String'>
    readonly ipAddress: FieldRef<"SessionLog", 'String'>
    readonly userAgent: FieldRef<"SessionLog", 'String'>
    readonly loginAt: FieldRef<"SessionLog", 'DateTime'>
    readonly lastActivityAt: FieldRef<"SessionLog", 'DateTime'>
    readonly logoutAt: FieldRef<"SessionLog", 'DateTime'>
    readonly status: FieldRef<"SessionLog", 'SessionStatus'>
    readonly metadata: FieldRef<"SessionLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SessionLog findUnique
   */
  export type SessionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLog to fetch.
     */
    where: SessionLogWhereUniqueInput
  }

  /**
   * SessionLog findUniqueOrThrow
   */
  export type SessionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLog to fetch.
     */
    where: SessionLogWhereUniqueInput
  }

  /**
   * SessionLog findFirst
   */
  export type SessionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLog to fetch.
     */
    where?: SessionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLogs to fetch.
     */
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionLogs.
     */
    cursor?: SessionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionLogs.
     */
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * SessionLog findFirstOrThrow
   */
  export type SessionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLog to fetch.
     */
    where?: SessionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLogs to fetch.
     */
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionLogs.
     */
    cursor?: SessionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionLogs.
     */
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * SessionLog findMany
   */
  export type SessionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter, which SessionLogs to fetch.
     */
    where?: SessionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLogs to fetch.
     */
    orderBy?: SessionLogOrderByWithRelationInput | SessionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionLogs.
     */
    cursor?: SessionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLogs.
     */
    skip?: number
    distinct?: SessionLogScalarFieldEnum | SessionLogScalarFieldEnum[]
  }

  /**
   * SessionLog create
   */
  export type SessionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionLog.
     */
    data: XOR<SessionLogCreateInput, SessionLogUncheckedCreateInput>
  }

  /**
   * SessionLog createMany
   */
  export type SessionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionLogs.
     */
    data: SessionLogCreateManyInput | SessionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionLog createManyAndReturn
   */
  export type SessionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * The data used to create many SessionLogs.
     */
    data: SessionLogCreateManyInput | SessionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionLog update
   */
  export type SessionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionLog.
     */
    data: XOR<SessionLogUpdateInput, SessionLogUncheckedUpdateInput>
    /**
     * Choose, which SessionLog to update.
     */
    where: SessionLogWhereUniqueInput
  }

  /**
   * SessionLog updateMany
   */
  export type SessionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionLogs.
     */
    data: XOR<SessionLogUpdateManyMutationInput, SessionLogUncheckedUpdateManyInput>
    /**
     * Filter which SessionLogs to update
     */
    where?: SessionLogWhereInput
    /**
     * Limit how many SessionLogs to update.
     */
    limit?: number
  }

  /**
   * SessionLog updateManyAndReturn
   */
  export type SessionLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * The data used to update SessionLogs.
     */
    data: XOR<SessionLogUpdateManyMutationInput, SessionLogUncheckedUpdateManyInput>
    /**
     * Filter which SessionLogs to update
     */
    where?: SessionLogWhereInput
    /**
     * Limit how many SessionLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionLog upsert
   */
  export type SessionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionLog to update in case it exists.
     */
    where: SessionLogWhereUniqueInput
    /**
     * In case the SessionLog found by the `where` argument doesn't exist, create a new SessionLog with this data.
     */
    create: XOR<SessionLogCreateInput, SessionLogUncheckedCreateInput>
    /**
     * In case the SessionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionLogUpdateInput, SessionLogUncheckedUpdateInput>
  }

  /**
   * SessionLog delete
   */
  export type SessionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
    /**
     * Filter which SessionLog to delete.
     */
    where: SessionLogWhereUniqueInput
  }

  /**
   * SessionLog deleteMany
   */
  export type SessionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionLogs to delete
     */
    where?: SessionLogWhereInput
    /**
     * Limit how many SessionLogs to delete.
     */
    limit?: number
  }

  /**
   * SessionLog without action
   */
  export type SessionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLog
     */
    select?: SessionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLog
     */
    omit?: SessionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLogInclude<ExtArgs> | null
  }


  /**
   * Model UserPresence
   */

  export type AggregateUserPresence = {
    _count: UserPresenceCountAggregateOutputType | null
    _min: UserPresenceMinAggregateOutputType | null
    _max: UserPresenceMaxAggregateOutputType | null
  }

  export type UserPresenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    status: $Enums.PresenceStatus | null
    currentRoute: string | null
    currentPage: string | null
    currentTicketId: string | null
    lastSeenAt: Date | null
  }

  export type UserPresenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    status: $Enums.PresenceStatus | null
    currentRoute: string | null
    currentPage: string | null
    currentTicketId: string | null
    lastSeenAt: Date | null
  }

  export type UserPresenceCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    status: number
    currentRoute: number
    currentPage: number
    currentTicketId: number
    lastSeenAt: number
    metadata: number
    _all: number
  }


  export type UserPresenceMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    status?: true
    currentRoute?: true
    currentPage?: true
    currentTicketId?: true
    lastSeenAt?: true
  }

  export type UserPresenceMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    status?: true
    currentRoute?: true
    currentPage?: true
    currentTicketId?: true
    lastSeenAt?: true
  }

  export type UserPresenceCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    status?: true
    currentRoute?: true
    currentPage?: true
    currentTicketId?: true
    lastSeenAt?: true
    metadata?: true
    _all?: true
  }

  export type UserPresenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPresence to aggregate.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPresences
    **/
    _count?: true | UserPresenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPresenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPresenceMaxAggregateInputType
  }

  export type GetUserPresenceAggregateType<T extends UserPresenceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPresence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPresence[P]>
      : GetScalarType<T[P], AggregateUserPresence[P]>
  }




  export type UserPresenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPresenceWhereInput
    orderBy?: UserPresenceOrderByWithAggregationInput | UserPresenceOrderByWithAggregationInput[]
    by: UserPresenceScalarFieldEnum[] | UserPresenceScalarFieldEnum
    having?: UserPresenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPresenceCountAggregateInputType | true
    _min?: UserPresenceMinAggregateInputType
    _max?: UserPresenceMaxAggregateInputType
  }

  export type UserPresenceGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    status: $Enums.PresenceStatus
    currentRoute: string | null
    currentPage: string | null
    currentTicketId: string | null
    lastSeenAt: Date
    metadata: JsonValue | null
    _count: UserPresenceCountAggregateOutputType | null
    _min: UserPresenceMinAggregateOutputType | null
    _max: UserPresenceMaxAggregateOutputType | null
  }

  type GetUserPresenceGroupByPayload<T extends UserPresenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPresenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPresenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPresenceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPresenceGroupByOutputType[P]>
        }
      >
    >


  export type UserPresenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    status?: boolean
    currentRoute?: boolean
    currentPage?: boolean
    currentTicketId?: boolean
    lastSeenAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    currentTicket?: boolean | UserPresence$currentTicketArgs<ExtArgs>
  }, ExtArgs["result"]["userPresence"]>

  export type UserPresenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    status?: boolean
    currentRoute?: boolean
    currentPage?: boolean
    currentTicketId?: boolean
    lastSeenAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    currentTicket?: boolean | UserPresence$currentTicketArgs<ExtArgs>
  }, ExtArgs["result"]["userPresence"]>

  export type UserPresenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    status?: boolean
    currentRoute?: boolean
    currentPage?: boolean
    currentTicketId?: boolean
    lastSeenAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    currentTicket?: boolean | UserPresence$currentTicketArgs<ExtArgs>
  }, ExtArgs["result"]["userPresence"]>

  export type UserPresenceSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    status?: boolean
    currentRoute?: boolean
    currentPage?: boolean
    currentTicketId?: boolean
    lastSeenAt?: boolean
    metadata?: boolean
  }

  export type UserPresenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tenantId" | "status" | "currentRoute" | "currentPage" | "currentTicketId" | "lastSeenAt" | "metadata", ExtArgs["result"]["userPresence"]>
  export type UserPresenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    currentTicket?: boolean | UserPresence$currentTicketArgs<ExtArgs>
  }
  export type UserPresenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    currentTicket?: boolean | UserPresence$currentTicketArgs<ExtArgs>
  }
  export type UserPresenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    currentTicket?: boolean | UserPresence$currentTicketArgs<ExtArgs>
  }

  export type $UserPresencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPresence"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      currentTicket: Prisma.$TicketPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      status: $Enums.PresenceStatus
      currentRoute: string | null
      currentPage: string | null
      currentTicketId: string | null
      lastSeenAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["userPresence"]>
    composites: {}
  }

  type UserPresenceGetPayload<S extends boolean | null | undefined | UserPresenceDefaultArgs> = $Result.GetResult<Prisma.$UserPresencePayload, S>

  type UserPresenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPresenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPresenceCountAggregateInputType | true
    }

  export interface UserPresenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPresence'], meta: { name: 'UserPresence' } }
    /**
     * Find zero or one UserPresence that matches the filter.
     * @param {UserPresenceFindUniqueArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPresenceFindUniqueArgs>(args: SelectSubset<T, UserPresenceFindUniqueArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPresence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPresenceFindUniqueOrThrowArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPresenceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPresenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPresence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindFirstArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPresenceFindFirstArgs>(args?: SelectSubset<T, UserPresenceFindFirstArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPresence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindFirstOrThrowArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPresenceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPresenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPresences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPresences
     * const userPresences = await prisma.userPresence.findMany()
     * 
     * // Get first 10 UserPresences
     * const userPresences = await prisma.userPresence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPresenceWithIdOnly = await prisma.userPresence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPresenceFindManyArgs>(args?: SelectSubset<T, UserPresenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPresence.
     * @param {UserPresenceCreateArgs} args - Arguments to create a UserPresence.
     * @example
     * // Create one UserPresence
     * const UserPresence = await prisma.userPresence.create({
     *   data: {
     *     // ... data to create a UserPresence
     *   }
     * })
     * 
     */
    create<T extends UserPresenceCreateArgs>(args: SelectSubset<T, UserPresenceCreateArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPresences.
     * @param {UserPresenceCreateManyArgs} args - Arguments to create many UserPresences.
     * @example
     * // Create many UserPresences
     * const userPresence = await prisma.userPresence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPresenceCreateManyArgs>(args?: SelectSubset<T, UserPresenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPresences and returns the data saved in the database.
     * @param {UserPresenceCreateManyAndReturnArgs} args - Arguments to create many UserPresences.
     * @example
     * // Create many UserPresences
     * const userPresence = await prisma.userPresence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPresences and only return the `id`
     * const userPresenceWithIdOnly = await prisma.userPresence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPresenceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPresenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPresence.
     * @param {UserPresenceDeleteArgs} args - Arguments to delete one UserPresence.
     * @example
     * // Delete one UserPresence
     * const UserPresence = await prisma.userPresence.delete({
     *   where: {
     *     // ... filter to delete one UserPresence
     *   }
     * })
     * 
     */
    delete<T extends UserPresenceDeleteArgs>(args: SelectSubset<T, UserPresenceDeleteArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPresence.
     * @param {UserPresenceUpdateArgs} args - Arguments to update one UserPresence.
     * @example
     * // Update one UserPresence
     * const userPresence = await prisma.userPresence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPresenceUpdateArgs>(args: SelectSubset<T, UserPresenceUpdateArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPresences.
     * @param {UserPresenceDeleteManyArgs} args - Arguments to filter UserPresences to delete.
     * @example
     * // Delete a few UserPresences
     * const { count } = await prisma.userPresence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPresenceDeleteManyArgs>(args?: SelectSubset<T, UserPresenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPresences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPresences
     * const userPresence = await prisma.userPresence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPresenceUpdateManyArgs>(args: SelectSubset<T, UserPresenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPresences and returns the data updated in the database.
     * @param {UserPresenceUpdateManyAndReturnArgs} args - Arguments to update many UserPresences.
     * @example
     * // Update many UserPresences
     * const userPresence = await prisma.userPresence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPresences and only return the `id`
     * const userPresenceWithIdOnly = await prisma.userPresence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPresenceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPresenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPresence.
     * @param {UserPresenceUpsertArgs} args - Arguments to update or create a UserPresence.
     * @example
     * // Update or create a UserPresence
     * const userPresence = await prisma.userPresence.upsert({
     *   create: {
     *     // ... data to create a UserPresence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPresence we want to update
     *   }
     * })
     */
    upsert<T extends UserPresenceUpsertArgs>(args: SelectSubset<T, UserPresenceUpsertArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPresences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceCountArgs} args - Arguments to filter UserPresences to count.
     * @example
     * // Count the number of UserPresences
     * const count = await prisma.userPresence.count({
     *   where: {
     *     // ... the filter for the UserPresences we want to count
     *   }
     * })
    **/
    count<T extends UserPresenceCountArgs>(
      args?: Subset<T, UserPresenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPresenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPresence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPresenceAggregateArgs>(args: Subset<T, UserPresenceAggregateArgs>): Prisma.PrismaPromise<GetUserPresenceAggregateType<T>>

    /**
     * Group by UserPresence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPresenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPresenceGroupByArgs['orderBy'] }
        : { orderBy?: UserPresenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPresenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPresenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPresence model
   */
  readonly fields: UserPresenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPresence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPresenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currentTicket<T extends UserPresence$currentTicketArgs<ExtArgs> = {}>(args?: Subset<T, UserPresence$currentTicketArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPresence model
   */
  interface UserPresenceFieldRefs {
    readonly id: FieldRef<"UserPresence", 'String'>
    readonly userId: FieldRef<"UserPresence", 'String'>
    readonly tenantId: FieldRef<"UserPresence", 'String'>
    readonly status: FieldRef<"UserPresence", 'PresenceStatus'>
    readonly currentRoute: FieldRef<"UserPresence", 'String'>
    readonly currentPage: FieldRef<"UserPresence", 'String'>
    readonly currentTicketId: FieldRef<"UserPresence", 'String'>
    readonly lastSeenAt: FieldRef<"UserPresence", 'DateTime'>
    readonly metadata: FieldRef<"UserPresence", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserPresence findUnique
   */
  export type UserPresenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence findUniqueOrThrow
   */
  export type UserPresenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence findFirst
   */
  export type UserPresenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPresences.
     */
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence findFirstOrThrow
   */
  export type UserPresenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPresences.
     */
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence findMany
   */
  export type UserPresenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPresences to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence create
   */
  export type UserPresenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPresence.
     */
    data: XOR<UserPresenceCreateInput, UserPresenceUncheckedCreateInput>
  }

  /**
   * UserPresence createMany
   */
  export type UserPresenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPresences.
     */
    data: UserPresenceCreateManyInput | UserPresenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPresence createManyAndReturn
   */
  export type UserPresenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * The data used to create many UserPresences.
     */
    data: UserPresenceCreateManyInput | UserPresenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPresence update
   */
  export type UserPresenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPresence.
     */
    data: XOR<UserPresenceUpdateInput, UserPresenceUncheckedUpdateInput>
    /**
     * Choose, which UserPresence to update.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence updateMany
   */
  export type UserPresenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPresences.
     */
    data: XOR<UserPresenceUpdateManyMutationInput, UserPresenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPresences to update
     */
    where?: UserPresenceWhereInput
    /**
     * Limit how many UserPresences to update.
     */
    limit?: number
  }

  /**
   * UserPresence updateManyAndReturn
   */
  export type UserPresenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * The data used to update UserPresences.
     */
    data: XOR<UserPresenceUpdateManyMutationInput, UserPresenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPresences to update
     */
    where?: UserPresenceWhereInput
    /**
     * Limit how many UserPresences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPresence upsert
   */
  export type UserPresenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPresence to update in case it exists.
     */
    where: UserPresenceWhereUniqueInput
    /**
     * In case the UserPresence found by the `where` argument doesn't exist, create a new UserPresence with this data.
     */
    create: XOR<UserPresenceCreateInput, UserPresenceUncheckedCreateInput>
    /**
     * In case the UserPresence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPresenceUpdateInput, UserPresenceUncheckedUpdateInput>
  }

  /**
   * UserPresence delete
   */
  export type UserPresenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
    /**
     * Filter which UserPresence to delete.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence deleteMany
   */
  export type UserPresenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPresences to delete
     */
    where?: UserPresenceWhereInput
    /**
     * Limit how many UserPresences to delete.
     */
    limit?: number
  }

  /**
   * UserPresence.currentTicket
   */
  export type UserPresence$currentTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
  }

  /**
   * UserPresence without action
   */
  export type UserPresenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPresenceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    adminUserId: 'adminUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    name: 'name',
    role: 'role',
    tenantId: 'tenantId',
    isActive: 'isActive',
    passwordMustChange: 'passwordMustChange',
    lastLoginAt: 'lastLoginAt',
    failedLoginAttempts: 'failedLoginAttempts',
    lockedUntil: 'lockedUntil',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    maxConcurrentTickets: 'maxConcurrentTickets',
    statusReason: 'statusReason',
    availableFrom: 'availableFrom',
    availableUntil: 'availableUntil'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    dpi: 'dpi',
    nit: 'nit'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    ticketNumber: 'ticketNumber',
    title: 'title',
    description: 'description',
    status: 'status',
    tenantId: 'tenantId',
    customerId: 'customerId',
    assignedToId: 'assignedToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accessories: 'accessories',
    cancellationReason: 'cancellationReason',
    checkInNotes: 'checkInNotes',
    deviceModel: 'deviceModel',
    deviceType: 'deviceType',
    serialNumber: 'serialNumber',
    createdById: 'createdById',
    serviceTemplateId: 'serviceTemplateId',
    updatedById: 'updatedById',
    priority: 'priority',
    dueDate: 'dueDate',
    estimatedCompletionDate: 'estimatedCompletionDate'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketAttachmentScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt'
  };

  export type TicketAttachmentScalarFieldEnum = (typeof TicketAttachmentScalarFieldEnum)[keyof typeof TicketAttachmentScalarFieldEnum]


  export const PartScalarFieldEnum: {
    id: 'id',
    name: 'name',
    sku: 'sku',
    quantity: 'quantity',
    cost: 'cost',
    price: 'price',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    category: 'category',
    location: 'location',
    minStock: 'minStock'
  };

  export type PartScalarFieldEnum = (typeof PartScalarFieldEnum)[keyof typeof PartScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    supplier: 'supplier',
    status: 'status',
    orderDate: 'orderDate',
    receivedDate: 'receivedDate',
    totalCost: 'totalCost',
    tenantId: 'tenantId',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseItemScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    unitCost: 'unitCost',
    partId: 'partId',
    purchaseOrderId: 'purchaseOrderId'
  };

  export type PurchaseItemScalarFieldEnum = (typeof PurchaseItemScalarFieldEnum)[keyof typeof PurchaseItemScalarFieldEnum]


  export const PartUsageScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    ticketId: 'ticketId',
    partId: 'partId',
    createdAt: 'createdAt'
  };

  export type PartUsageScalarFieldEnum = (typeof PartUsageScalarFieldEnum)[keyof typeof PartUsageScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    details: 'details',
    userId: 'userId',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    action: 'action',
    module: 'module',
    entityType: 'entityType',
    entityId: 'entityId',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const TicketNoteScalarFieldEnum: {
    id: 'id',
    content: 'content',
    isInternal: 'isInternal',
    ticketId: 'ticketId',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketNoteScalarFieldEnum = (typeof TicketNoteScalarFieldEnum)[keyof typeof TicketNoteScalarFieldEnum]


  export const ServiceTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    defaultTitle: 'defaultTitle',
    defaultDescription: 'defaultDescription',
    defaultPriority: 'defaultPriority',
    estimatedDuration: 'estimatedDuration',
    laborCost: 'laborCost',
    isActive: 'isActive',
    color: 'color',
    icon: 'icon',
    tenantId: 'tenantId',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceTemplateScalarFieldEnum = (typeof ServiceTemplateScalarFieldEnum)[keyof typeof ServiceTemplateScalarFieldEnum]


  export const TemplateDefaultPartScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    required: 'required',
    templateId: 'templateId',
    partId: 'partId',
    createdAt: 'createdAt'
  };

  export type TemplateDefaultPartScalarFieldEnum = (typeof TemplateDefaultPartScalarFieldEnum)[keyof typeof TemplateDefaultPartScalarFieldEnum]


  export const TicketServiceScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    serviceId: 'serviceId',
    name: 'name',
    laborCost: 'laborCost',
    createdAt: 'createdAt'
  };

  export type TicketServiceScalarFieldEnum = (typeof TicketServiceScalarFieldEnum)[keyof typeof TicketServiceScalarFieldEnum]


  export const TechnicianSpecializationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    specialization: 'specialization',
    createdAt: 'createdAt'
  };

  export type TechnicianSpecializationScalarFieldEnum = (typeof TechnicianSpecializationScalarFieldEnum)[keyof typeof TechnicianSpecializationScalarFieldEnum]


  export const TechnicianUnavailabilityScalarFieldEnum: {
    id: 'id',
    reason: 'reason',
    notes: 'notes',
    userId: 'userId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TechnicianUnavailabilityScalarFieldEnum = (typeof TechnicianUnavailabilityScalarFieldEnum)[keyof typeof TechnicianUnavailabilityScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    link: 'link',
    isRead: 'isRead',
    tenantId: 'tenantId',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    status: 'status',
    ticketId: 'ticketId',
    customerId: 'customerId',
    laborCost: 'laborCost',
    partsCost: 'partsCost',
    partsMarkup: 'partsMarkup',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    total: 'total',
    customerName: 'customerName',
    customerNIT: 'customerNIT',
    customerDPI: 'customerDPI',
    customerAddress: 'customerAddress',
    notes: 'notes',
    paymentTerms: 'paymentTerms',
    issuedAt: 'issuedAt',
    dueAt: 'dueAt',
    paidAt: 'paidAt',
    tenantId: 'tenantId',
    createdById: 'createdById',
    updatedById: 'updatedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    paymentNumber: 'paymentNumber',
    invoiceId: 'invoiceId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    transactionRef: 'transactionRef',
    notes: 'notes',
    paidAt: 'paidAt',
    tenantId: 'tenantId',
    receivedById: 'receivedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const CashRegisterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isOpen: 'isOpen',
    openedAt: 'openedAt',
    closedAt: 'closedAt',
    openingBalance: 'openingBalance',
    closingBalance: 'closingBalance',
    expectedBalance: 'expectedBalance',
    difference: 'difference',
    closingNotes: 'closingNotes',
    tenantId: 'tenantId',
    openedById: 'openedById',
    closedById: 'closedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CashRegisterScalarFieldEnum = (typeof CashRegisterScalarFieldEnum)[keyof typeof CashRegisterScalarFieldEnum]


  export const CashTransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    description: 'description',
    reference: 'reference',
    cashRegisterId: 'cashRegisterId',
    tenantId: 'tenantId',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type CashTransactionScalarFieldEnum = (typeof CashTransactionScalarFieldEnum)[keyof typeof CashTransactionScalarFieldEnum]


  export const TenantSettingsScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    businessName: 'businessName',
    businessNIT: 'businessNIT',
    businessAddress: 'businessAddress',
    businessPhone: 'businessPhone',
    businessEmail: 'businessEmail',
    taxRate: 'taxRate',
    taxName: 'taxName',
    currency: 'currency',
    defaultPaymentTerms: 'defaultPaymentTerms',
    invoiceFooter: 'invoiceFooter',
    slaWarningPercent: 'slaWarningPercent',
    slaCriticalPercent: 'slaCriticalPercent',
    slaEmailEnabled: 'slaEmailEnabled',
    slaInAppEnabled: 'slaInAppEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantSettingsScalarFieldEnum = (typeof TenantSettingsScalarFieldEnum)[keyof typeof TenantSettingsScalarFieldEnum]


  export const InvoiceHistoryScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    action: 'action',
    oldValue: 'oldValue',
    newValue: 'newValue',
    notes: 'notes',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type InvoiceHistoryScalarFieldEnum = (typeof InvoiceHistoryScalarFieldEnum)[keyof typeof InvoiceHistoryScalarFieldEnum]


  export const POSSaleScalarFieldEnum: {
    id: 'id',
    saleNumber: 'saleNumber',
    customerId: 'customerId',
    customerName: 'customerName',
    customerPhone: 'customerPhone',
    customerEmail: 'customerEmail',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    total: 'total',
    amountPaid: 'amountPaid',
    changeGiven: 'changeGiven',
    status: 'status',
    notes: 'notes',
    tenantId: 'tenantId',
    cashRegisterId: 'cashRegisterId',
    createdById: 'createdById',
    quotationId: 'quotationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type POSSaleScalarFieldEnum = (typeof POSSaleScalarFieldEnum)[keyof typeof POSSaleScalarFieldEnum]


  export const POSSaleItemScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    partId: 'partId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discount: 'discount'
  };

  export type POSSaleItemScalarFieldEnum = (typeof POSSaleItemScalarFieldEnum)[keyof typeof POSSaleItemScalarFieldEnum]


  export const POSSalePaymentScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    amount: 'amount',
    method: 'method',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type POSSalePaymentScalarFieldEnum = (typeof POSSalePaymentScalarFieldEnum)[keyof typeof POSSalePaymentScalarFieldEnum]


  export const POSQuotationScalarFieldEnum: {
    id: 'id',
    quotationNumber: 'quotationNumber',
    customerId: 'customerId',
    customerName: 'customerName',
    customerPhone: 'customerPhone',
    customerEmail: 'customerEmail',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    total: 'total',
    status: 'status',
    validUntil: 'validUntil',
    notes: 'notes',
    tenantId: 'tenantId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type POSQuotationScalarFieldEnum = (typeof POSQuotationScalarFieldEnum)[keyof typeof POSQuotationScalarFieldEnum]


  export const POSQuotationItemScalarFieldEnum: {
    id: 'id',
    quotationId: 'quotationId',
    partId: 'partId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discount: 'discount'
  };

  export type POSQuotationItemScalarFieldEnum = (typeof POSQuotationItemScalarFieldEnum)[keyof typeof POSQuotationItemScalarFieldEnum]


  export const CreditNoteScalarFieldEnum: {
    id: 'id',
    creditNoteNumber: 'creditNoteNumber',
    posSaleId: 'posSaleId',
    customerId: 'customerId',
    reason: 'reason',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    total: 'total',
    status: 'status',
    refundMethod: 'refundMethod',
    refundReference: 'refundReference',
    notes: 'notes',
    processedAt: 'processedAt',
    processedById: 'processedById',
    tenantId: 'tenantId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreditNoteScalarFieldEnum = (typeof CreditNoteScalarFieldEnum)[keyof typeof CreditNoteScalarFieldEnum]


  export const CreditNoteItemScalarFieldEnum: {
    id: 'id',
    creditNoteId: 'creditNoteId',
    partId: 'partId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    reason: 'reason'
  };

  export type CreditNoteItemScalarFieldEnum = (typeof CreditNoteItemScalarFieldEnum)[keyof typeof CreditNoteItemScalarFieldEnum]


  export const SessionLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    sessionToken: 'sessionToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    loginAt: 'loginAt',
    lastActivityAt: 'lastActivityAt',
    logoutAt: 'logoutAt',
    status: 'status',
    metadata: 'metadata'
  };

  export type SessionLogScalarFieldEnum = (typeof SessionLogScalarFieldEnum)[keyof typeof SessionLogScalarFieldEnum]


  export const UserPresenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    status: 'status',
    currentRoute: 'currentRoute',
    currentPage: 'currentPage',
    currentTicketId: 'currentTicketId',
    lastSeenAt: 'lastSeenAt',
    metadata: 'metadata'
  };

  export type UserPresenceScalarFieldEnum = (typeof UserPresenceScalarFieldEnum)[keyof typeof UserPresenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TechnicianStatus'
   */
  export type EnumTechnicianStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TechnicianStatus'>
    


  /**
   * Reference to a field of type 'TechnicianStatus[]'
   */
  export type ListEnumTechnicianStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TechnicianStatus[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PurchaseStatus'
   */
  export type EnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus'>
    


  /**
   * Reference to a field of type 'PurchaseStatus[]'
   */
  export type ListEnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'AuditModule'
   */
  export type EnumAuditModuleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditModule'>
    


  /**
   * Reference to a field of type 'AuditModule[]'
   */
  export type ListEnumAuditModuleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditModule[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ServiceCategory'
   */
  export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory'>
    


  /**
   * Reference to a field of type 'ServiceCategory[]'
   */
  export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory[]'>
    


  /**
   * Reference to a field of type 'Specialization'
   */
  export type EnumSpecializationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Specialization'>
    


  /**
   * Reference to a field of type 'Specialization[]'
   */
  export type ListEnumSpecializationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Specialization[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'POSSaleStatus'
   */
  export type EnumPOSSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POSSaleStatus'>
    


  /**
   * Reference to a field of type 'POSSaleStatus[]'
   */
  export type ListEnumPOSSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POSSaleStatus[]'>
    


  /**
   * Reference to a field of type 'QuotationStatus'
   */
  export type EnumQuotationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationStatus'>
    


  /**
   * Reference to a field of type 'QuotationStatus[]'
   */
  export type ListEnumQuotationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationStatus[]'>
    


  /**
   * Reference to a field of type 'CreditNoteStatus'
   */
  export type EnumCreditNoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditNoteStatus'>
    


  /**
   * Reference to a field of type 'CreditNoteStatus[]'
   */
  export type ListEnumCreditNoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditNoteStatus[]'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'PresenceStatus'
   */
  export type EnumPresenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PresenceStatus'>
    


  /**
   * Reference to a field of type 'PresenceStatus[]'
   */
  export type ListEnumPresenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PresenceStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: UuidFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    adminUserId?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    auditLogs?: AuditLogListRelationFilter
    sessionLogs?: SessionLogListRelationFilter
    userPresences?: UserPresenceListRelationFilter
    cashRegisters?: CashRegisterListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    creditNotes?: CreditNoteListRelationFilter
    customers?: CustomerListRelationFilter
    invoices?: InvoiceListRelationFilter
    notifications?: NotificationListRelationFilter
    parts?: PartListRelationFilter
    payments?: PaymentListRelationFilter
    posSales?: POSSaleListRelationFilter
    posQuotations?: POSQuotationListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    serviceTemplates?: ServiceTemplateListRelationFilter
    settings?: XOR<TenantSettingsNullableScalarRelationFilter, TenantSettingsWhereInput> | null
    tickets?: TicketListRelationFilter
    users?: UserListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    adminUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auditLogs?: AuditLogOrderByRelationAggregateInput
    sessionLogs?: SessionLogOrderByRelationAggregateInput
    userPresences?: UserPresenceOrderByRelationAggregateInput
    cashRegisters?: CashRegisterOrderByRelationAggregateInput
    cashTransactions?: CashTransactionOrderByRelationAggregateInput
    creditNotes?: CreditNoteOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    parts?: PartOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    posSales?: POSSaleOrderByRelationAggregateInput
    posQuotations?: POSQuotationOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    serviceTemplates?: ServiceTemplateOrderByRelationAggregateInput
    settings?: TenantSettingsOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    adminUserId?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    auditLogs?: AuditLogListRelationFilter
    sessionLogs?: SessionLogListRelationFilter
    userPresences?: UserPresenceListRelationFilter
    cashRegisters?: CashRegisterListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    creditNotes?: CreditNoteListRelationFilter
    customers?: CustomerListRelationFilter
    invoices?: InvoiceListRelationFilter
    notifications?: NotificationListRelationFilter
    parts?: PartListRelationFilter
    payments?: PaymentListRelationFilter
    posSales?: POSSaleListRelationFilter
    posQuotations?: POSQuotationListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    serviceTemplates?: ServiceTemplateListRelationFilter
    settings?: XOR<TenantSettingsNullableScalarRelationFilter, TenantSettingsWhereInput> | null
    tickets?: TicketListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "slug">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    adminUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    adminUserId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    tenantId?: UuidFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    passwordMustChange?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: UuidNullableFilter<"User"> | string | null
    updatedById?: UuidNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumTechnicianStatusFilter<"User"> | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFilter<"User"> | number
    statusReason?: StringNullableFilter<"User"> | string | null
    availableFrom?: DateTimeNullableFilter<"User"> | Date | string | null
    availableUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    usersCreated?: UserListRelationFilter
    usersUpdated?: UserListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    sessionLogs?: SessionLogListRelationFilter
    presence?: XOR<UserPresenceNullableScalarRelationFilter, UserPresenceWhereInput> | null
    closedCashRegisters?: CashRegisterListRelationFilter
    openedCashRegisters?: CashRegisterListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    creditNotesCreated?: CreditNoteListRelationFilter
    creditNotesProcessed?: CreditNoteListRelationFilter
    createdCustomers?: CustomerListRelationFilter
    updatedCustomers?: CustomerListRelationFilter
    createdInvoices?: InvoiceListRelationFilter
    updatedInvoices?: InvoiceListRelationFilter
    invoiceHistory?: InvoiceHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
    createdParts?: PartListRelationFilter
    updatedParts?: PartListRelationFilter
    posSales?: POSSaleListRelationFilter
    posQuotations?: POSQuotationListRelationFilter
    receivedPayments?: PaymentListRelationFilter
    createdTemplates?: ServiceTemplateListRelationFilter
    updatedTemplates?: ServiceTemplateListRelationFilter
    specializations?: TechnicianSpecializationListRelationFilter
    unavailabilities?: TechnicianUnavailabilityListRelationFilter
    ticketNotes?: TicketNoteListRelationFilter
    assignedTickets?: TicketListRelationFilter
    createdTickets?: TicketListRelationFilter
    updatedTickets?: TicketListRelationFilter
    uploadedAttachments?: TicketAttachmentListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    passwordMustChange?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    maxConcurrentTickets?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    availableFrom?: SortOrderInput | SortOrder
    availableUntil?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    usersCreated?: UserOrderByRelationAggregateInput
    usersUpdated?: UserOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    sessionLogs?: SessionLogOrderByRelationAggregateInput
    presence?: UserPresenceOrderByWithRelationInput
    closedCashRegisters?: CashRegisterOrderByRelationAggregateInput
    openedCashRegisters?: CashRegisterOrderByRelationAggregateInput
    cashTransactions?: CashTransactionOrderByRelationAggregateInput
    creditNotesCreated?: CreditNoteOrderByRelationAggregateInput
    creditNotesProcessed?: CreditNoteOrderByRelationAggregateInput
    createdCustomers?: CustomerOrderByRelationAggregateInput
    updatedCustomers?: CustomerOrderByRelationAggregateInput
    createdInvoices?: InvoiceOrderByRelationAggregateInput
    updatedInvoices?: InvoiceOrderByRelationAggregateInput
    invoiceHistory?: InvoiceHistoryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    createdParts?: PartOrderByRelationAggregateInput
    updatedParts?: PartOrderByRelationAggregateInput
    posSales?: POSSaleOrderByRelationAggregateInput
    posQuotations?: POSQuotationOrderByRelationAggregateInput
    receivedPayments?: PaymentOrderByRelationAggregateInput
    createdTemplates?: ServiceTemplateOrderByRelationAggregateInput
    updatedTemplates?: ServiceTemplateOrderByRelationAggregateInput
    specializations?: TechnicianSpecializationOrderByRelationAggregateInput
    unavailabilities?: TechnicianUnavailabilityOrderByRelationAggregateInput
    ticketNotes?: TicketNoteOrderByRelationAggregateInput
    assignedTickets?: TicketOrderByRelationAggregateInput
    createdTickets?: TicketOrderByRelationAggregateInput
    updatedTickets?: TicketOrderByRelationAggregateInput
    uploadedAttachments?: TicketAttachmentOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_email_per_tenant?: UserUnique_email_per_tenantCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    tenantId?: UuidFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    passwordMustChange?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: UuidNullableFilter<"User"> | string | null
    updatedById?: UuidNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumTechnicianStatusFilter<"User"> | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFilter<"User"> | number
    statusReason?: StringNullableFilter<"User"> | string | null
    availableFrom?: DateTimeNullableFilter<"User"> | Date | string | null
    availableUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    usersCreated?: UserListRelationFilter
    usersUpdated?: UserListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    sessionLogs?: SessionLogListRelationFilter
    presence?: XOR<UserPresenceNullableScalarRelationFilter, UserPresenceWhereInput> | null
    closedCashRegisters?: CashRegisterListRelationFilter
    openedCashRegisters?: CashRegisterListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    creditNotesCreated?: CreditNoteListRelationFilter
    creditNotesProcessed?: CreditNoteListRelationFilter
    createdCustomers?: CustomerListRelationFilter
    updatedCustomers?: CustomerListRelationFilter
    createdInvoices?: InvoiceListRelationFilter
    updatedInvoices?: InvoiceListRelationFilter
    invoiceHistory?: InvoiceHistoryListRelationFilter
    notifications?: NotificationListRelationFilter
    createdParts?: PartListRelationFilter
    updatedParts?: PartListRelationFilter
    posSales?: POSSaleListRelationFilter
    posQuotations?: POSQuotationListRelationFilter
    receivedPayments?: PaymentListRelationFilter
    createdTemplates?: ServiceTemplateListRelationFilter
    updatedTemplates?: ServiceTemplateListRelationFilter
    specializations?: TechnicianSpecializationListRelationFilter
    unavailabilities?: TechnicianUnavailabilityListRelationFilter
    ticketNotes?: TicketNoteListRelationFilter
    assignedTickets?: TicketListRelationFilter
    createdTickets?: TicketListRelationFilter
    updatedTickets?: TicketListRelationFilter
    uploadedAttachments?: TicketAttachmentListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "unique_email_per_tenant">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    passwordMustChange?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    maxConcurrentTickets?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    availableFrom?: SortOrderInput | SortOrder
    availableUntil?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    tenantId?: UuidWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    passwordMustChange?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdById?: UuidNullableWithAggregatesFilter<"User"> | string | null
    updatedById?: UuidNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    status?: EnumTechnicianStatusWithAggregatesFilter<"User"> | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntWithAggregatesFilter<"User"> | number
    statusReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    availableFrom?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    availableUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: UuidFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    tenantId?: UuidFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    createdById?: UuidNullableFilter<"Customer"> | string | null
    updatedById?: UuidNullableFilter<"Customer"> | string | null
    dpi?: StringNullableFilter<"Customer"> | string | null
    nit?: StringNullableFilter<"Customer"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    creditNotes?: CreditNoteListRelationFilter
    invoices?: InvoiceListRelationFilter
    posSales?: POSSaleListRelationFilter
    posQuotations?: POSQuotationListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tickets?: TicketListRelationFilter
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    dpi?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    creditNotes?: CreditNoteOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    posSales?: POSSaleOrderByRelationAggregateInput
    posQuotations?: POSQuotationOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
    updatedBy?: UserOrderByWithRelationInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_dpi_per_tenant?: CustomerUnique_dpi_per_tenantCompoundUniqueInput
    unique_nit_per_tenant?: CustomerUnique_nit_per_tenantCompoundUniqueInput
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    tenantId?: UuidFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    createdById?: UuidNullableFilter<"Customer"> | string | null
    updatedById?: UuidNullableFilter<"Customer"> | string | null
    dpi?: StringNullableFilter<"Customer"> | string | null
    nit?: StringNullableFilter<"Customer"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    creditNotes?: CreditNoteListRelationFilter
    invoices?: InvoiceListRelationFilter
    posSales?: POSSaleListRelationFilter
    posQuotations?: POSQuotationListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tickets?: TicketListRelationFilter
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "unique_dpi_per_tenant" | "unique_nit_per_tenant">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    dpi?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    tenantId?: UuidWithAggregatesFilter<"Customer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    createdById?: UuidNullableWithAggregatesFilter<"Customer"> | string | null
    updatedById?: UuidNullableWithAggregatesFilter<"Customer"> | string | null
    dpi?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    nit?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: UuidFilter<"Ticket"> | string
    ticketNumber?: StringNullableFilter<"Ticket"> | string | null
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    tenantId?: UuidFilter<"Ticket"> | string
    customerId?: UuidFilter<"Ticket"> | string
    assignedToId?: UuidNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    accessories?: StringNullableFilter<"Ticket"> | string | null
    cancellationReason?: StringNullableFilter<"Ticket"> | string | null
    checkInNotes?: StringNullableFilter<"Ticket"> | string | null
    deviceModel?: StringNullableFilter<"Ticket"> | string | null
    deviceType?: StringNullableFilter<"Ticket"> | string | null
    serialNumber?: StringNullableFilter<"Ticket"> | string | null
    createdById?: UuidNullableFilter<"Ticket"> | string | null
    serviceTemplateId?: UuidNullableFilter<"Ticket"> | string | null
    updatedById?: UuidNullableFilter<"Ticket"> | string | null
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    dueDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    estimatedCompletionDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    attachments?: TicketAttachmentListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    partsUsed?: PartUsageListRelationFilter
    notes?: TicketNoteListRelationFilter
    services?: TicketServiceListRelationFilter
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    serviceTemplate?: XOR<ServiceTemplateNullableScalarRelationFilter, ServiceTemplateWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    viewedByUsers?: UserPresenceListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    ticketNumber?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessories?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    checkInNotes?: SortOrderInput | SortOrder
    deviceModel?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    serviceTemplateId?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    estimatedCompletionDate?: SortOrderInput | SortOrder
    attachments?: TicketAttachmentOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    partsUsed?: PartUsageOrderByRelationAggregateInput
    notes?: TicketNoteOrderByRelationAggregateInput
    services?: TicketServiceOrderByRelationAggregateInput
    assignedTo?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    serviceTemplate?: ServiceTemplateOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    viewedByUsers?: UserPresenceOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticketNumber_tenantId?: TicketTicketNumberTenantIdCompoundUniqueInput
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    ticketNumber?: StringNullableFilter<"Ticket"> | string | null
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    tenantId?: UuidFilter<"Ticket"> | string
    customerId?: UuidFilter<"Ticket"> | string
    assignedToId?: UuidNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    accessories?: StringNullableFilter<"Ticket"> | string | null
    cancellationReason?: StringNullableFilter<"Ticket"> | string | null
    checkInNotes?: StringNullableFilter<"Ticket"> | string | null
    deviceModel?: StringNullableFilter<"Ticket"> | string | null
    deviceType?: StringNullableFilter<"Ticket"> | string | null
    serialNumber?: StringNullableFilter<"Ticket"> | string | null
    createdById?: UuidNullableFilter<"Ticket"> | string | null
    serviceTemplateId?: UuidNullableFilter<"Ticket"> | string | null
    updatedById?: UuidNullableFilter<"Ticket"> | string | null
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    dueDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    estimatedCompletionDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    attachments?: TicketAttachmentListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    partsUsed?: PartUsageListRelationFilter
    notes?: TicketNoteListRelationFilter
    services?: TicketServiceListRelationFilter
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    serviceTemplate?: XOR<ServiceTemplateNullableScalarRelationFilter, ServiceTemplateWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    viewedByUsers?: UserPresenceListRelationFilter
  }, "id" | "ticketNumber_tenantId">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    ticketNumber?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessories?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    checkInNotes?: SortOrderInput | SortOrder
    deviceModel?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    serviceTemplateId?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    estimatedCompletionDate?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Ticket"> | string
    ticketNumber?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    tenantId?: UuidWithAggregatesFilter<"Ticket"> | string
    customerId?: UuidWithAggregatesFilter<"Ticket"> | string
    assignedToId?: UuidNullableWithAggregatesFilter<"Ticket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    accessories?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    checkInNotes?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    deviceModel?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    createdById?: UuidNullableWithAggregatesFilter<"Ticket"> | string | null
    serviceTemplateId?: UuidNullableWithAggregatesFilter<"Ticket"> | string | null
    updatedById?: UuidNullableWithAggregatesFilter<"Ticket"> | string | null
    priority?: EnumTicketPriorityWithAggregatesFilter<"Ticket"> | $Enums.TicketPriority
    dueDate?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    estimatedCompletionDate?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
  }

  export type TicketAttachmentWhereInput = {
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    id?: UuidFilter<"TicketAttachment"> | string
    ticketId?: UuidFilter<"TicketAttachment"> | string
    filename?: StringFilter<"TicketAttachment"> | string
    originalName?: StringFilter<"TicketAttachment"> | string
    mimeType?: StringFilter<"TicketAttachment"> | string
    size?: IntFilter<"TicketAttachment"> | number
    url?: StringFilter<"TicketAttachment"> | string
    uploadedById?: UuidFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TicketAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type TicketAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    OR?: TicketAttachmentWhereInput[]
    NOT?: TicketAttachmentWhereInput | TicketAttachmentWhereInput[]
    ticketId?: UuidFilter<"TicketAttachment"> | string
    filename?: StringFilter<"TicketAttachment"> | string
    originalName?: StringFilter<"TicketAttachment"> | string
    mimeType?: StringFilter<"TicketAttachment"> | string
    size?: IntFilter<"TicketAttachment"> | number
    url?: StringFilter<"TicketAttachment"> | string
    uploadedById?: UuidFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TicketAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    _count?: TicketAttachmentCountOrderByAggregateInput
    _avg?: TicketAttachmentAvgOrderByAggregateInput
    _max?: TicketAttachmentMaxOrderByAggregateInput
    _min?: TicketAttachmentMinOrderByAggregateInput
    _sum?: TicketAttachmentSumOrderByAggregateInput
  }

  export type TicketAttachmentScalarWhereWithAggregatesInput = {
    AND?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    OR?: TicketAttachmentScalarWhereWithAggregatesInput[]
    NOT?: TicketAttachmentScalarWhereWithAggregatesInput | TicketAttachmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TicketAttachment"> | string
    ticketId?: UuidWithAggregatesFilter<"TicketAttachment"> | string
    filename?: StringWithAggregatesFilter<"TicketAttachment"> | string
    originalName?: StringWithAggregatesFilter<"TicketAttachment"> | string
    mimeType?: StringWithAggregatesFilter<"TicketAttachment"> | string
    size?: IntWithAggregatesFilter<"TicketAttachment"> | number
    url?: StringWithAggregatesFilter<"TicketAttachment"> | string
    uploadedById?: UuidWithAggregatesFilter<"TicketAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketAttachment"> | Date | string
  }

  export type PartWhereInput = {
    AND?: PartWhereInput | PartWhereInput[]
    OR?: PartWhereInput[]
    NOT?: PartWhereInput | PartWhereInput[]
    id?: UuidFilter<"Part"> | string
    name?: StringFilter<"Part"> | string
    sku?: StringNullableFilter<"Part"> | string | null
    quantity?: IntFilter<"Part"> | number
    cost?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    tenantId?: UuidFilter<"Part"> | string
    createdAt?: DateTimeFilter<"Part"> | Date | string
    updatedAt?: DateTimeFilter<"Part"> | Date | string
    createdById?: UuidNullableFilter<"Part"> | string | null
    updatedById?: UuidNullableFilter<"Part"> | string | null
    category?: StringNullableFilter<"Part"> | string | null
    location?: StringNullableFilter<"Part"> | string | null
    minStock?: IntFilter<"Part"> | number
    creditNoteItems?: CreditNoteItemListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    posQuotationItems?: POSQuotationItemListRelationFilter
    posSaleItems?: POSSaleItemListRelationFilter
    purchaseItems?: PurchaseItemListRelationFilter
    templateDefaultParts?: TemplateDefaultPartListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    usages?: PartUsageListRelationFilter
  }

  export type PartOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrderInput | SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    minStock?: SortOrder
    creditNoteItems?: CreditNoteItemOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    posQuotationItems?: POSQuotationItemOrderByRelationAggregateInput
    posSaleItems?: POSSaleItemOrderByRelationAggregateInput
    purchaseItems?: PurchaseItemOrderByRelationAggregateInput
    templateDefaultParts?: TemplateDefaultPartOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    usages?: PartUsageOrderByRelationAggregateInput
  }

  export type PartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_sku_per_tenant?: PartUnique_sku_per_tenantCompoundUniqueInput
    AND?: PartWhereInput | PartWhereInput[]
    OR?: PartWhereInput[]
    NOT?: PartWhereInput | PartWhereInput[]
    name?: StringFilter<"Part"> | string
    sku?: StringNullableFilter<"Part"> | string | null
    quantity?: IntFilter<"Part"> | number
    cost?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    tenantId?: UuidFilter<"Part"> | string
    createdAt?: DateTimeFilter<"Part"> | Date | string
    updatedAt?: DateTimeFilter<"Part"> | Date | string
    createdById?: UuidNullableFilter<"Part"> | string | null
    updatedById?: UuidNullableFilter<"Part"> | string | null
    category?: StringNullableFilter<"Part"> | string | null
    location?: StringNullableFilter<"Part"> | string | null
    minStock?: IntFilter<"Part"> | number
    creditNoteItems?: CreditNoteItemListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    posQuotationItems?: POSQuotationItemListRelationFilter
    posSaleItems?: POSSaleItemListRelationFilter
    purchaseItems?: PurchaseItemListRelationFilter
    templateDefaultParts?: TemplateDefaultPartListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    usages?: PartUsageListRelationFilter
  }, "id" | "unique_sku_per_tenant">

  export type PartOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrderInput | SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    minStock?: SortOrder
    _count?: PartCountOrderByAggregateInput
    _avg?: PartAvgOrderByAggregateInput
    _max?: PartMaxOrderByAggregateInput
    _min?: PartMinOrderByAggregateInput
    _sum?: PartSumOrderByAggregateInput
  }

  export type PartScalarWhereWithAggregatesInput = {
    AND?: PartScalarWhereWithAggregatesInput | PartScalarWhereWithAggregatesInput[]
    OR?: PartScalarWhereWithAggregatesInput[]
    NOT?: PartScalarWhereWithAggregatesInput | PartScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Part"> | string
    name?: StringWithAggregatesFilter<"Part"> | string
    sku?: StringNullableWithAggregatesFilter<"Part"> | string | null
    quantity?: IntWithAggregatesFilter<"Part"> | number
    cost?: DecimalWithAggregatesFilter<"Part"> | Decimal | DecimalJsLike | number | string
    price?: DecimalWithAggregatesFilter<"Part"> | Decimal | DecimalJsLike | number | string
    tenantId?: UuidWithAggregatesFilter<"Part"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Part"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Part"> | Date | string
    createdById?: UuidNullableWithAggregatesFilter<"Part"> | string | null
    updatedById?: UuidNullableWithAggregatesFilter<"Part"> | string | null
    category?: StringNullableWithAggregatesFilter<"Part"> | string | null
    location?: StringNullableWithAggregatesFilter<"Part"> | string | null
    minStock?: IntWithAggregatesFilter<"Part"> | number
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: UuidFilter<"PurchaseOrder"> | string
    supplier?: StringFilter<"PurchaseOrder"> | string
    status?: EnumPurchaseStatusFilter<"PurchaseOrder"> | $Enums.PurchaseStatus
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    totalCost?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tenantId?: UuidFilter<"PurchaseOrder"> | string
    createdById?: UuidNullableFilter<"PurchaseOrder"> | string | null
    updatedById?: UuidNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    items?: PurchaseItemListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    supplier?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    receivedDate?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: PurchaseItemOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    supplier?: StringFilter<"PurchaseOrder"> | string
    status?: EnumPurchaseStatusFilter<"PurchaseOrder"> | $Enums.PurchaseStatus
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    totalCost?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tenantId?: UuidFilter<"PurchaseOrder"> | string
    createdById?: UuidNullableFilter<"PurchaseOrder"> | string | null
    updatedById?: UuidNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    items?: PurchaseItemListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    supplier?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    receivedDate?: SortOrderInput | SortOrder
    totalCost?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PurchaseOrder"> | string
    supplier?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    status?: EnumPurchaseStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.PurchaseStatus
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    receivedDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    totalCost?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tenantId?: UuidWithAggregatesFilter<"PurchaseOrder"> | string
    createdById?: UuidNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    updatedById?: UuidNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseItemWhereInput = {
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    id?: UuidFilter<"PurchaseItem"> | string
    quantity?: IntFilter<"PurchaseItem"> | number
    unitCost?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    partId?: UuidFilter<"PurchaseItem"> | string
    purchaseOrderId?: UuidFilter<"PurchaseItem"> | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
  }

  export type PurchaseItemOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    partId?: SortOrder
    purchaseOrderId?: SortOrder
    part?: PartOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
  }

  export type PurchaseItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    OR?: PurchaseItemWhereInput[]
    NOT?: PurchaseItemWhereInput | PurchaseItemWhereInput[]
    quantity?: IntFilter<"PurchaseItem"> | number
    unitCost?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    partId?: UuidFilter<"PurchaseItem"> | string
    purchaseOrderId?: UuidFilter<"PurchaseItem"> | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
  }, "id">

  export type PurchaseItemOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    partId?: SortOrder
    purchaseOrderId?: SortOrder
    _count?: PurchaseItemCountOrderByAggregateInput
    _avg?: PurchaseItemAvgOrderByAggregateInput
    _max?: PurchaseItemMaxOrderByAggregateInput
    _min?: PurchaseItemMinOrderByAggregateInput
    _sum?: PurchaseItemSumOrderByAggregateInput
  }

  export type PurchaseItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseItemScalarWhereWithAggregatesInput | PurchaseItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PurchaseItem"> | string
    quantity?: IntWithAggregatesFilter<"PurchaseItem"> | number
    unitCost?: DecimalWithAggregatesFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    partId?: UuidWithAggregatesFilter<"PurchaseItem"> | string
    purchaseOrderId?: UuidWithAggregatesFilter<"PurchaseItem"> | string
  }

  export type PartUsageWhereInput = {
    AND?: PartUsageWhereInput | PartUsageWhereInput[]
    OR?: PartUsageWhereInput[]
    NOT?: PartUsageWhereInput | PartUsageWhereInput[]
    id?: UuidFilter<"PartUsage"> | string
    quantity?: IntFilter<"PartUsage"> | number
    ticketId?: UuidFilter<"PartUsage"> | string
    partId?: UuidFilter<"PartUsage"> | string
    createdAt?: DateTimeFilter<"PartUsage"> | Date | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type PartUsageOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    ticketId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
    part?: PartOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type PartUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartUsageWhereInput | PartUsageWhereInput[]
    OR?: PartUsageWhereInput[]
    NOT?: PartUsageWhereInput | PartUsageWhereInput[]
    quantity?: IntFilter<"PartUsage"> | number
    ticketId?: UuidFilter<"PartUsage"> | string
    partId?: UuidFilter<"PartUsage"> | string
    createdAt?: DateTimeFilter<"PartUsage"> | Date | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type PartUsageOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    ticketId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
    _count?: PartUsageCountOrderByAggregateInput
    _avg?: PartUsageAvgOrderByAggregateInput
    _max?: PartUsageMaxOrderByAggregateInput
    _min?: PartUsageMinOrderByAggregateInput
    _sum?: PartUsageSumOrderByAggregateInput
  }

  export type PartUsageScalarWhereWithAggregatesInput = {
    AND?: PartUsageScalarWhereWithAggregatesInput | PartUsageScalarWhereWithAggregatesInput[]
    OR?: PartUsageScalarWhereWithAggregatesInput[]
    NOT?: PartUsageScalarWhereWithAggregatesInput | PartUsageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PartUsage"> | string
    quantity?: IntWithAggregatesFilter<"PartUsage"> | number
    ticketId?: UuidWithAggregatesFilter<"PartUsage"> | string
    partId?: UuidWithAggregatesFilter<"PartUsage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PartUsage"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    tenantId?: UuidFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    module?: EnumAuditModuleFilter<"AuditLog"> | $Enums.AuditModule
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    success?: BoolFilter<"AuditLog"> | boolean
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    details?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    details?: StringNullableFilter<"AuditLog"> | string | null
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    tenantId?: UuidFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    module?: EnumAuditModuleFilter<"AuditLog"> | $Enums.AuditModule
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    success?: BoolFilter<"AuditLog"> | boolean
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    details?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    tenantId?: UuidWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    module?: EnumAuditModuleWithAggregatesFilter<"AuditLog"> | $Enums.AuditModule
    entityType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    success?: BoolWithAggregatesFilter<"AuditLog"> | boolean
  }

  export type TicketNoteWhereInput = {
    AND?: TicketNoteWhereInput | TicketNoteWhereInput[]
    OR?: TicketNoteWhereInput[]
    NOT?: TicketNoteWhereInput | TicketNoteWhereInput[]
    id?: UuidFilter<"TicketNote"> | string
    content?: StringFilter<"TicketNote"> | string
    isInternal?: BoolFilter<"TicketNote"> | boolean
    ticketId?: UuidFilter<"TicketNote"> | string
    authorId?: UuidFilter<"TicketNote"> | string
    createdAt?: DateTimeFilter<"TicketNote"> | Date | string
    updatedAt?: DateTimeFilter<"TicketNote"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type TicketNoteOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketNoteWhereInput | TicketNoteWhereInput[]
    OR?: TicketNoteWhereInput[]
    NOT?: TicketNoteWhereInput | TicketNoteWhereInput[]
    content?: StringFilter<"TicketNote"> | string
    isInternal?: BoolFilter<"TicketNote"> | boolean
    ticketId?: UuidFilter<"TicketNote"> | string
    authorId?: UuidFilter<"TicketNote"> | string
    createdAt?: DateTimeFilter<"TicketNote"> | Date | string
    updatedAt?: DateTimeFilter<"TicketNote"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketNoteOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketNoteCountOrderByAggregateInput
    _max?: TicketNoteMaxOrderByAggregateInput
    _min?: TicketNoteMinOrderByAggregateInput
  }

  export type TicketNoteScalarWhereWithAggregatesInput = {
    AND?: TicketNoteScalarWhereWithAggregatesInput | TicketNoteScalarWhereWithAggregatesInput[]
    OR?: TicketNoteScalarWhereWithAggregatesInput[]
    NOT?: TicketNoteScalarWhereWithAggregatesInput | TicketNoteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TicketNote"> | string
    content?: StringWithAggregatesFilter<"TicketNote"> | string
    isInternal?: BoolWithAggregatesFilter<"TicketNote"> | boolean
    ticketId?: UuidWithAggregatesFilter<"TicketNote"> | string
    authorId?: UuidWithAggregatesFilter<"TicketNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketNote"> | Date | string
  }

  export type ServiceTemplateWhereInput = {
    AND?: ServiceTemplateWhereInput | ServiceTemplateWhereInput[]
    OR?: ServiceTemplateWhereInput[]
    NOT?: ServiceTemplateWhereInput | ServiceTemplateWhereInput[]
    id?: UuidFilter<"ServiceTemplate"> | string
    name?: StringFilter<"ServiceTemplate"> | string
    category?: EnumServiceCategoryFilter<"ServiceTemplate"> | $Enums.ServiceCategory
    defaultTitle?: StringFilter<"ServiceTemplate"> | string
    defaultDescription?: StringFilter<"ServiceTemplate"> | string
    defaultPriority?: StringFilter<"ServiceTemplate"> | string
    estimatedDuration?: IntNullableFilter<"ServiceTemplate"> | number | null
    laborCost?: DecimalNullableFilter<"ServiceTemplate"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ServiceTemplate"> | boolean
    color?: StringNullableFilter<"ServiceTemplate"> | string | null
    icon?: StringNullableFilter<"ServiceTemplate"> | string | null
    tenantId?: UuidFilter<"ServiceTemplate"> | string
    createdById?: UuidNullableFilter<"ServiceTemplate"> | string | null
    updatedById?: UuidNullableFilter<"ServiceTemplate"> | string | null
    createdAt?: DateTimeFilter<"ServiceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTemplate"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    defaultParts?: TemplateDefaultPartListRelationFilter
    usages?: TicketServiceListRelationFilter
    tickets?: TicketListRelationFilter
  }

  export type ServiceTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultTitle?: SortOrder
    defaultDescription?: SortOrder
    defaultPriority?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    laborCost?: SortOrderInput | SortOrder
    isActive?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    defaultParts?: TemplateDefaultPartOrderByRelationAggregateInput
    usages?: TicketServiceOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type ServiceTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceTemplateWhereInput | ServiceTemplateWhereInput[]
    OR?: ServiceTemplateWhereInput[]
    NOT?: ServiceTemplateWhereInput | ServiceTemplateWhereInput[]
    name?: StringFilter<"ServiceTemplate"> | string
    category?: EnumServiceCategoryFilter<"ServiceTemplate"> | $Enums.ServiceCategory
    defaultTitle?: StringFilter<"ServiceTemplate"> | string
    defaultDescription?: StringFilter<"ServiceTemplate"> | string
    defaultPriority?: StringFilter<"ServiceTemplate"> | string
    estimatedDuration?: IntNullableFilter<"ServiceTemplate"> | number | null
    laborCost?: DecimalNullableFilter<"ServiceTemplate"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ServiceTemplate"> | boolean
    color?: StringNullableFilter<"ServiceTemplate"> | string | null
    icon?: StringNullableFilter<"ServiceTemplate"> | string | null
    tenantId?: UuidFilter<"ServiceTemplate"> | string
    createdById?: UuidNullableFilter<"ServiceTemplate"> | string | null
    updatedById?: UuidNullableFilter<"ServiceTemplate"> | string | null
    createdAt?: DateTimeFilter<"ServiceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTemplate"> | Date | string
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    defaultParts?: TemplateDefaultPartListRelationFilter
    usages?: TicketServiceListRelationFilter
    tickets?: TicketListRelationFilter
  }, "id">

  export type ServiceTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultTitle?: SortOrder
    defaultDescription?: SortOrder
    defaultPriority?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    laborCost?: SortOrderInput | SortOrder
    isActive?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceTemplateCountOrderByAggregateInput
    _avg?: ServiceTemplateAvgOrderByAggregateInput
    _max?: ServiceTemplateMaxOrderByAggregateInput
    _min?: ServiceTemplateMinOrderByAggregateInput
    _sum?: ServiceTemplateSumOrderByAggregateInput
  }

  export type ServiceTemplateScalarWhereWithAggregatesInput = {
    AND?: ServiceTemplateScalarWhereWithAggregatesInput | ServiceTemplateScalarWhereWithAggregatesInput[]
    OR?: ServiceTemplateScalarWhereWithAggregatesInput[]
    NOT?: ServiceTemplateScalarWhereWithAggregatesInput | ServiceTemplateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ServiceTemplate"> | string
    name?: StringWithAggregatesFilter<"ServiceTemplate"> | string
    category?: EnumServiceCategoryWithAggregatesFilter<"ServiceTemplate"> | $Enums.ServiceCategory
    defaultTitle?: StringWithAggregatesFilter<"ServiceTemplate"> | string
    defaultDescription?: StringWithAggregatesFilter<"ServiceTemplate"> | string
    defaultPriority?: StringWithAggregatesFilter<"ServiceTemplate"> | string
    estimatedDuration?: IntNullableWithAggregatesFilter<"ServiceTemplate"> | number | null
    laborCost?: DecimalNullableWithAggregatesFilter<"ServiceTemplate"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"ServiceTemplate"> | boolean
    color?: StringNullableWithAggregatesFilter<"ServiceTemplate"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ServiceTemplate"> | string | null
    tenantId?: UuidWithAggregatesFilter<"ServiceTemplate"> | string
    createdById?: UuidNullableWithAggregatesFilter<"ServiceTemplate"> | string | null
    updatedById?: UuidNullableWithAggregatesFilter<"ServiceTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceTemplate"> | Date | string
  }

  export type TemplateDefaultPartWhereInput = {
    AND?: TemplateDefaultPartWhereInput | TemplateDefaultPartWhereInput[]
    OR?: TemplateDefaultPartWhereInput[]
    NOT?: TemplateDefaultPartWhereInput | TemplateDefaultPartWhereInput[]
    id?: UuidFilter<"TemplateDefaultPart"> | string
    quantity?: IntFilter<"TemplateDefaultPart"> | number
    required?: BoolFilter<"TemplateDefaultPart"> | boolean
    templateId?: UuidFilter<"TemplateDefaultPart"> | string
    partId?: UuidFilter<"TemplateDefaultPart"> | string
    createdAt?: DateTimeFilter<"TemplateDefaultPart"> | Date | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    template?: XOR<ServiceTemplateScalarRelationFilter, ServiceTemplateWhereInput>
  }

  export type TemplateDefaultPartOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    required?: SortOrder
    templateId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
    part?: PartOrderByWithRelationInput
    template?: ServiceTemplateOrderByWithRelationInput
  }

  export type TemplateDefaultPartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateDefaultPartWhereInput | TemplateDefaultPartWhereInput[]
    OR?: TemplateDefaultPartWhereInput[]
    NOT?: TemplateDefaultPartWhereInput | TemplateDefaultPartWhereInput[]
    quantity?: IntFilter<"TemplateDefaultPart"> | number
    required?: BoolFilter<"TemplateDefaultPart"> | boolean
    templateId?: UuidFilter<"TemplateDefaultPart"> | string
    partId?: UuidFilter<"TemplateDefaultPart"> | string
    createdAt?: DateTimeFilter<"TemplateDefaultPart"> | Date | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    template?: XOR<ServiceTemplateScalarRelationFilter, ServiceTemplateWhereInput>
  }, "id">

  export type TemplateDefaultPartOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    required?: SortOrder
    templateId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
    _count?: TemplateDefaultPartCountOrderByAggregateInput
    _avg?: TemplateDefaultPartAvgOrderByAggregateInput
    _max?: TemplateDefaultPartMaxOrderByAggregateInput
    _min?: TemplateDefaultPartMinOrderByAggregateInput
    _sum?: TemplateDefaultPartSumOrderByAggregateInput
  }

  export type TemplateDefaultPartScalarWhereWithAggregatesInput = {
    AND?: TemplateDefaultPartScalarWhereWithAggregatesInput | TemplateDefaultPartScalarWhereWithAggregatesInput[]
    OR?: TemplateDefaultPartScalarWhereWithAggregatesInput[]
    NOT?: TemplateDefaultPartScalarWhereWithAggregatesInput | TemplateDefaultPartScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TemplateDefaultPart"> | string
    quantity?: IntWithAggregatesFilter<"TemplateDefaultPart"> | number
    required?: BoolWithAggregatesFilter<"TemplateDefaultPart"> | boolean
    templateId?: UuidWithAggregatesFilter<"TemplateDefaultPart"> | string
    partId?: UuidWithAggregatesFilter<"TemplateDefaultPart"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TemplateDefaultPart"> | Date | string
  }

  export type TicketServiceWhereInput = {
    AND?: TicketServiceWhereInput | TicketServiceWhereInput[]
    OR?: TicketServiceWhereInput[]
    NOT?: TicketServiceWhereInput | TicketServiceWhereInput[]
    id?: UuidFilter<"TicketService"> | string
    ticketId?: UuidFilter<"TicketService"> | string
    serviceId?: UuidFilter<"TicketService"> | string
    name?: StringFilter<"TicketService"> | string
    laborCost?: DecimalFilter<"TicketService"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TicketService"> | Date | string
    service?: XOR<ServiceTemplateScalarRelationFilter, ServiceTemplateWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }

  export type TicketServiceOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    laborCost?: SortOrder
    createdAt?: SortOrder
    service?: ServiceTemplateOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
  }

  export type TicketServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketServiceWhereInput | TicketServiceWhereInput[]
    OR?: TicketServiceWhereInput[]
    NOT?: TicketServiceWhereInput | TicketServiceWhereInput[]
    ticketId?: UuidFilter<"TicketService"> | string
    serviceId?: UuidFilter<"TicketService"> | string
    name?: StringFilter<"TicketService"> | string
    laborCost?: DecimalFilter<"TicketService"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TicketService"> | Date | string
    service?: XOR<ServiceTemplateScalarRelationFilter, ServiceTemplateWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
  }, "id">

  export type TicketServiceOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    laborCost?: SortOrder
    createdAt?: SortOrder
    _count?: TicketServiceCountOrderByAggregateInput
    _avg?: TicketServiceAvgOrderByAggregateInput
    _max?: TicketServiceMaxOrderByAggregateInput
    _min?: TicketServiceMinOrderByAggregateInput
    _sum?: TicketServiceSumOrderByAggregateInput
  }

  export type TicketServiceScalarWhereWithAggregatesInput = {
    AND?: TicketServiceScalarWhereWithAggregatesInput | TicketServiceScalarWhereWithAggregatesInput[]
    OR?: TicketServiceScalarWhereWithAggregatesInput[]
    NOT?: TicketServiceScalarWhereWithAggregatesInput | TicketServiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TicketService"> | string
    ticketId?: UuidWithAggregatesFilter<"TicketService"> | string
    serviceId?: UuidWithAggregatesFilter<"TicketService"> | string
    name?: StringWithAggregatesFilter<"TicketService"> | string
    laborCost?: DecimalWithAggregatesFilter<"TicketService"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketService"> | Date | string
  }

  export type TechnicianSpecializationWhereInput = {
    AND?: TechnicianSpecializationWhereInput | TechnicianSpecializationWhereInput[]
    OR?: TechnicianSpecializationWhereInput[]
    NOT?: TechnicianSpecializationWhereInput | TechnicianSpecializationWhereInput[]
    id?: UuidFilter<"TechnicianSpecialization"> | string
    userId?: UuidFilter<"TechnicianSpecialization"> | string
    specialization?: EnumSpecializationFilter<"TechnicianSpecialization"> | $Enums.Specialization
    createdAt?: DateTimeFilter<"TechnicianSpecialization"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TechnicianSpecializationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TechnicianSpecializationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_specialization?: TechnicianSpecializationUserIdSpecializationCompoundUniqueInput
    AND?: TechnicianSpecializationWhereInput | TechnicianSpecializationWhereInput[]
    OR?: TechnicianSpecializationWhereInput[]
    NOT?: TechnicianSpecializationWhereInput | TechnicianSpecializationWhereInput[]
    userId?: UuidFilter<"TechnicianSpecialization"> | string
    specialization?: EnumSpecializationFilter<"TechnicianSpecialization"> | $Enums.Specialization
    createdAt?: DateTimeFilter<"TechnicianSpecialization"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_specialization">

  export type TechnicianSpecializationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    createdAt?: SortOrder
    _count?: TechnicianSpecializationCountOrderByAggregateInput
    _max?: TechnicianSpecializationMaxOrderByAggregateInput
    _min?: TechnicianSpecializationMinOrderByAggregateInput
  }

  export type TechnicianSpecializationScalarWhereWithAggregatesInput = {
    AND?: TechnicianSpecializationScalarWhereWithAggregatesInput | TechnicianSpecializationScalarWhereWithAggregatesInput[]
    OR?: TechnicianSpecializationScalarWhereWithAggregatesInput[]
    NOT?: TechnicianSpecializationScalarWhereWithAggregatesInput | TechnicianSpecializationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TechnicianSpecialization"> | string
    userId?: UuidWithAggregatesFilter<"TechnicianSpecialization"> | string
    specialization?: EnumSpecializationWithAggregatesFilter<"TechnicianSpecialization"> | $Enums.Specialization
    createdAt?: DateTimeWithAggregatesFilter<"TechnicianSpecialization"> | Date | string
  }

  export type TechnicianUnavailabilityWhereInput = {
    AND?: TechnicianUnavailabilityWhereInput | TechnicianUnavailabilityWhereInput[]
    OR?: TechnicianUnavailabilityWhereInput[]
    NOT?: TechnicianUnavailabilityWhereInput | TechnicianUnavailabilityWhereInput[]
    id?: UuidFilter<"TechnicianUnavailability"> | string
    reason?: EnumTechnicianStatusFilter<"TechnicianUnavailability"> | $Enums.TechnicianStatus
    notes?: StringNullableFilter<"TechnicianUnavailability"> | string | null
    userId?: UuidFilter<"TechnicianUnavailability"> | string
    startDate?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    endDate?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    isActive?: BoolFilter<"TechnicianUnavailability"> | boolean
    createdAt?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    updatedAt?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TechnicianUnavailabilityOrderByWithRelationInput = {
    id?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TechnicianUnavailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TechnicianUnavailabilityWhereInput | TechnicianUnavailabilityWhereInput[]
    OR?: TechnicianUnavailabilityWhereInput[]
    NOT?: TechnicianUnavailabilityWhereInput | TechnicianUnavailabilityWhereInput[]
    reason?: EnumTechnicianStatusFilter<"TechnicianUnavailability"> | $Enums.TechnicianStatus
    notes?: StringNullableFilter<"TechnicianUnavailability"> | string | null
    userId?: UuidFilter<"TechnicianUnavailability"> | string
    startDate?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    endDate?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    isActive?: BoolFilter<"TechnicianUnavailability"> | boolean
    createdAt?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    updatedAt?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TechnicianUnavailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TechnicianUnavailabilityCountOrderByAggregateInput
    _max?: TechnicianUnavailabilityMaxOrderByAggregateInput
    _min?: TechnicianUnavailabilityMinOrderByAggregateInput
  }

  export type TechnicianUnavailabilityScalarWhereWithAggregatesInput = {
    AND?: TechnicianUnavailabilityScalarWhereWithAggregatesInput | TechnicianUnavailabilityScalarWhereWithAggregatesInput[]
    OR?: TechnicianUnavailabilityScalarWhereWithAggregatesInput[]
    NOT?: TechnicianUnavailabilityScalarWhereWithAggregatesInput | TechnicianUnavailabilityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TechnicianUnavailability"> | string
    reason?: EnumTechnicianStatusWithAggregatesFilter<"TechnicianUnavailability"> | $Enums.TechnicianStatus
    notes?: StringNullableWithAggregatesFilter<"TechnicianUnavailability"> | string | null
    userId?: UuidWithAggregatesFilter<"TechnicianUnavailability"> | string
    startDate?: DateTimeWithAggregatesFilter<"TechnicianUnavailability"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"TechnicianUnavailability"> | Date | string
    isActive?: BoolWithAggregatesFilter<"TechnicianUnavailability"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TechnicianUnavailability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TechnicianUnavailability"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    tenantId?: UuidFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    tenantId?: UuidFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    userId?: UuidWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    tenantId?: UuidWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    ticketId?: UuidFilter<"Invoice"> | string
    customerId?: UuidFilter<"Invoice"> | string
    laborCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    customerName?: StringFilter<"Invoice"> | string
    customerNIT?: StringNullableFilter<"Invoice"> | string | null
    customerDPI?: StringNullableFilter<"Invoice"> | string | null
    customerAddress?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    dueAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    tenantId?: UuidFilter<"Invoice"> | string
    createdById?: UuidFilter<"Invoice"> | string
    updatedById?: UuidFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    history?: InvoiceHistoryListRelationFilter
    payments?: PaymentListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    ticketId?: SortOrder
    customerId?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    partsMarkup?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    customerName?: SortOrder
    customerNIT?: SortOrderInput | SortOrder
    customerDPI?: SortOrderInput | SortOrder
    customerAddress?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    dueAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    history?: InvoiceHistoryOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    ticket?: TicketOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticketId?: string
    unique_invoice_number_per_tenant?: InvoiceUnique_invoice_number_per_tenantCompoundUniqueInput
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    customerId?: UuidFilter<"Invoice"> | string
    laborCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    customerName?: StringFilter<"Invoice"> | string
    customerNIT?: StringNullableFilter<"Invoice"> | string | null
    customerDPI?: StringNullableFilter<"Invoice"> | string | null
    customerAddress?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    dueAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    tenantId?: UuidFilter<"Invoice"> | string
    createdById?: UuidFilter<"Invoice"> | string
    updatedById?: UuidFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    history?: InvoiceHistoryListRelationFilter
    payments?: PaymentListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    updatedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "ticketId" | "unique_invoice_number_per_tenant">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    ticketId?: SortOrder
    customerId?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    partsMarkup?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    customerName?: SortOrder
    customerNIT?: SortOrderInput | SortOrder
    customerDPI?: SortOrderInput | SortOrder
    customerAddress?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    dueAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    ticketId?: UuidWithAggregatesFilter<"Invoice"> | string
    customerId?: UuidWithAggregatesFilter<"Invoice"> | string
    laborCost?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    customerName?: StringWithAggregatesFilter<"Invoice"> | string
    customerNIT?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customerDPI?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customerAddress?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    issuedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    tenantId?: UuidWithAggregatesFilter<"Invoice"> | string
    createdById?: UuidWithAggregatesFilter<"Invoice"> | string
    updatedById?: UuidWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    paymentNumber?: StringFilter<"Payment"> | string
    invoiceId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    tenantId?: UuidFilter<"Payment"> | string
    receivedById?: UuidFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    receivedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    paidAt?: SortOrder
    tenantId?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    receivedBy?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_payment_number_per_tenant?: PaymentUnique_payment_number_per_tenantCompoundUniqueInput
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    paymentNumber?: StringFilter<"Payment"> | string
    invoiceId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    tenantId?: UuidFilter<"Payment"> | string
    receivedById?: UuidFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    receivedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "unique_payment_number_per_tenant">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    paidAt?: SortOrder
    tenantId?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    paymentNumber?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: UuidWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    transactionRef?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paidAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    tenantId?: UuidWithAggregatesFilter<"Payment"> | string
    receivedById?: UuidWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type CashRegisterWhereInput = {
    AND?: CashRegisterWhereInput | CashRegisterWhereInput[]
    OR?: CashRegisterWhereInput[]
    NOT?: CashRegisterWhereInput | CashRegisterWhereInput[]
    id?: UuidFilter<"CashRegister"> | string
    name?: StringFilter<"CashRegister"> | string
    isOpen?: BoolFilter<"CashRegister"> | boolean
    openedAt?: DateTimeNullableFilter<"CashRegister"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"CashRegister"> | Date | string | null
    openingBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    difference?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    closingNotes?: StringNullableFilter<"CashRegister"> | string | null
    tenantId?: UuidFilter<"CashRegister"> | string
    openedById?: UuidNullableFilter<"CashRegister"> | string | null
    closedById?: UuidNullableFilter<"CashRegister"> | string | null
    createdAt?: DateTimeFilter<"CashRegister"> | Date | string
    updatedAt?: DateTimeFilter<"CashRegister"> | Date | string
    closedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    openedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    posSales?: POSSaleListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    transactions?: CashTransactionListRelationFilter
  }

  export type CashRegisterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isOpen?: SortOrder
    openedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    expectedBalance?: SortOrder
    difference?: SortOrder
    closingNotes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    openedById?: SortOrderInput | SortOrder
    closedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedBy?: UserOrderByWithRelationInput
    openedBy?: UserOrderByWithRelationInput
    posSales?: POSSaleOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    transactions?: CashTransactionOrderByRelationAggregateInput
  }

  export type CashRegisterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashRegisterWhereInput | CashRegisterWhereInput[]
    OR?: CashRegisterWhereInput[]
    NOT?: CashRegisterWhereInput | CashRegisterWhereInput[]
    name?: StringFilter<"CashRegister"> | string
    isOpen?: BoolFilter<"CashRegister"> | boolean
    openedAt?: DateTimeNullableFilter<"CashRegister"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"CashRegister"> | Date | string | null
    openingBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    difference?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    closingNotes?: StringNullableFilter<"CashRegister"> | string | null
    tenantId?: UuidFilter<"CashRegister"> | string
    openedById?: UuidNullableFilter<"CashRegister"> | string | null
    closedById?: UuidNullableFilter<"CashRegister"> | string | null
    createdAt?: DateTimeFilter<"CashRegister"> | Date | string
    updatedAt?: DateTimeFilter<"CashRegister"> | Date | string
    closedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    openedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    posSales?: POSSaleListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    transactions?: CashTransactionListRelationFilter
  }, "id">

  export type CashRegisterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isOpen?: SortOrder
    openedAt?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    expectedBalance?: SortOrder
    difference?: SortOrder
    closingNotes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    openedById?: SortOrderInput | SortOrder
    closedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CashRegisterCountOrderByAggregateInput
    _avg?: CashRegisterAvgOrderByAggregateInput
    _max?: CashRegisterMaxOrderByAggregateInput
    _min?: CashRegisterMinOrderByAggregateInput
    _sum?: CashRegisterSumOrderByAggregateInput
  }

  export type CashRegisterScalarWhereWithAggregatesInput = {
    AND?: CashRegisterScalarWhereWithAggregatesInput | CashRegisterScalarWhereWithAggregatesInput[]
    OR?: CashRegisterScalarWhereWithAggregatesInput[]
    NOT?: CashRegisterScalarWhereWithAggregatesInput | CashRegisterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CashRegister"> | string
    name?: StringWithAggregatesFilter<"CashRegister"> | string
    isOpen?: BoolWithAggregatesFilter<"CashRegister"> | boolean
    openedAt?: DateTimeNullableWithAggregatesFilter<"CashRegister"> | Date | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"CashRegister"> | Date | string | null
    openingBalance?: DecimalWithAggregatesFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalWithAggregatesFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalWithAggregatesFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    difference?: DecimalWithAggregatesFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    closingNotes?: StringNullableWithAggregatesFilter<"CashRegister"> | string | null
    tenantId?: UuidWithAggregatesFilter<"CashRegister"> | string
    openedById?: UuidNullableWithAggregatesFilter<"CashRegister"> | string | null
    closedById?: UuidNullableWithAggregatesFilter<"CashRegister"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CashRegister"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashRegister"> | Date | string
  }

  export type CashTransactionWhereInput = {
    AND?: CashTransactionWhereInput | CashTransactionWhereInput[]
    OR?: CashTransactionWhereInput[]
    NOT?: CashTransactionWhereInput | CashTransactionWhereInput[]
    id?: UuidFilter<"CashTransaction"> | string
    type?: StringFilter<"CashTransaction"> | string
    amount?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"CashTransaction"> | string
    reference?: StringNullableFilter<"CashTransaction"> | string | null
    cashRegisterId?: UuidFilter<"CashTransaction"> | string
    tenantId?: UuidFilter<"CashTransaction"> | string
    createdById?: UuidFilter<"CashTransaction"> | string
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    cashRegister?: XOR<CashRegisterScalarRelationFilter, CashRegisterWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type CashTransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    reference?: SortOrderInput | SortOrder
    cashRegisterId?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    cashRegister?: CashRegisterOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type CashTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashTransactionWhereInput | CashTransactionWhereInput[]
    OR?: CashTransactionWhereInput[]
    NOT?: CashTransactionWhereInput | CashTransactionWhereInput[]
    type?: StringFilter<"CashTransaction"> | string
    amount?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"CashTransaction"> | string
    reference?: StringNullableFilter<"CashTransaction"> | string | null
    cashRegisterId?: UuidFilter<"CashTransaction"> | string
    tenantId?: UuidFilter<"CashTransaction"> | string
    createdById?: UuidFilter<"CashTransaction"> | string
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    cashRegister?: XOR<CashRegisterScalarRelationFilter, CashRegisterWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type CashTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    reference?: SortOrderInput | SortOrder
    cashRegisterId?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: CashTransactionCountOrderByAggregateInput
    _avg?: CashTransactionAvgOrderByAggregateInput
    _max?: CashTransactionMaxOrderByAggregateInput
    _min?: CashTransactionMinOrderByAggregateInput
    _sum?: CashTransactionSumOrderByAggregateInput
  }

  export type CashTransactionScalarWhereWithAggregatesInput = {
    AND?: CashTransactionScalarWhereWithAggregatesInput | CashTransactionScalarWhereWithAggregatesInput[]
    OR?: CashTransactionScalarWhereWithAggregatesInput[]
    NOT?: CashTransactionScalarWhereWithAggregatesInput | CashTransactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CashTransaction"> | string
    type?: StringWithAggregatesFilter<"CashTransaction"> | string
    amount?: DecimalWithAggregatesFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"CashTransaction"> | string
    reference?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    cashRegisterId?: UuidWithAggregatesFilter<"CashTransaction"> | string
    tenantId?: UuidWithAggregatesFilter<"CashTransaction"> | string
    createdById?: UuidWithAggregatesFilter<"CashTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CashTransaction"> | Date | string
  }

  export type TenantSettingsWhereInput = {
    AND?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    OR?: TenantSettingsWhereInput[]
    NOT?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    id?: UuidFilter<"TenantSettings"> | string
    tenantId?: UuidFilter<"TenantSettings"> | string
    businessName?: StringNullableFilter<"TenantSettings"> | string | null
    businessNIT?: StringNullableFilter<"TenantSettings"> | string | null
    businessAddress?: StringNullableFilter<"TenantSettings"> | string | null
    businessPhone?: StringNullableFilter<"TenantSettings"> | string | null
    businessEmail?: StringNullableFilter<"TenantSettings"> | string | null
    taxRate?: DecimalFilter<"TenantSettings"> | Decimal | DecimalJsLike | number | string
    taxName?: StringFilter<"TenantSettings"> | string
    currency?: StringFilter<"TenantSettings"> | string
    defaultPaymentTerms?: StringNullableFilter<"TenantSettings"> | string | null
    invoiceFooter?: StringNullableFilter<"TenantSettings"> | string | null
    slaWarningPercent?: IntFilter<"TenantSettings"> | number
    slaCriticalPercent?: IntFilter<"TenantSettings"> | number
    slaEmailEnabled?: BoolFilter<"TenantSettings"> | boolean
    slaInAppEnabled?: BoolFilter<"TenantSettings"> | boolean
    createdAt?: DateTimeFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSettings"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantSettingsOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    businessName?: SortOrderInput | SortOrder
    businessNIT?: SortOrderInput | SortOrder
    businessAddress?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    businessEmail?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    taxName?: SortOrder
    currency?: SortOrder
    defaultPaymentTerms?: SortOrderInput | SortOrder
    invoiceFooter?: SortOrderInput | SortOrder
    slaWarningPercent?: SortOrder
    slaCriticalPercent?: SortOrder
    slaEmailEnabled?: SortOrder
    slaInAppEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    OR?: TenantSettingsWhereInput[]
    NOT?: TenantSettingsWhereInput | TenantSettingsWhereInput[]
    businessName?: StringNullableFilter<"TenantSettings"> | string | null
    businessNIT?: StringNullableFilter<"TenantSettings"> | string | null
    businessAddress?: StringNullableFilter<"TenantSettings"> | string | null
    businessPhone?: StringNullableFilter<"TenantSettings"> | string | null
    businessEmail?: StringNullableFilter<"TenantSettings"> | string | null
    taxRate?: DecimalFilter<"TenantSettings"> | Decimal | DecimalJsLike | number | string
    taxName?: StringFilter<"TenantSettings"> | string
    currency?: StringFilter<"TenantSettings"> | string
    defaultPaymentTerms?: StringNullableFilter<"TenantSettings"> | string | null
    invoiceFooter?: StringNullableFilter<"TenantSettings"> | string | null
    slaWarningPercent?: IntFilter<"TenantSettings"> | number
    slaCriticalPercent?: IntFilter<"TenantSettings"> | number
    slaEmailEnabled?: BoolFilter<"TenantSettings"> | boolean
    slaInAppEnabled?: BoolFilter<"TenantSettings"> | boolean
    createdAt?: DateTimeFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSettings"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    businessName?: SortOrderInput | SortOrder
    businessNIT?: SortOrderInput | SortOrder
    businessAddress?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    businessEmail?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    taxName?: SortOrder
    currency?: SortOrder
    defaultPaymentTerms?: SortOrderInput | SortOrder
    invoiceFooter?: SortOrderInput | SortOrder
    slaWarningPercent?: SortOrder
    slaCriticalPercent?: SortOrder
    slaEmailEnabled?: SortOrder
    slaInAppEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantSettingsCountOrderByAggregateInput
    _avg?: TenantSettingsAvgOrderByAggregateInput
    _max?: TenantSettingsMaxOrderByAggregateInput
    _min?: TenantSettingsMinOrderByAggregateInput
    _sum?: TenantSettingsSumOrderByAggregateInput
  }

  export type TenantSettingsScalarWhereWithAggregatesInput = {
    AND?: TenantSettingsScalarWhereWithAggregatesInput | TenantSettingsScalarWhereWithAggregatesInput[]
    OR?: TenantSettingsScalarWhereWithAggregatesInput[]
    NOT?: TenantSettingsScalarWhereWithAggregatesInput | TenantSettingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TenantSettings"> | string
    tenantId?: UuidWithAggregatesFilter<"TenantSettings"> | string
    businessName?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    businessNIT?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    businessAddress?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    businessPhone?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    businessEmail?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    taxRate?: DecimalWithAggregatesFilter<"TenantSettings"> | Decimal | DecimalJsLike | number | string
    taxName?: StringWithAggregatesFilter<"TenantSettings"> | string
    currency?: StringWithAggregatesFilter<"TenantSettings"> | string
    defaultPaymentTerms?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    invoiceFooter?: StringNullableWithAggregatesFilter<"TenantSettings"> | string | null
    slaWarningPercent?: IntWithAggregatesFilter<"TenantSettings"> | number
    slaCriticalPercent?: IntWithAggregatesFilter<"TenantSettings"> | number
    slaEmailEnabled?: BoolWithAggregatesFilter<"TenantSettings"> | boolean
    slaInAppEnabled?: BoolWithAggregatesFilter<"TenantSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TenantSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantSettings"> | Date | string
  }

  export type InvoiceHistoryWhereInput = {
    AND?: InvoiceHistoryWhereInput | InvoiceHistoryWhereInput[]
    OR?: InvoiceHistoryWhereInput[]
    NOT?: InvoiceHistoryWhereInput | InvoiceHistoryWhereInput[]
    id?: UuidFilter<"InvoiceHistory"> | string
    invoiceId?: UuidFilter<"InvoiceHistory"> | string
    action?: StringFilter<"InvoiceHistory"> | string
    oldValue?: StringNullableFilter<"InvoiceHistory"> | string | null
    newValue?: StringNullableFilter<"InvoiceHistory"> | string | null
    notes?: StringNullableFilter<"InvoiceHistory"> | string | null
    userId?: UuidFilter<"InvoiceHistory"> | string
    createdAt?: DateTimeFilter<"InvoiceHistory"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvoiceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    action?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InvoiceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceHistoryWhereInput | InvoiceHistoryWhereInput[]
    OR?: InvoiceHistoryWhereInput[]
    NOT?: InvoiceHistoryWhereInput | InvoiceHistoryWhereInput[]
    invoiceId?: UuidFilter<"InvoiceHistory"> | string
    action?: StringFilter<"InvoiceHistory"> | string
    oldValue?: StringNullableFilter<"InvoiceHistory"> | string | null
    newValue?: StringNullableFilter<"InvoiceHistory"> | string | null
    notes?: StringNullableFilter<"InvoiceHistory"> | string | null
    userId?: UuidFilter<"InvoiceHistory"> | string
    createdAt?: DateTimeFilter<"InvoiceHistory"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InvoiceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    action?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: InvoiceHistoryCountOrderByAggregateInput
    _max?: InvoiceHistoryMaxOrderByAggregateInput
    _min?: InvoiceHistoryMinOrderByAggregateInput
  }

  export type InvoiceHistoryScalarWhereWithAggregatesInput = {
    AND?: InvoiceHistoryScalarWhereWithAggregatesInput | InvoiceHistoryScalarWhereWithAggregatesInput[]
    OR?: InvoiceHistoryScalarWhereWithAggregatesInput[]
    NOT?: InvoiceHistoryScalarWhereWithAggregatesInput | InvoiceHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InvoiceHistory"> | string
    invoiceId?: UuidWithAggregatesFilter<"InvoiceHistory"> | string
    action?: StringWithAggregatesFilter<"InvoiceHistory"> | string
    oldValue?: StringNullableWithAggregatesFilter<"InvoiceHistory"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"InvoiceHistory"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InvoiceHistory"> | string | null
    userId?: UuidWithAggregatesFilter<"InvoiceHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceHistory"> | Date | string
  }

  export type POSSaleWhereInput = {
    AND?: POSSaleWhereInput | POSSaleWhereInput[]
    OR?: POSSaleWhereInput[]
    NOT?: POSSaleWhereInput | POSSaleWhereInput[]
    id?: UuidFilter<"POSSale"> | string
    saleNumber?: StringFilter<"POSSale"> | string
    customerId?: UuidNullableFilter<"POSSale"> | string | null
    customerName?: StringFilter<"POSSale"> | string
    customerPhone?: StringNullableFilter<"POSSale"> | string | null
    customerEmail?: StringNullableFilter<"POSSale"> | string | null
    subtotal?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFilter<"POSSale"> | $Enums.POSSaleStatus
    notes?: StringNullableFilter<"POSSale"> | string | null
    tenantId?: UuidFilter<"POSSale"> | string
    cashRegisterId?: UuidNullableFilter<"POSSale"> | string | null
    createdById?: UuidFilter<"POSSale"> | string
    quotationId?: UuidNullableFilter<"POSSale"> | string | null
    createdAt?: DateTimeFilter<"POSSale"> | Date | string
    updatedAt?: DateTimeFilter<"POSSale"> | Date | string
    cashRegister?: XOR<CashRegisterNullableScalarRelationFilter, CashRegisterWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    creditNotes?: CreditNoteListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: POSSaleItemListRelationFilter
    payments?: POSSalePaymentListRelationFilter
    quotation?: XOR<POSQuotationNullableScalarRelationFilter, POSQuotationWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type POSSaleOrderByWithRelationInput = {
    id?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    amountPaid?: SortOrder
    changeGiven?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    cashRegisterId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    quotationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cashRegister?: CashRegisterOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    creditNotes?: CreditNoteOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    items?: POSSaleItemOrderByRelationAggregateInput
    payments?: POSSalePaymentOrderByRelationAggregateInput
    quotation?: POSQuotationOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type POSSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quotationId?: string
    saleNumber_tenantId?: POSSaleSaleNumberTenantIdCompoundUniqueInput
    AND?: POSSaleWhereInput | POSSaleWhereInput[]
    OR?: POSSaleWhereInput[]
    NOT?: POSSaleWhereInput | POSSaleWhereInput[]
    saleNumber?: StringFilter<"POSSale"> | string
    customerId?: UuidNullableFilter<"POSSale"> | string | null
    customerName?: StringFilter<"POSSale"> | string
    customerPhone?: StringNullableFilter<"POSSale"> | string | null
    customerEmail?: StringNullableFilter<"POSSale"> | string | null
    subtotal?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFilter<"POSSale"> | $Enums.POSSaleStatus
    notes?: StringNullableFilter<"POSSale"> | string | null
    tenantId?: UuidFilter<"POSSale"> | string
    cashRegisterId?: UuidNullableFilter<"POSSale"> | string | null
    createdById?: UuidFilter<"POSSale"> | string
    createdAt?: DateTimeFilter<"POSSale"> | Date | string
    updatedAt?: DateTimeFilter<"POSSale"> | Date | string
    cashRegister?: XOR<CashRegisterNullableScalarRelationFilter, CashRegisterWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    creditNotes?: CreditNoteListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: POSSaleItemListRelationFilter
    payments?: POSSalePaymentListRelationFilter
    quotation?: XOR<POSQuotationNullableScalarRelationFilter, POSQuotationWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "quotationId" | "saleNumber_tenantId">

  export type POSSaleOrderByWithAggregationInput = {
    id?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    amountPaid?: SortOrder
    changeGiven?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    cashRegisterId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    quotationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: POSSaleCountOrderByAggregateInput
    _avg?: POSSaleAvgOrderByAggregateInput
    _max?: POSSaleMaxOrderByAggregateInput
    _min?: POSSaleMinOrderByAggregateInput
    _sum?: POSSaleSumOrderByAggregateInput
  }

  export type POSSaleScalarWhereWithAggregatesInput = {
    AND?: POSSaleScalarWhereWithAggregatesInput | POSSaleScalarWhereWithAggregatesInput[]
    OR?: POSSaleScalarWhereWithAggregatesInput[]
    NOT?: POSSaleScalarWhereWithAggregatesInput | POSSaleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"POSSale"> | string
    saleNumber?: StringWithAggregatesFilter<"POSSale"> | string
    customerId?: UuidNullableWithAggregatesFilter<"POSSale"> | string | null
    customerName?: StringWithAggregatesFilter<"POSSale"> | string
    customerPhone?: StringNullableWithAggregatesFilter<"POSSale"> | string | null
    customerEmail?: StringNullableWithAggregatesFilter<"POSSale"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalWithAggregatesFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalWithAggregatesFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusWithAggregatesFilter<"POSSale"> | $Enums.POSSaleStatus
    notes?: StringNullableWithAggregatesFilter<"POSSale"> | string | null
    tenantId?: UuidWithAggregatesFilter<"POSSale"> | string
    cashRegisterId?: UuidNullableWithAggregatesFilter<"POSSale"> | string | null
    createdById?: UuidWithAggregatesFilter<"POSSale"> | string
    quotationId?: UuidNullableWithAggregatesFilter<"POSSale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"POSSale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"POSSale"> | Date | string
  }

  export type POSSaleItemWhereInput = {
    AND?: POSSaleItemWhereInput | POSSaleItemWhereInput[]
    OR?: POSSaleItemWhereInput[]
    NOT?: POSSaleItemWhereInput | POSSaleItemWhereInput[]
    id?: UuidFilter<"POSSaleItem"> | string
    saleId?: UuidFilter<"POSSaleItem"> | string
    partId?: UuidFilter<"POSSaleItem"> | string
    quantity?: IntFilter<"POSSaleItem"> | number
    unitPrice?: DecimalFilter<"POSSaleItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"POSSaleItem"> | Decimal | DecimalJsLike | number | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    sale?: XOR<POSSaleScalarRelationFilter, POSSaleWhereInput>
  }

  export type POSSaleItemOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    part?: PartOrderByWithRelationInput
    sale?: POSSaleOrderByWithRelationInput
  }

  export type POSSaleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: POSSaleItemWhereInput | POSSaleItemWhereInput[]
    OR?: POSSaleItemWhereInput[]
    NOT?: POSSaleItemWhereInput | POSSaleItemWhereInput[]
    saleId?: UuidFilter<"POSSaleItem"> | string
    partId?: UuidFilter<"POSSaleItem"> | string
    quantity?: IntFilter<"POSSaleItem"> | number
    unitPrice?: DecimalFilter<"POSSaleItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"POSSaleItem"> | Decimal | DecimalJsLike | number | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    sale?: XOR<POSSaleScalarRelationFilter, POSSaleWhereInput>
  }, "id">

  export type POSSaleItemOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    _count?: POSSaleItemCountOrderByAggregateInput
    _avg?: POSSaleItemAvgOrderByAggregateInput
    _max?: POSSaleItemMaxOrderByAggregateInput
    _min?: POSSaleItemMinOrderByAggregateInput
    _sum?: POSSaleItemSumOrderByAggregateInput
  }

  export type POSSaleItemScalarWhereWithAggregatesInput = {
    AND?: POSSaleItemScalarWhereWithAggregatesInput | POSSaleItemScalarWhereWithAggregatesInput[]
    OR?: POSSaleItemScalarWhereWithAggregatesInput[]
    NOT?: POSSaleItemScalarWhereWithAggregatesInput | POSSaleItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"POSSaleItem"> | string
    saleId?: UuidWithAggregatesFilter<"POSSaleItem"> | string
    partId?: UuidWithAggregatesFilter<"POSSaleItem"> | string
    quantity?: IntWithAggregatesFilter<"POSSaleItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"POSSaleItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"POSSaleItem"> | Decimal | DecimalJsLike | number | string
  }

  export type POSSalePaymentWhereInput = {
    AND?: POSSalePaymentWhereInput | POSSalePaymentWhereInput[]
    OR?: POSSalePaymentWhereInput[]
    NOT?: POSSalePaymentWhereInput | POSSalePaymentWhereInput[]
    id?: UuidFilter<"POSSalePayment"> | string
    saleId?: UuidFilter<"POSSalePayment"> | string
    amount?: DecimalFilter<"POSSalePayment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"POSSalePayment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"POSSalePayment"> | string | null
    createdAt?: DateTimeFilter<"POSSalePayment"> | Date | string
    sale?: XOR<POSSaleScalarRelationFilter, POSSaleWhereInput>
  }

  export type POSSalePaymentOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sale?: POSSaleOrderByWithRelationInput
  }

  export type POSSalePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: POSSalePaymentWhereInput | POSSalePaymentWhereInput[]
    OR?: POSSalePaymentWhereInput[]
    NOT?: POSSalePaymentWhereInput | POSSalePaymentWhereInput[]
    saleId?: UuidFilter<"POSSalePayment"> | string
    amount?: DecimalFilter<"POSSalePayment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"POSSalePayment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"POSSalePayment"> | string | null
    createdAt?: DateTimeFilter<"POSSalePayment"> | Date | string
    sale?: XOR<POSSaleScalarRelationFilter, POSSaleWhereInput>
  }, "id">

  export type POSSalePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: POSSalePaymentCountOrderByAggregateInput
    _avg?: POSSalePaymentAvgOrderByAggregateInput
    _max?: POSSalePaymentMaxOrderByAggregateInput
    _min?: POSSalePaymentMinOrderByAggregateInput
    _sum?: POSSalePaymentSumOrderByAggregateInput
  }

  export type POSSalePaymentScalarWhereWithAggregatesInput = {
    AND?: POSSalePaymentScalarWhereWithAggregatesInput | POSSalePaymentScalarWhereWithAggregatesInput[]
    OR?: POSSalePaymentScalarWhereWithAggregatesInput[]
    NOT?: POSSalePaymentScalarWhereWithAggregatesInput | POSSalePaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"POSSalePayment"> | string
    saleId?: UuidWithAggregatesFilter<"POSSalePayment"> | string
    amount?: DecimalWithAggregatesFilter<"POSSalePayment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodWithAggregatesFilter<"POSSalePayment"> | $Enums.PaymentMethod
    reference?: StringNullableWithAggregatesFilter<"POSSalePayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"POSSalePayment"> | Date | string
  }

  export type POSQuotationWhereInput = {
    AND?: POSQuotationWhereInput | POSQuotationWhereInput[]
    OR?: POSQuotationWhereInput[]
    NOT?: POSQuotationWhereInput | POSQuotationWhereInput[]
    id?: UuidFilter<"POSQuotation"> | string
    quotationNumber?: StringFilter<"POSQuotation"> | string
    customerId?: UuidNullableFilter<"POSQuotation"> | string | null
    customerName?: StringFilter<"POSQuotation"> | string
    customerPhone?: StringNullableFilter<"POSQuotation"> | string | null
    customerEmail?: StringNullableFilter<"POSQuotation"> | string | null
    subtotal?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFilter<"POSQuotation"> | $Enums.QuotationStatus
    validUntil?: DateTimeNullableFilter<"POSQuotation"> | Date | string | null
    notes?: StringNullableFilter<"POSQuotation"> | string | null
    tenantId?: UuidFilter<"POSQuotation"> | string
    createdById?: UuidFilter<"POSQuotation"> | string
    createdAt?: DateTimeFilter<"POSQuotation"> | Date | string
    updatedAt?: DateTimeFilter<"POSQuotation"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: POSQuotationItemListRelationFilter
    convertedToSale?: XOR<POSSaleNullableScalarRelationFilter, POSSaleWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type POSQuotationOrderByWithRelationInput = {
    id?: SortOrder
    quotationNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    items?: POSQuotationItemOrderByRelationAggregateInput
    convertedToSale?: POSSaleOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type POSQuotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quotationNumber_tenantId?: POSQuotationQuotationNumberTenantIdCompoundUniqueInput
    AND?: POSQuotationWhereInput | POSQuotationWhereInput[]
    OR?: POSQuotationWhereInput[]
    NOT?: POSQuotationWhereInput | POSQuotationWhereInput[]
    quotationNumber?: StringFilter<"POSQuotation"> | string
    customerId?: UuidNullableFilter<"POSQuotation"> | string | null
    customerName?: StringFilter<"POSQuotation"> | string
    customerPhone?: StringNullableFilter<"POSQuotation"> | string | null
    customerEmail?: StringNullableFilter<"POSQuotation"> | string | null
    subtotal?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFilter<"POSQuotation"> | $Enums.QuotationStatus
    validUntil?: DateTimeNullableFilter<"POSQuotation"> | Date | string | null
    notes?: StringNullableFilter<"POSQuotation"> | string | null
    tenantId?: UuidFilter<"POSQuotation"> | string
    createdById?: UuidFilter<"POSQuotation"> | string
    createdAt?: DateTimeFilter<"POSQuotation"> | Date | string
    updatedAt?: DateTimeFilter<"POSQuotation"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: POSQuotationItemListRelationFilter
    convertedToSale?: XOR<POSSaleNullableScalarRelationFilter, POSSaleWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "quotationNumber_tenantId">

  export type POSQuotationOrderByWithAggregationInput = {
    id?: SortOrder
    quotationNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    validUntil?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: POSQuotationCountOrderByAggregateInput
    _avg?: POSQuotationAvgOrderByAggregateInput
    _max?: POSQuotationMaxOrderByAggregateInput
    _min?: POSQuotationMinOrderByAggregateInput
    _sum?: POSQuotationSumOrderByAggregateInput
  }

  export type POSQuotationScalarWhereWithAggregatesInput = {
    AND?: POSQuotationScalarWhereWithAggregatesInput | POSQuotationScalarWhereWithAggregatesInput[]
    OR?: POSQuotationScalarWhereWithAggregatesInput[]
    NOT?: POSQuotationScalarWhereWithAggregatesInput | POSQuotationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"POSQuotation"> | string
    quotationNumber?: StringWithAggregatesFilter<"POSQuotation"> | string
    customerId?: UuidNullableWithAggregatesFilter<"POSQuotation"> | string | null
    customerName?: StringWithAggregatesFilter<"POSQuotation"> | string
    customerPhone?: StringNullableWithAggregatesFilter<"POSQuotation"> | string | null
    customerEmail?: StringNullableWithAggregatesFilter<"POSQuotation"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusWithAggregatesFilter<"POSQuotation"> | $Enums.QuotationStatus
    validUntil?: DateTimeNullableWithAggregatesFilter<"POSQuotation"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"POSQuotation"> | string | null
    tenantId?: UuidWithAggregatesFilter<"POSQuotation"> | string
    createdById?: UuidWithAggregatesFilter<"POSQuotation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"POSQuotation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"POSQuotation"> | Date | string
  }

  export type POSQuotationItemWhereInput = {
    AND?: POSQuotationItemWhereInput | POSQuotationItemWhereInput[]
    OR?: POSQuotationItemWhereInput[]
    NOT?: POSQuotationItemWhereInput | POSQuotationItemWhereInput[]
    id?: UuidFilter<"POSQuotationItem"> | string
    quotationId?: UuidFilter<"POSQuotationItem"> | string
    partId?: UuidFilter<"POSQuotationItem"> | string
    quantity?: IntFilter<"POSQuotationItem"> | number
    unitPrice?: DecimalFilter<"POSQuotationItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"POSQuotationItem"> | Decimal | DecimalJsLike | number | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    quotation?: XOR<POSQuotationScalarRelationFilter, POSQuotationWhereInput>
  }

  export type POSQuotationItemOrderByWithRelationInput = {
    id?: SortOrder
    quotationId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    part?: PartOrderByWithRelationInput
    quotation?: POSQuotationOrderByWithRelationInput
  }

  export type POSQuotationItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: POSQuotationItemWhereInput | POSQuotationItemWhereInput[]
    OR?: POSQuotationItemWhereInput[]
    NOT?: POSQuotationItemWhereInput | POSQuotationItemWhereInput[]
    quotationId?: UuidFilter<"POSQuotationItem"> | string
    partId?: UuidFilter<"POSQuotationItem"> | string
    quantity?: IntFilter<"POSQuotationItem"> | number
    unitPrice?: DecimalFilter<"POSQuotationItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"POSQuotationItem"> | Decimal | DecimalJsLike | number | string
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
    quotation?: XOR<POSQuotationScalarRelationFilter, POSQuotationWhereInput>
  }, "id">

  export type POSQuotationItemOrderByWithAggregationInput = {
    id?: SortOrder
    quotationId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    _count?: POSQuotationItemCountOrderByAggregateInput
    _avg?: POSQuotationItemAvgOrderByAggregateInput
    _max?: POSQuotationItemMaxOrderByAggregateInput
    _min?: POSQuotationItemMinOrderByAggregateInput
    _sum?: POSQuotationItemSumOrderByAggregateInput
  }

  export type POSQuotationItemScalarWhereWithAggregatesInput = {
    AND?: POSQuotationItemScalarWhereWithAggregatesInput | POSQuotationItemScalarWhereWithAggregatesInput[]
    OR?: POSQuotationItemScalarWhereWithAggregatesInput[]
    NOT?: POSQuotationItemScalarWhereWithAggregatesInput | POSQuotationItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"POSQuotationItem"> | string
    quotationId?: UuidWithAggregatesFilter<"POSQuotationItem"> | string
    partId?: UuidWithAggregatesFilter<"POSQuotationItem"> | string
    quantity?: IntWithAggregatesFilter<"POSQuotationItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"POSQuotationItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"POSQuotationItem"> | Decimal | DecimalJsLike | number | string
  }

  export type CreditNoteWhereInput = {
    AND?: CreditNoteWhereInput | CreditNoteWhereInput[]
    OR?: CreditNoteWhereInput[]
    NOT?: CreditNoteWhereInput | CreditNoteWhereInput[]
    id?: UuidFilter<"CreditNote"> | string
    creditNoteNumber?: StringFilter<"CreditNote"> | string
    posSaleId?: UuidFilter<"CreditNote"> | string
    customerId?: UuidNullableFilter<"CreditNote"> | string | null
    reason?: StringFilter<"CreditNote"> | string
    subtotal?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFilter<"CreditNote"> | $Enums.CreditNoteStatus
    refundMethod?: EnumPaymentMethodNullableFilter<"CreditNote"> | $Enums.PaymentMethod | null
    refundReference?: StringNullableFilter<"CreditNote"> | string | null
    notes?: StringNullableFilter<"CreditNote"> | string | null
    processedAt?: DateTimeNullableFilter<"CreditNote"> | Date | string | null
    processedById?: UuidNullableFilter<"CreditNote"> | string | null
    tenantId?: UuidFilter<"CreditNote"> | string
    createdById?: UuidFilter<"CreditNote"> | string
    createdAt?: DateTimeFilter<"CreditNote"> | Date | string
    updatedAt?: DateTimeFilter<"CreditNote"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    processedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: CreditNoteItemListRelationFilter
    posSale?: XOR<POSSaleScalarRelationFilter, POSSaleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type CreditNoteOrderByWithRelationInput = {
    id?: SortOrder
    creditNoteNumber?: SortOrder
    posSaleId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    reason?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    refundMethod?: SortOrderInput | SortOrder
    refundReference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    processedBy?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    items?: CreditNoteItemOrderByRelationAggregateInput
    posSale?: POSSaleOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type CreditNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creditNoteNumber_tenantId?: CreditNoteCreditNoteNumberTenantIdCompoundUniqueInput
    AND?: CreditNoteWhereInput | CreditNoteWhereInput[]
    OR?: CreditNoteWhereInput[]
    NOT?: CreditNoteWhereInput | CreditNoteWhereInput[]
    creditNoteNumber?: StringFilter<"CreditNote"> | string
    posSaleId?: UuidFilter<"CreditNote"> | string
    customerId?: UuidNullableFilter<"CreditNote"> | string | null
    reason?: StringFilter<"CreditNote"> | string
    subtotal?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFilter<"CreditNote"> | $Enums.CreditNoteStatus
    refundMethod?: EnumPaymentMethodNullableFilter<"CreditNote"> | $Enums.PaymentMethod | null
    refundReference?: StringNullableFilter<"CreditNote"> | string | null
    notes?: StringNullableFilter<"CreditNote"> | string | null
    processedAt?: DateTimeNullableFilter<"CreditNote"> | Date | string | null
    processedById?: UuidNullableFilter<"CreditNote"> | string | null
    tenantId?: UuidFilter<"CreditNote"> | string
    createdById?: UuidFilter<"CreditNote"> | string
    createdAt?: DateTimeFilter<"CreditNote"> | Date | string
    updatedAt?: DateTimeFilter<"CreditNote"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    processedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    items?: CreditNoteItemListRelationFilter
    posSale?: XOR<POSSaleScalarRelationFilter, POSSaleWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "creditNoteNumber_tenantId">

  export type CreditNoteOrderByWithAggregationInput = {
    id?: SortOrder
    creditNoteNumber?: SortOrder
    posSaleId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    reason?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    refundMethod?: SortOrderInput | SortOrder
    refundReference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    processedById?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreditNoteCountOrderByAggregateInput
    _avg?: CreditNoteAvgOrderByAggregateInput
    _max?: CreditNoteMaxOrderByAggregateInput
    _min?: CreditNoteMinOrderByAggregateInput
    _sum?: CreditNoteSumOrderByAggregateInput
  }

  export type CreditNoteScalarWhereWithAggregatesInput = {
    AND?: CreditNoteScalarWhereWithAggregatesInput | CreditNoteScalarWhereWithAggregatesInput[]
    OR?: CreditNoteScalarWhereWithAggregatesInput[]
    NOT?: CreditNoteScalarWhereWithAggregatesInput | CreditNoteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CreditNote"> | string
    creditNoteNumber?: StringWithAggregatesFilter<"CreditNote"> | string
    posSaleId?: UuidWithAggregatesFilter<"CreditNote"> | string
    customerId?: UuidNullableWithAggregatesFilter<"CreditNote"> | string | null
    reason?: StringWithAggregatesFilter<"CreditNote"> | string
    subtotal?: DecimalWithAggregatesFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusWithAggregatesFilter<"CreditNote"> | $Enums.CreditNoteStatus
    refundMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"CreditNote"> | $Enums.PaymentMethod | null
    refundReference?: StringNullableWithAggregatesFilter<"CreditNote"> | string | null
    notes?: StringNullableWithAggregatesFilter<"CreditNote"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"CreditNote"> | Date | string | null
    processedById?: UuidNullableWithAggregatesFilter<"CreditNote"> | string | null
    tenantId?: UuidWithAggregatesFilter<"CreditNote"> | string
    createdById?: UuidWithAggregatesFilter<"CreditNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CreditNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CreditNote"> | Date | string
  }

  export type CreditNoteItemWhereInput = {
    AND?: CreditNoteItemWhereInput | CreditNoteItemWhereInput[]
    OR?: CreditNoteItemWhereInput[]
    NOT?: CreditNoteItemWhereInput | CreditNoteItemWhereInput[]
    id?: UuidFilter<"CreditNoteItem"> | string
    creditNoteId?: UuidFilter<"CreditNoteItem"> | string
    partId?: UuidFilter<"CreditNoteItem"> | string
    quantity?: IntFilter<"CreditNoteItem"> | number
    unitPrice?: DecimalFilter<"CreditNoteItem"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"CreditNoteItem"> | string | null
    creditNote?: XOR<CreditNoteScalarRelationFilter, CreditNoteWhereInput>
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
  }

  export type CreditNoteItemOrderByWithRelationInput = {
    id?: SortOrder
    creditNoteId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    reason?: SortOrderInput | SortOrder
    creditNote?: CreditNoteOrderByWithRelationInput
    part?: PartOrderByWithRelationInput
  }

  export type CreditNoteItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditNoteItemWhereInput | CreditNoteItemWhereInput[]
    OR?: CreditNoteItemWhereInput[]
    NOT?: CreditNoteItemWhereInput | CreditNoteItemWhereInput[]
    creditNoteId?: UuidFilter<"CreditNoteItem"> | string
    partId?: UuidFilter<"CreditNoteItem"> | string
    quantity?: IntFilter<"CreditNoteItem"> | number
    unitPrice?: DecimalFilter<"CreditNoteItem"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"CreditNoteItem"> | string | null
    creditNote?: XOR<CreditNoteScalarRelationFilter, CreditNoteWhereInput>
    part?: XOR<PartScalarRelationFilter, PartWhereInput>
  }, "id">

  export type CreditNoteItemOrderByWithAggregationInput = {
    id?: SortOrder
    creditNoteId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: CreditNoteItemCountOrderByAggregateInput
    _avg?: CreditNoteItemAvgOrderByAggregateInput
    _max?: CreditNoteItemMaxOrderByAggregateInput
    _min?: CreditNoteItemMinOrderByAggregateInput
    _sum?: CreditNoteItemSumOrderByAggregateInput
  }

  export type CreditNoteItemScalarWhereWithAggregatesInput = {
    AND?: CreditNoteItemScalarWhereWithAggregatesInput | CreditNoteItemScalarWhereWithAggregatesInput[]
    OR?: CreditNoteItemScalarWhereWithAggregatesInput[]
    NOT?: CreditNoteItemScalarWhereWithAggregatesInput | CreditNoteItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CreditNoteItem"> | string
    creditNoteId?: UuidWithAggregatesFilter<"CreditNoteItem"> | string
    partId?: UuidWithAggregatesFilter<"CreditNoteItem"> | string
    quantity?: IntWithAggregatesFilter<"CreditNoteItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"CreditNoteItem"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableWithAggregatesFilter<"CreditNoteItem"> | string | null
  }

  export type SessionLogWhereInput = {
    AND?: SessionLogWhereInput | SessionLogWhereInput[]
    OR?: SessionLogWhereInput[]
    NOT?: SessionLogWhereInput | SessionLogWhereInput[]
    id?: UuidFilter<"SessionLog"> | string
    tenantId?: UuidFilter<"SessionLog"> | string
    userId?: UuidFilter<"SessionLog"> | string
    sessionToken?: StringFilter<"SessionLog"> | string
    ipAddress?: StringNullableFilter<"SessionLog"> | string | null
    userAgent?: StringNullableFilter<"SessionLog"> | string | null
    loginAt?: DateTimeFilter<"SessionLog"> | Date | string
    lastActivityAt?: DateTimeFilter<"SessionLog"> | Date | string
    logoutAt?: DateTimeNullableFilter<"SessionLog"> | Date | string | null
    status?: EnumSessionStatusFilter<"SessionLog"> | $Enums.SessionStatus
    metadata?: JsonNullableFilter<"SessionLog">
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    loginAt?: SortOrder
    lastActivityAt?: SortOrder
    logoutAt?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SessionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionLogWhereInput | SessionLogWhereInput[]
    OR?: SessionLogWhereInput[]
    NOT?: SessionLogWhereInput | SessionLogWhereInput[]
    tenantId?: UuidFilter<"SessionLog"> | string
    userId?: UuidFilter<"SessionLog"> | string
    ipAddress?: StringNullableFilter<"SessionLog"> | string | null
    userAgent?: StringNullableFilter<"SessionLog"> | string | null
    loginAt?: DateTimeFilter<"SessionLog"> | Date | string
    lastActivityAt?: DateTimeFilter<"SessionLog"> | Date | string
    logoutAt?: DateTimeNullableFilter<"SessionLog"> | Date | string | null
    status?: EnumSessionStatusFilter<"SessionLog"> | $Enums.SessionStatus
    metadata?: JsonNullableFilter<"SessionLog">
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    loginAt?: SortOrder
    lastActivityAt?: SortOrder
    logoutAt?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: SessionLogCountOrderByAggregateInput
    _max?: SessionLogMaxOrderByAggregateInput
    _min?: SessionLogMinOrderByAggregateInput
  }

  export type SessionLogScalarWhereWithAggregatesInput = {
    AND?: SessionLogScalarWhereWithAggregatesInput | SessionLogScalarWhereWithAggregatesInput[]
    OR?: SessionLogScalarWhereWithAggregatesInput[]
    NOT?: SessionLogScalarWhereWithAggregatesInput | SessionLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SessionLog"> | string
    tenantId?: UuidWithAggregatesFilter<"SessionLog"> | string
    userId?: UuidWithAggregatesFilter<"SessionLog"> | string
    sessionToken?: StringWithAggregatesFilter<"SessionLog"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SessionLog"> | string | null
    loginAt?: DateTimeWithAggregatesFilter<"SessionLog"> | Date | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"SessionLog"> | Date | string
    logoutAt?: DateTimeNullableWithAggregatesFilter<"SessionLog"> | Date | string | null
    status?: EnumSessionStatusWithAggregatesFilter<"SessionLog"> | $Enums.SessionStatus
    metadata?: JsonNullableWithAggregatesFilter<"SessionLog">
  }

  export type UserPresenceWhereInput = {
    AND?: UserPresenceWhereInput | UserPresenceWhereInput[]
    OR?: UserPresenceWhereInput[]
    NOT?: UserPresenceWhereInput | UserPresenceWhereInput[]
    id?: UuidFilter<"UserPresence"> | string
    userId?: UuidFilter<"UserPresence"> | string
    tenantId?: UuidFilter<"UserPresence"> | string
    status?: EnumPresenceStatusFilter<"UserPresence"> | $Enums.PresenceStatus
    currentRoute?: StringNullableFilter<"UserPresence"> | string | null
    currentPage?: StringNullableFilter<"UserPresence"> | string | null
    currentTicketId?: UuidNullableFilter<"UserPresence"> | string | null
    lastSeenAt?: DateTimeFilter<"UserPresence"> | Date | string
    metadata?: JsonNullableFilter<"UserPresence">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    currentTicket?: XOR<TicketNullableScalarRelationFilter, TicketWhereInput> | null
  }

  export type UserPresenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    currentRoute?: SortOrderInput | SortOrder
    currentPage?: SortOrderInput | SortOrder
    currentTicketId?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    currentTicket?: TicketOrderByWithRelationInput
  }

  export type UserPresenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPresenceWhereInput | UserPresenceWhereInput[]
    OR?: UserPresenceWhereInput[]
    NOT?: UserPresenceWhereInput | UserPresenceWhereInput[]
    tenantId?: UuidFilter<"UserPresence"> | string
    status?: EnumPresenceStatusFilter<"UserPresence"> | $Enums.PresenceStatus
    currentRoute?: StringNullableFilter<"UserPresence"> | string | null
    currentPage?: StringNullableFilter<"UserPresence"> | string | null
    currentTicketId?: UuidNullableFilter<"UserPresence"> | string | null
    lastSeenAt?: DateTimeFilter<"UserPresence"> | Date | string
    metadata?: JsonNullableFilter<"UserPresence">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    currentTicket?: XOR<TicketNullableScalarRelationFilter, TicketWhereInput> | null
  }, "id" | "userId">

  export type UserPresenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    currentRoute?: SortOrderInput | SortOrder
    currentPage?: SortOrderInput | SortOrder
    currentTicketId?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: UserPresenceCountOrderByAggregateInput
    _max?: UserPresenceMaxOrderByAggregateInput
    _min?: UserPresenceMinOrderByAggregateInput
  }

  export type UserPresenceScalarWhereWithAggregatesInput = {
    AND?: UserPresenceScalarWhereWithAggregatesInput | UserPresenceScalarWhereWithAggregatesInput[]
    OR?: UserPresenceScalarWhereWithAggregatesInput[]
    NOT?: UserPresenceScalarWhereWithAggregatesInput | UserPresenceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserPresence"> | string
    userId?: UuidWithAggregatesFilter<"UserPresence"> | string
    tenantId?: UuidWithAggregatesFilter<"UserPresence"> | string
    status?: EnumPresenceStatusWithAggregatesFilter<"UserPresence"> | $Enums.PresenceStatus
    currentRoute?: StringNullableWithAggregatesFilter<"UserPresence"> | string | null
    currentPage?: StringNullableWithAggregatesFilter<"UserPresence"> | string | null
    currentTicketId?: UuidNullableWithAggregatesFilter<"UserPresence"> | string | null
    lastSeenAt?: DateTimeWithAggregatesFilter<"UserPresence"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"UserPresence">
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedCustomersInput
    creditNotes?: CreditNoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCustomerInput
    tenant: TenantCreateNestedOneWithoutCustomersInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedCustomersInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCustomerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedCustomersNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCustomerNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCreateInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketAttachmentCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutAttachmentsInput
    uploadedBy: UserCreateNestedOneWithoutUploadedAttachmentsInput
  }

  export type TicketAttachmentUncheckedCreateInput = {
    id?: string
    ticketId: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    uploadedById: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutAttachmentsNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedAttachmentsNestedInput
  }

  export type TicketAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentCreateManyInput = {
    id?: string
    ticketId: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    uploadedById: string
    createdAt?: Date | string
  }

  export type TicketAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartCreateInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartCreateManyInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
  }

  export type PartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
  }

  export type PartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    supplier: string
    status?: $Enums.PurchaseStatus
    orderDate?: Date | string
    receivedDate?: Date | string | null
    totalCost?: Decimal | DecimalJsLike | number | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemCreateNestedManyWithoutPurchaseOrderInput
    tenant: TenantCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    supplier: string
    status?: $Enums.PurchaseStatus
    orderDate?: Date | string
    receivedDate?: Date | string | null
    totalCost?: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUpdateManyWithoutPurchaseOrderNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    supplier: string
    status?: $Enums.PurchaseStatus
    orderDate?: Date | string
    receivedDate?: Date | string | null
    totalCost?: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    part: PartCreateNestedOneWithoutPurchaseItemsInput
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseItemUncheckedCreateInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    partId: string
    purchaseOrderId: string
  }

  export type PurchaseItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    part?: PartUpdateOneRequiredWithoutPurchaseItemsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseItemCreateManyInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    partId: string
    purchaseOrderId: string
  }

  export type PurchaseItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partId?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
  }

  export type PartUsageCreateInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    part: PartCreateNestedOneWithoutUsagesInput
    ticket: TicketCreateNestedOneWithoutPartsUsedInput
  }

  export type PartUsageUncheckedCreateInput = {
    id?: string
    quantity: number
    ticketId: string
    partId: string
    createdAt?: Date | string
  }

  export type PartUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    part?: PartUpdateOneRequiredWithoutUsagesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutPartsUsedNestedInput
  }

  export type PartUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    ticketId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUsageCreateManyInput = {
    id?: string
    quantity: number
    ticketId: string
    partId: string
    createdAt?: Date | string
  }

  export type PartUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    ticketId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    details?: string | null
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    details?: string | null
    userId?: string | null
    tenantId: string
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateManyInput = {
    id?: string
    details?: string | null
    userId?: string | null
    tenantId: string
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketNoteCreateInput = {
    id?: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutTicketNotesInput
    ticket: TicketCreateNestedOneWithoutNotesInput
  }

  export type TicketNoteUncheckedCreateInput = {
    id?: string
    content: string
    isInternal?: boolean
    ticketId: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutTicketNotesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutNotesNestedInput
  }

  export type TicketNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteCreateManyInput = {
    id?: string
    content: string
    isInternal?: boolean
    ticketId: string
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTemplateCreateInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedTemplatesInput
    tenant: TenantCreateNestedOneWithoutServiceTemplatesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTemplatesInput
    defaultParts?: TemplateDefaultPartCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceCreateNestedManyWithoutServiceInput
    tickets?: TicketCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateUncheckedCreateInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceUncheckedCreateNestedManyWithoutServiceInput
    tickets?: TicketUncheckedCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedTemplatesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutServiceTemplatesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTemplatesNestedInput
    defaultParts?: TemplateDefaultPartUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUpdateManyWithoutServiceNestedInput
    tickets?: TicketUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUncheckedUpdateManyWithoutServiceNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateCreateManyInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateDefaultPartCreateInput = {
    id?: string
    quantity?: number
    required?: boolean
    createdAt?: Date | string
    part: PartCreateNestedOneWithoutTemplateDefaultPartsInput
    template: ServiceTemplateCreateNestedOneWithoutDefaultPartsInput
  }

  export type TemplateDefaultPartUncheckedCreateInput = {
    id?: string
    quantity?: number
    required?: boolean
    templateId: string
    partId: string
    createdAt?: Date | string
  }

  export type TemplateDefaultPartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    part?: PartUpdateOneRequiredWithoutTemplateDefaultPartsNestedInput
    template?: ServiceTemplateUpdateOneRequiredWithoutDefaultPartsNestedInput
  }

  export type TemplateDefaultPartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateDefaultPartCreateManyInput = {
    id?: string
    quantity?: number
    required?: boolean
    templateId: string
    partId: string
    createdAt?: Date | string
  }

  export type TemplateDefaultPartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateDefaultPartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketServiceCreateInput = {
    id?: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    service: ServiceTemplateCreateNestedOneWithoutUsagesInput
    ticket: TicketCreateNestedOneWithoutServicesInput
  }

  export type TicketServiceUncheckedCreateInput = {
    id?: string
    ticketId: string
    serviceId: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TicketServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceTemplateUpdateOneRequiredWithoutUsagesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutServicesNestedInput
  }

  export type TicketServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketServiceCreateManyInput = {
    id?: string
    ticketId: string
    serviceId: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TicketServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianSpecializationCreateInput = {
    id?: string
    specialization: $Enums.Specialization
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSpecializationsInput
  }

  export type TechnicianSpecializationUncheckedCreateInput = {
    id?: string
    userId: string
    specialization: $Enums.Specialization
    createdAt?: Date | string
  }

  export type TechnicianSpecializationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: EnumSpecializationFieldUpdateOperationsInput | $Enums.Specialization
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSpecializationsNestedInput
  }

  export type TechnicianSpecializationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: EnumSpecializationFieldUpdateOperationsInput | $Enums.Specialization
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianSpecializationCreateManyInput = {
    id?: string
    userId: string
    specialization: $Enums.Specialization
    createdAt?: Date | string
  }

  export type TechnicianSpecializationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: EnumSpecializationFieldUpdateOperationsInput | $Enums.Specialization
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianSpecializationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    specialization?: EnumSpecializationFieldUpdateOperationsInput | $Enums.Specialization
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianUnavailabilityCreateInput = {
    id?: string
    reason?: $Enums.TechnicianStatus
    notes?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUnavailabilitiesInput
  }

  export type TechnicianUnavailabilityUncheckedCreateInput = {
    id?: string
    reason?: $Enums.TechnicianStatus
    notes?: string | null
    userId: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicianUnavailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUnavailabilitiesNestedInput
  }

  export type TechnicianUnavailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianUnavailabilityCreateManyInput = {
    id?: string
    reason?: $Enums.TechnicianStatus
    notes?: string | null
    userId: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicianUnavailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianUnavailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    tenantId: string
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    tenantId: string
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    history?: InvoiceHistoryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    ticket: TicketCreateNestedOneWithoutInvoiceInput
    updatedBy: UserCreateNestedOneWithoutUpdatedInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: InvoiceHistoryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    history?: InvoiceHistoryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutInvoiceNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: InvoiceHistoryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    paymentNumber: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    receivedBy: UserCreateNestedOneWithoutReceivedPaymentsInput
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    tenantId: string
    receivedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutReceivedPaymentsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    tenantId: string
    receivedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRegisterCreateInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedBy?: UserCreateNestedOneWithoutClosedCashRegistersInput
    openedBy?: UserCreateNestedOneWithoutOpenedCashRegistersInput
    posSales?: POSSaleCreateNestedManyWithoutCashRegisterInput
    tenant: TenantCreateNestedOneWithoutCashRegistersInput
    transactions?: CashTransactionCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterUncheckedCreateInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    tenantId: string
    openedById?: string | null
    closedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCashRegisterInput
    transactions?: CashTransactionUncheckedCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedBy?: UserUpdateOneWithoutClosedCashRegistersNestedInput
    openedBy?: UserUpdateOneWithoutOpenedCashRegistersNestedInput
    posSales?: POSSaleUpdateManyWithoutCashRegisterNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashRegistersNestedInput
    transactions?: CashTransactionUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    openedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posSales?: POSSaleUncheckedUpdateManyWithoutCashRegisterNestedInput
    transactions?: CashTransactionUncheckedUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterCreateManyInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    tenantId: string
    openedById?: string | null
    closedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashRegisterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRegisterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    openedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionCreateInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    createdAt?: Date | string
    cashRegister: CashRegisterCreateNestedOneWithoutTransactionsInput
    createdBy: UserCreateNestedOneWithoutCashTransactionsInput
    tenant: TenantCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    cashRegisterId: string
    tenantId: string
    createdById: string
    createdAt?: Date | string
  }

  export type CashTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCashTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashRegisterId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionCreateManyInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    cashRegisterId: string
    tenantId: string
    createdById: string
    createdAt?: Date | string
  }

  export type CashTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashRegisterId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsCreateInput = {
    id?: string
    businessName?: string | null
    businessNIT?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    businessEmail?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxName?: string
    currency?: string
    defaultPaymentTerms?: string | null
    invoiceFooter?: string | null
    slaWarningPercent?: number
    slaCriticalPercent?: number
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSettingsInput
  }

  export type TenantSettingsUncheckedCreateInput = {
    id?: string
    tenantId: string
    businessName?: string | null
    businessNIT?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    businessEmail?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxName?: string
    currency?: string
    defaultPaymentTerms?: string | null
    invoiceFooter?: string | null
    slaWarningPercent?: number
    slaCriticalPercent?: number
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessNIT?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    defaultPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    slaWarningPercent?: IntFieldUpdateOperationsInput | number
    slaCriticalPercent?: IntFieldUpdateOperationsInput | number
    slaEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    slaInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type TenantSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessNIT?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    defaultPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    slaWarningPercent?: IntFieldUpdateOperationsInput | number
    slaCriticalPercent?: IntFieldUpdateOperationsInput | number
    slaEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    slaInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsCreateManyInput = {
    id?: string
    tenantId: string
    businessName?: string | null
    businessNIT?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    businessEmail?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxName?: string
    currency?: string
    defaultPaymentTerms?: string | null
    invoiceFooter?: string | null
    slaWarningPercent?: number
    slaCriticalPercent?: number
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessNIT?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    defaultPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    slaWarningPercent?: IntFieldUpdateOperationsInput | number
    slaCriticalPercent?: IntFieldUpdateOperationsInput | number
    slaEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    slaInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessNIT?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    defaultPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    slaWarningPercent?: IntFieldUpdateOperationsInput | number
    slaCriticalPercent?: IntFieldUpdateOperationsInput | number
    slaEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    slaInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceHistoryCreateInput = {
    id?: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutHistoryInput
    user: UserCreateNestedOneWithoutInvoiceHistoryInput
  }

  export type InvoiceHistoryUncheckedCreateInput = {
    id?: string
    invoiceId: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type InvoiceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutInvoiceHistoryNestedInput
  }

  export type InvoiceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceHistoryCreateManyInput = {
    id?: string
    invoiceId: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type InvoiceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSaleCreateInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashRegister?: CashRegisterCreateNestedOneWithoutPosSalesInput
    createdBy: UserCreateNestedOneWithoutPosSalesInput
    creditNotes?: CreditNoteCreateNestedManyWithoutPosSaleInput
    customer?: CustomerCreateNestedOneWithoutPosSalesInput
    items?: POSSaleItemCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentCreateNestedManyWithoutSaleInput
    quotation?: POSQuotationCreateNestedOneWithoutConvertedToSaleInput
    tenant: TenantCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput
    items?: POSSaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneWithoutPosSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPosSalesNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutPosSaleNestedInput
    customer?: CustomerUpdateOneWithoutPosSalesNestedInput
    items?: POSSaleItemUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUpdateManyWithoutSaleNestedInput
    quotation?: POSQuotationUpdateOneWithoutConvertedToSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput
    items?: POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type POSSaleCreateManyInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSSaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSaleItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    part: PartCreateNestedOneWithoutPosSaleItemsInput
    sale: POSSaleCreateNestedOneWithoutItemsInput
  }

  export type POSSaleItemUncheckedCreateInput = {
    id?: string
    saleId: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    part?: PartUpdateOneRequiredWithoutPosSaleItemsNestedInput
    sale?: POSSaleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type POSSaleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemCreateManyInput = {
    id?: string
    saleId: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSSalePaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    reference?: string | null
    createdAt?: Date | string
    sale: POSSaleCreateNestedOneWithoutPaymentsInput
  }

  export type POSSalePaymentUncheckedCreateInput = {
    id?: string
    saleId: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    reference?: string | null
    createdAt?: Date | string
  }

  export type POSSalePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: POSSaleUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type POSSalePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSalePaymentCreateManyInput = {
    id?: string
    saleId: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    reference?: string | null
    createdAt?: Date | string
  }

  export type POSSalePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSalePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSQuotationCreateInput = {
    id?: string
    quotationNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPosQuotationsInput
    customer?: CustomerCreateNestedOneWithoutPosQuotationsInput
    items?: POSQuotationItemCreateNestedManyWithoutQuotationInput
    convertedToSale?: POSSaleCreateNestedOneWithoutQuotationInput
    tenant: TenantCreateNestedOneWithoutPosQuotationsInput
  }

  export type POSQuotationUncheckedCreateInput = {
    id?: string
    quotationNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: POSQuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    convertedToSale?: POSSaleUncheckedCreateNestedOneWithoutQuotationInput
  }

  export type POSQuotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPosQuotationsNestedInput
    customer?: CustomerUpdateOneWithoutPosQuotationsNestedInput
    items?: POSQuotationItemUpdateManyWithoutQuotationNestedInput
    convertedToSale?: POSSaleUpdateOneWithoutQuotationNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosQuotationsNestedInput
  }

  export type POSQuotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: POSQuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    convertedToSale?: POSSaleUncheckedUpdateOneWithoutQuotationNestedInput
  }

  export type POSQuotationCreateManyInput = {
    id?: string
    quotationNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSQuotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSQuotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSQuotationItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    part: PartCreateNestedOneWithoutPosQuotationItemsInput
    quotation: POSQuotationCreateNestedOneWithoutItemsInput
  }

  export type POSQuotationItemUncheckedCreateInput = {
    id?: string
    quotationId: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    part?: PartUpdateOneRequiredWithoutPosQuotationItemsNestedInput
    quotation?: POSQuotationUpdateOneRequiredWithoutItemsNestedInput
  }

  export type POSQuotationItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemCreateManyInput = {
    id?: string
    quotationId: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CreditNoteCreateInput = {
    id?: string
    creditNoteNumber: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreditNotesCreatedInput
    processedBy?: UserCreateNestedOneWithoutCreditNotesProcessedInput
    customer?: CustomerCreateNestedOneWithoutCreditNotesInput
    items?: CreditNoteItemCreateNestedManyWithoutCreditNoteInput
    posSale: POSSaleCreateNestedOneWithoutCreditNotesInput
    tenant: TenantCreateNestedOneWithoutCreditNotesInput
  }

  export type CreditNoteUncheckedCreateInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CreditNoteItemUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type CreditNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreditNotesCreatedNestedInput
    processedBy?: UserUpdateOneWithoutCreditNotesProcessedNestedInput
    customer?: CustomerUpdateOneWithoutCreditNotesNestedInput
    items?: CreditNoteItemUpdateManyWithoutCreditNoteNestedInput
    posSale?: POSSaleUpdateOneRequiredWithoutCreditNotesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCreditNotesNestedInput
  }

  export type CreditNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CreditNoteItemUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type CreditNoteCreateManyInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
    creditNote: CreditNoteCreateNestedOneWithoutItemsInput
    part: PartCreateNestedOneWithoutCreditNoteItemsInput
  }

  export type CreditNoteItemUncheckedCreateInput = {
    id?: string
    creditNoteId: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
  }

  export type CreditNoteItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditNote?: CreditNoteUpdateOneRequiredWithoutItemsNestedInput
    part?: PartUpdateOneRequiredWithoutCreditNoteItemsNestedInput
  }

  export type CreditNoteItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditNoteItemCreateManyInput = {
    id?: string
    creditNoteId: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
  }

  export type CreditNoteItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditNoteItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteId?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionLogCreateInput = {
    id?: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tenant: TenantCreateNestedOneWithoutSessionLogsInput
    user: UserCreateNestedOneWithoutSessionLogsInput
  }

  export type SessionLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tenant?: TenantUpdateOneRequiredWithoutSessionLogsNestedInput
    user?: UserUpdateOneRequiredWithoutSessionLogsNestedInput
  }

  export type SessionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionLogCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceCreateInput = {
    id?: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPresenceInput
    tenant: TenantCreateNestedOneWithoutUserPresencesInput
    currentTicket?: TicketCreateNestedOneWithoutViewedByUsersInput
  }

  export type UserPresenceUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    currentTicketId?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPresenceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUserPresencesNestedInput
    currentTicket?: TicketUpdateOneWithoutViewedByUsersNestedInput
  }

  export type UserPresenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    currentTicketId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    currentTicketId?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    currentTicketId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SessionLogListRelationFilter = {
    every?: SessionLogWhereInput
    some?: SessionLogWhereInput
    none?: SessionLogWhereInput
  }

  export type UserPresenceListRelationFilter = {
    every?: UserPresenceWhereInput
    some?: UserPresenceWhereInput
    none?: UserPresenceWhereInput
  }

  export type CashRegisterListRelationFilter = {
    every?: CashRegisterWhereInput
    some?: CashRegisterWhereInput
    none?: CashRegisterWhereInput
  }

  export type CashTransactionListRelationFilter = {
    every?: CashTransactionWhereInput
    some?: CashTransactionWhereInput
    none?: CashTransactionWhereInput
  }

  export type CreditNoteListRelationFilter = {
    every?: CreditNoteWhereInput
    some?: CreditNoteWhereInput
    none?: CreditNoteWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PartListRelationFilter = {
    every?: PartWhereInput
    some?: PartWhereInput
    none?: PartWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type POSSaleListRelationFilter = {
    every?: POSSaleWhereInput
    some?: POSSaleWhereInput
    none?: POSSaleWhereInput
  }

  export type POSQuotationListRelationFilter = {
    every?: POSQuotationWhereInput
    some?: POSQuotationWhereInput
    none?: POSQuotationWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type ServiceTemplateListRelationFilter = {
    every?: ServiceTemplateWhereInput
    some?: ServiceTemplateWhereInput
    none?: ServiceTemplateWhereInput
  }

  export type TenantSettingsNullableScalarRelationFilter = {
    is?: TenantSettingsWhereInput | null
    isNot?: TenantSettingsWhereInput | null
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPresenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashRegisterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POSSaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POSQuotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    adminUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    adminUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    adminUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTechnicianStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TechnicianStatus | EnumTechnicianStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TechnicianStatus[] | ListEnumTechnicianStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechnicianStatus[] | ListEnumTechnicianStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnicianStatusFilter<$PrismaModel> | $Enums.TechnicianStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserPresenceNullableScalarRelationFilter = {
    is?: UserPresenceWhereInput | null
    isNot?: UserPresenceWhereInput | null
  }

  export type InvoiceHistoryListRelationFilter = {
    every?: InvoiceHistoryWhereInput
    some?: InvoiceHistoryWhereInput
    none?: InvoiceHistoryWhereInput
  }

  export type TechnicianSpecializationListRelationFilter = {
    every?: TechnicianSpecializationWhereInput
    some?: TechnicianSpecializationWhereInput
    none?: TechnicianSpecializationWhereInput
  }

  export type TechnicianUnavailabilityListRelationFilter = {
    every?: TechnicianUnavailabilityWhereInput
    some?: TechnicianUnavailabilityWhereInput
    none?: TechnicianUnavailabilityWhereInput
  }

  export type TicketNoteListRelationFilter = {
    every?: TicketNoteWhereInput
    some?: TicketNoteWhereInput
    none?: TicketNoteWhereInput
  }

  export type TicketAttachmentListRelationFilter = {
    every?: TicketAttachmentWhereInput
    some?: TicketAttachmentWhereInput
    none?: TicketAttachmentWhereInput
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type InvoiceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TechnicianSpecializationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TechnicianUnavailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserUnique_email_per_tenantCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    passwordMustChange?: SortOrder
    lastLoginAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    maxConcurrentTickets?: SortOrder
    statusReason?: SortOrder
    availableFrom?: SortOrder
    availableUntil?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
    maxConcurrentTickets?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    passwordMustChange?: SortOrder
    lastLoginAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    maxConcurrentTickets?: SortOrder
    statusReason?: SortOrder
    availableFrom?: SortOrder
    availableUntil?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    role?: SortOrder
    tenantId?: SortOrder
    isActive?: SortOrder
    passwordMustChange?: SortOrder
    lastLoginAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    maxConcurrentTickets?: SortOrder
    statusReason?: SortOrder
    availableFrom?: SortOrder
    availableUntil?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedLoginAttempts?: SortOrder
    maxConcurrentTickets?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTechnicianStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TechnicianStatus | EnumTechnicianStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TechnicianStatus[] | ListEnumTechnicianStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechnicianStatus[] | ListEnumTechnicianStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnicianStatusWithAggregatesFilter<$PrismaModel> | $Enums.TechnicianStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechnicianStatusFilter<$PrismaModel>
    _max?: NestedEnumTechnicianStatusFilter<$PrismaModel>
  }

  export type CustomerUnique_dpi_per_tenantCompoundUniqueInput = {
    dpi: string
    tenantId: string
  }

  export type CustomerUnique_nit_per_tenantCompoundUniqueInput = {
    nit: string
    tenantId: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    dpi?: SortOrder
    nit?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    dpi?: SortOrder
    nit?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    dpi?: SortOrder
    nit?: SortOrder
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PartUsageListRelationFilter = {
    every?: PartUsageWhereInput
    some?: PartUsageWhereInput
    none?: PartUsageWhereInput
  }

  export type TicketServiceListRelationFilter = {
    every?: TicketServiceWhereInput
    some?: TicketServiceWhereInput
    none?: TicketServiceWhereInput
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type ServiceTemplateNullableScalarRelationFilter = {
    is?: ServiceTemplateWhereInput | null
    isNot?: ServiceTemplateWhereInput | null
  }

  export type PartUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketTicketNumberTenantIdCompoundUniqueInput = {
    ticketNumber: string
    tenantId: string
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessories?: SortOrder
    cancellationReason?: SortOrder
    checkInNotes?: SortOrder
    deviceModel?: SortOrder
    deviceType?: SortOrder
    serialNumber?: SortOrder
    createdById?: SortOrder
    serviceTemplateId?: SortOrder
    updatedById?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    estimatedCompletionDate?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessories?: SortOrder
    cancellationReason?: SortOrder
    checkInNotes?: SortOrder
    deviceModel?: SortOrder
    deviceType?: SortOrder
    serialNumber?: SortOrder
    createdById?: SortOrder
    serviceTemplateId?: SortOrder
    updatedById?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    estimatedCompletionDate?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    customerId?: SortOrder
    assignedToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessories?: SortOrder
    cancellationReason?: SortOrder
    checkInNotes?: SortOrder
    deviceModel?: SortOrder
    deviceType?: SortOrder
    serialNumber?: SortOrder
    createdById?: SortOrder
    serviceTemplateId?: SortOrder
    updatedById?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    estimatedCompletionDate?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TicketAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketAttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type TicketAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketAttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CreditNoteItemListRelationFilter = {
    every?: CreditNoteItemWhereInput
    some?: CreditNoteItemWhereInput
    none?: CreditNoteItemWhereInput
  }

  export type POSQuotationItemListRelationFilter = {
    every?: POSQuotationItemWhereInput
    some?: POSQuotationItemWhereInput
    none?: POSQuotationItemWhereInput
  }

  export type POSSaleItemListRelationFilter = {
    every?: POSSaleItemWhereInput
    some?: POSSaleItemWhereInput
    none?: POSSaleItemWhereInput
  }

  export type PurchaseItemListRelationFilter = {
    every?: PurchaseItemWhereInput
    some?: PurchaseItemWhereInput
    none?: PurchaseItemWhereInput
  }

  export type TemplateDefaultPartListRelationFilter = {
    every?: TemplateDefaultPartWhereInput
    some?: TemplateDefaultPartWhereInput
    none?: TemplateDefaultPartWhereInput
  }

  export type CreditNoteItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POSQuotationItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POSSaleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateDefaultPartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartUnique_sku_per_tenantCompoundUniqueInput = {
    sku: string
    tenantId: string
  }

  export type PartCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    category?: SortOrder
    location?: SortOrder
    minStock?: SortOrder
  }

  export type PartAvgOrderByAggregateInput = {
    quantity?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    minStock?: SortOrder
  }

  export type PartMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    category?: SortOrder
    location?: SortOrder
    minStock?: SortOrder
  }

  export type PartMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    quantity?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    category?: SortOrder
    location?: SortOrder
    minStock?: SortOrder
  }

  export type PartSumOrderByAggregateInput = {
    quantity?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    minStock?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    receivedDate?: SortOrder
    totalCost?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    receivedDate?: SortOrder
    totalCost?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    receivedDate?: SortOrder
    totalCost?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type EnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type PartScalarRelationFilter = {
    is?: PartWhereInput
    isNot?: PartWhereInput
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseItemCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    partId?: SortOrder
    purchaseOrderId?: SortOrder
  }

  export type PurchaseItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    partId?: SortOrder
    purchaseOrderId?: SortOrder
  }

  export type PurchaseItemMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    partId?: SortOrder
    purchaseOrderId?: SortOrder
  }

  export type PurchaseItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type PartUsageCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    ticketId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
  }

  export type PartUsageAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PartUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    ticketId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
  }

  export type PartUsageMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    ticketId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
  }

  export type PartUsageSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type EnumAuditModuleFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditModule | EnumAuditModuleFieldRefInput<$PrismaModel>
    in?: $Enums.AuditModule[] | ListEnumAuditModuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditModule[] | ListEnumAuditModuleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditModuleFilter<$PrismaModel> | $Enums.AuditModule
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    details?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    details?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    details?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type EnumAuditModuleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditModule | EnumAuditModuleFieldRefInput<$PrismaModel>
    in?: $Enums.AuditModule[] | ListEnumAuditModuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditModule[] | ListEnumAuditModuleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditModuleWithAggregatesFilter<$PrismaModel> | $Enums.AuditModule
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditModuleFilter<$PrismaModel>
    _max?: NestedEnumAuditModuleFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type TicketNoteCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketNoteMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isInternal?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ServiceTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultTitle?: SortOrder
    defaultDescription?: SortOrder
    defaultPriority?: SortOrder
    estimatedDuration?: SortOrder
    laborCost?: SortOrder
    isActive?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTemplateAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    laborCost?: SortOrder
  }

  export type ServiceTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultTitle?: SortOrder
    defaultDescription?: SortOrder
    defaultPriority?: SortOrder
    estimatedDuration?: SortOrder
    laborCost?: SortOrder
    isActive?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    defaultTitle?: SortOrder
    defaultDescription?: SortOrder
    defaultPriority?: SortOrder
    estimatedDuration?: SortOrder
    laborCost?: SortOrder
    isActive?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTemplateSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    laborCost?: SortOrder
  }

  export type EnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ServiceTemplateScalarRelationFilter = {
    is?: ServiceTemplateWhereInput
    isNot?: ServiceTemplateWhereInput
  }

  export type TemplateDefaultPartCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    required?: SortOrder
    templateId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
  }

  export type TemplateDefaultPartAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type TemplateDefaultPartMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    required?: SortOrder
    templateId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
  }

  export type TemplateDefaultPartMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    required?: SortOrder
    templateId?: SortOrder
    partId?: SortOrder
    createdAt?: SortOrder
  }

  export type TemplateDefaultPartSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type TicketServiceCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    laborCost?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketServiceAvgOrderByAggregateInput = {
    laborCost?: SortOrder
  }

  export type TicketServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    laborCost?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketServiceMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    laborCost?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketServiceSumOrderByAggregateInput = {
    laborCost?: SortOrder
  }

  export type EnumSpecializationFilter<$PrismaModel = never> = {
    equals?: $Enums.Specialization | EnumSpecializationFieldRefInput<$PrismaModel>
    in?: $Enums.Specialization[] | ListEnumSpecializationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Specialization[] | ListEnumSpecializationFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecializationFilter<$PrismaModel> | $Enums.Specialization
  }

  export type TechnicianSpecializationUserIdSpecializationCompoundUniqueInput = {
    userId: string
    specialization: $Enums.Specialization
  }

  export type TechnicianSpecializationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicianSpecializationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    createdAt?: SortOrder
  }

  export type TechnicianSpecializationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSpecializationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Specialization | EnumSpecializationFieldRefInput<$PrismaModel>
    in?: $Enums.Specialization[] | ListEnumSpecializationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Specialization[] | ListEnumSpecializationFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecializationWithAggregatesFilter<$PrismaModel> | $Enums.Specialization
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpecializationFilter<$PrismaModel>
    _max?: NestedEnumSpecializationFilter<$PrismaModel>
  }

  export type TechnicianUnavailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TechnicianUnavailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TechnicianUnavailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceUnique_invoice_number_per_tenantCompoundUniqueInput = {
    invoiceNumber: string
    tenantId: string
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    ticketId?: SortOrder
    customerId?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    partsMarkup?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    customerName?: SortOrder
    customerNIT?: SortOrder
    customerDPI?: SortOrder
    customerAddress?: SortOrder
    notes?: SortOrder
    paymentTerms?: SortOrder
    issuedAt?: SortOrder
    dueAt?: SortOrder
    paidAt?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    laborCost?: SortOrder
    partsCost?: SortOrder
    partsMarkup?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    ticketId?: SortOrder
    customerId?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    partsMarkup?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    customerName?: SortOrder
    customerNIT?: SortOrder
    customerDPI?: SortOrder
    customerAddress?: SortOrder
    notes?: SortOrder
    paymentTerms?: SortOrder
    issuedAt?: SortOrder
    dueAt?: SortOrder
    paidAt?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    status?: SortOrder
    ticketId?: SortOrder
    customerId?: SortOrder
    laborCost?: SortOrder
    partsCost?: SortOrder
    partsMarkup?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    customerName?: SortOrder
    customerNIT?: SortOrder
    customerDPI?: SortOrder
    customerAddress?: SortOrder
    notes?: SortOrder
    paymentTerms?: SortOrder
    issuedAt?: SortOrder
    dueAt?: SortOrder
    paidAt?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    laborCost?: SortOrder
    partsCost?: SortOrder
    partsMarkup?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type PaymentUnique_payment_number_per_tenantCompoundUniqueInput = {
    paymentNumber: string
    tenantId: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionRef?: SortOrder
    notes?: SortOrder
    paidAt?: SortOrder
    tenantId?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionRef?: SortOrder
    notes?: SortOrder
    paidAt?: SortOrder
    tenantId?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionRef?: SortOrder
    notes?: SortOrder
    paidAt?: SortOrder
    tenantId?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type CashRegisterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isOpen?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    expectedBalance?: SortOrder
    difference?: SortOrder
    closingNotes?: SortOrder
    tenantId?: SortOrder
    openedById?: SortOrder
    closedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashRegisterAvgOrderByAggregateInput = {
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    expectedBalance?: SortOrder
    difference?: SortOrder
  }

  export type CashRegisterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isOpen?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    expectedBalance?: SortOrder
    difference?: SortOrder
    closingNotes?: SortOrder
    tenantId?: SortOrder
    openedById?: SortOrder
    closedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashRegisterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isOpen?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    expectedBalance?: SortOrder
    difference?: SortOrder
    closingNotes?: SortOrder
    tenantId?: SortOrder
    openedById?: SortOrder
    closedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CashRegisterSumOrderByAggregateInput = {
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    expectedBalance?: SortOrder
    difference?: SortOrder
  }

  export type CashRegisterScalarRelationFilter = {
    is?: CashRegisterWhereInput
    isNot?: CashRegisterWhereInput
  }

  export type CashTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    cashRegisterId?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type CashTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CashTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    cashRegisterId?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type CashTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    cashRegisterId?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type CashTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TenantSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    businessName?: SortOrder
    businessNIT?: SortOrder
    businessAddress?: SortOrder
    businessPhone?: SortOrder
    businessEmail?: SortOrder
    taxRate?: SortOrder
    taxName?: SortOrder
    currency?: SortOrder
    defaultPaymentTerms?: SortOrder
    invoiceFooter?: SortOrder
    slaWarningPercent?: SortOrder
    slaCriticalPercent?: SortOrder
    slaEmailEnabled?: SortOrder
    slaInAppEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSettingsAvgOrderByAggregateInput = {
    taxRate?: SortOrder
    slaWarningPercent?: SortOrder
    slaCriticalPercent?: SortOrder
  }

  export type TenantSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    businessName?: SortOrder
    businessNIT?: SortOrder
    businessAddress?: SortOrder
    businessPhone?: SortOrder
    businessEmail?: SortOrder
    taxRate?: SortOrder
    taxName?: SortOrder
    currency?: SortOrder
    defaultPaymentTerms?: SortOrder
    invoiceFooter?: SortOrder
    slaWarningPercent?: SortOrder
    slaCriticalPercent?: SortOrder
    slaEmailEnabled?: SortOrder
    slaInAppEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    businessName?: SortOrder
    businessNIT?: SortOrder
    businessAddress?: SortOrder
    businessPhone?: SortOrder
    businessEmail?: SortOrder
    taxRate?: SortOrder
    taxName?: SortOrder
    currency?: SortOrder
    defaultPaymentTerms?: SortOrder
    invoiceFooter?: SortOrder
    slaWarningPercent?: SortOrder
    slaCriticalPercent?: SortOrder
    slaEmailEnabled?: SortOrder
    slaInAppEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSettingsSumOrderByAggregateInput = {
    taxRate?: SortOrder
    slaWarningPercent?: SortOrder
    slaCriticalPercent?: SortOrder
  }

  export type InvoiceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    action?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    action?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    action?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPOSSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.POSSaleStatus | EnumPOSSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POSSaleStatus[] | ListEnumPOSSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POSSaleStatus[] | ListEnumPOSSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOSSaleStatusFilter<$PrismaModel> | $Enums.POSSaleStatus
  }

  export type CashRegisterNullableScalarRelationFilter = {
    is?: CashRegisterWhereInput | null
    isNot?: CashRegisterWhereInput | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type POSSalePaymentListRelationFilter = {
    every?: POSSalePaymentWhereInput
    some?: POSSalePaymentWhereInput
    none?: POSSalePaymentWhereInput
  }

  export type POSQuotationNullableScalarRelationFilter = {
    is?: POSQuotationWhereInput | null
    isNot?: POSQuotationWhereInput | null
  }

  export type POSSalePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POSSaleSaleNumberTenantIdCompoundUniqueInput = {
    saleNumber: string
    tenantId: string
  }

  export type POSSaleCountOrderByAggregateInput = {
    id?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    amountPaid?: SortOrder
    changeGiven?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    cashRegisterId?: SortOrder
    createdById?: SortOrder
    quotationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSSaleAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    amountPaid?: SortOrder
    changeGiven?: SortOrder
  }

  export type POSSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    amountPaid?: SortOrder
    changeGiven?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    cashRegisterId?: SortOrder
    createdById?: SortOrder
    quotationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSSaleMinOrderByAggregateInput = {
    id?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    amountPaid?: SortOrder
    changeGiven?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    cashRegisterId?: SortOrder
    createdById?: SortOrder
    quotationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSSaleSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    amountPaid?: SortOrder
    changeGiven?: SortOrder
  }

  export type EnumPOSSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POSSaleStatus | EnumPOSSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POSSaleStatus[] | ListEnumPOSSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POSSaleStatus[] | ListEnumPOSSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOSSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.POSSaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOSSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumPOSSaleStatusFilter<$PrismaModel>
  }

  export type POSSaleScalarRelationFilter = {
    is?: POSSaleWhereInput
    isNot?: POSSaleWhereInput
  }

  export type POSSaleItemCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSSaleItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSSaleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSSaleItemMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSSaleItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSSalePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type POSSalePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type POSSalePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type POSSalePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type POSSalePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumQuotationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusFilter<$PrismaModel> | $Enums.QuotationStatus
  }

  export type POSSaleNullableScalarRelationFilter = {
    is?: POSSaleWhereInput | null
    isNot?: POSSaleWhereInput | null
  }

  export type POSQuotationQuotationNumberTenantIdCompoundUniqueInput = {
    quotationNumber: string
    tenantId: string
  }

  export type POSQuotationCountOrderByAggregateInput = {
    id?: SortOrder
    quotationNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSQuotationAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
  }

  export type POSQuotationMaxOrderByAggregateInput = {
    id?: SortOrder
    quotationNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSQuotationMinOrderByAggregateInput = {
    id?: SortOrder
    quotationNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type POSQuotationSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
  }

  export type EnumQuotationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationStatusFilter<$PrismaModel>
  }

  export type POSQuotationScalarRelationFilter = {
    is?: POSQuotationWhereInput
    isNot?: POSQuotationWhereInput
  }

  export type POSQuotationItemCountOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSQuotationItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSQuotationItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSQuotationItemMinOrderByAggregateInput = {
    id?: SortOrder
    quotationId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type POSQuotationItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
  }

  export type EnumCreditNoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusFilter<$PrismaModel> | $Enums.CreditNoteStatus
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type CreditNoteCreditNoteNumberTenantIdCompoundUniqueInput = {
    creditNoteNumber: string
    tenantId: string
  }

  export type CreditNoteCountOrderByAggregateInput = {
    id?: SortOrder
    creditNoteNumber?: SortOrder
    posSaleId?: SortOrder
    customerId?: SortOrder
    reason?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    refundMethod?: SortOrder
    refundReference?: SortOrder
    notes?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditNoteAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type CreditNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    creditNoteNumber?: SortOrder
    posSaleId?: SortOrder
    customerId?: SortOrder
    reason?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    refundMethod?: SortOrder
    refundReference?: SortOrder
    notes?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditNoteMinOrderByAggregateInput = {
    id?: SortOrder
    creditNoteNumber?: SortOrder
    posSaleId?: SortOrder
    customerId?: SortOrder
    reason?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    refundMethod?: SortOrder
    refundReference?: SortOrder
    notes?: SortOrder
    processedAt?: SortOrder
    processedById?: SortOrder
    tenantId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditNoteSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type EnumCreditNoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditNoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type CreditNoteScalarRelationFilter = {
    is?: CreditNoteWhereInput
    isNot?: CreditNoteWhereInput
  }

  export type CreditNoteItemCountOrderByAggregateInput = {
    id?: SortOrder
    creditNoteId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    reason?: SortOrder
  }

  export type CreditNoteItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type CreditNoteItemMaxOrderByAggregateInput = {
    id?: SortOrder
    creditNoteId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    reason?: SortOrder
  }

  export type CreditNoteItemMinOrderByAggregateInput = {
    id?: SortOrder
    creditNoteId?: SortOrder
    partId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    reason?: SortOrder
  }

  export type CreditNoteItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type SessionLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    loginAt?: SortOrder
    lastActivityAt?: SortOrder
    logoutAt?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
  }

  export type SessionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    loginAt?: SortOrder
    lastActivityAt?: SortOrder
    logoutAt?: SortOrder
    status?: SortOrder
  }

  export type SessionLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    loginAt?: SortOrder
    lastActivityAt?: SortOrder
    logoutAt?: SortOrder
    status?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type EnumPresenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PresenceStatus | EnumPresenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPresenceStatusFilter<$PrismaModel> | $Enums.PresenceStatus
  }

  export type TicketNullableScalarRelationFilter = {
    is?: TicketWhereInput | null
    isNot?: TicketWhereInput | null
  }

  export type UserPresenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    currentRoute?: SortOrder
    currentPage?: SortOrder
    currentTicketId?: SortOrder
    lastSeenAt?: SortOrder
    metadata?: SortOrder
  }

  export type UserPresenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    currentRoute?: SortOrder
    currentPage?: SortOrder
    currentTicketId?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type UserPresenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    currentRoute?: SortOrder
    currentPage?: SortOrder
    currentTicketId?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type EnumPresenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PresenceStatus | EnumPresenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPresenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.PresenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPresenceStatusFilter<$PrismaModel>
    _max?: NestedEnumPresenceStatusFilter<$PrismaModel>
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<SessionLogCreateWithoutTenantInput, SessionLogUncheckedCreateWithoutTenantInput> | SessionLogCreateWithoutTenantInput[] | SessionLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutTenantInput | SessionLogCreateOrConnectWithoutTenantInput[]
    createMany?: SessionLogCreateManyTenantInputEnvelope
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
  }

  export type UserPresenceCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserPresenceCreateWithoutTenantInput, UserPresenceUncheckedCreateWithoutTenantInput> | UserPresenceCreateWithoutTenantInput[] | UserPresenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserPresenceCreateOrConnectWithoutTenantInput | UserPresenceCreateOrConnectWithoutTenantInput[]
    createMany?: UserPresenceCreateManyTenantInputEnvelope
    connect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
  }

  export type CashRegisterCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput> | CashRegisterCreateWithoutTenantInput[] | CashRegisterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTenantInput | CashRegisterCreateOrConnectWithoutTenantInput[]
    createMany?: CashRegisterCreateManyTenantInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type CashTransactionCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashTransactionCreateWithoutTenantInput, CashTransactionUncheckedCreateWithoutTenantInput> | CashTransactionCreateWithoutTenantInput[] | CashTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutTenantInput | CashTransactionCreateOrConnectWithoutTenantInput[]
    createMany?: CashTransactionCreateManyTenantInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CreditNoteCreateNestedManyWithoutTenantInput = {
    create?: XOR<CreditNoteCreateWithoutTenantInput, CreditNoteUncheckedCreateWithoutTenantInput> | CreditNoteCreateWithoutTenantInput[] | CreditNoteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutTenantInput | CreditNoteCreateOrConnectWithoutTenantInput[]
    createMany?: CreditNoteCreateManyTenantInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PartCreateNestedManyWithoutTenantInput = {
    create?: XOR<PartCreateWithoutTenantInput, PartUncheckedCreateWithoutTenantInput> | PartCreateWithoutTenantInput[] | PartUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PartCreateOrConnectWithoutTenantInput | PartCreateOrConnectWithoutTenantInput[]
    createMany?: PartCreateManyTenantInputEnvelope
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type POSSaleCreateNestedManyWithoutTenantInput = {
    create?: XOR<POSSaleCreateWithoutTenantInput, POSSaleUncheckedCreateWithoutTenantInput> | POSSaleCreateWithoutTenantInput[] | POSSaleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutTenantInput | POSSaleCreateOrConnectWithoutTenantInput[]
    createMany?: POSSaleCreateManyTenantInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type POSQuotationCreateNestedManyWithoutTenantInput = {
    create?: XOR<POSQuotationCreateWithoutTenantInput, POSQuotationUncheckedCreateWithoutTenantInput> | POSQuotationCreateWithoutTenantInput[] | POSQuotationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutTenantInput | POSQuotationCreateOrConnectWithoutTenantInput[]
    createMany?: POSQuotationCreateManyTenantInputEnvelope
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type ServiceTemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<ServiceTemplateCreateWithoutTenantInput, ServiceTemplateUncheckedCreateWithoutTenantInput> | ServiceTemplateCreateWithoutTenantInput[] | ServiceTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutTenantInput | ServiceTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ServiceTemplateCreateManyTenantInputEnvelope
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
  }

  export type TenantSettingsCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantSettingsCreateOrConnectWithoutTenantInput
    connect?: TenantSettingsWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutTenantInput = {
    create?: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput> | TicketCreateWithoutTenantInput[] | TicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTenantInput | TicketCreateOrConnectWithoutTenantInput[]
    createMany?: TicketCreateManyTenantInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SessionLogCreateWithoutTenantInput, SessionLogUncheckedCreateWithoutTenantInput> | SessionLogCreateWithoutTenantInput[] | SessionLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutTenantInput | SessionLogCreateOrConnectWithoutTenantInput[]
    createMany?: SessionLogCreateManyTenantInputEnvelope
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
  }

  export type UserPresenceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserPresenceCreateWithoutTenantInput, UserPresenceUncheckedCreateWithoutTenantInput> | UserPresenceCreateWithoutTenantInput[] | UserPresenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserPresenceCreateOrConnectWithoutTenantInput | UserPresenceCreateOrConnectWithoutTenantInput[]
    createMany?: UserPresenceCreateManyTenantInputEnvelope
    connect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
  }

  export type CashRegisterUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput> | CashRegisterCreateWithoutTenantInput[] | CashRegisterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTenantInput | CashRegisterCreateOrConnectWithoutTenantInput[]
    createMany?: CashRegisterCreateManyTenantInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CashTransactionCreateWithoutTenantInput, CashTransactionUncheckedCreateWithoutTenantInput> | CashTransactionCreateWithoutTenantInput[] | CashTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutTenantInput | CashTransactionCreateOrConnectWithoutTenantInput[]
    createMany?: CashTransactionCreateManyTenantInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CreditNoteUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CreditNoteCreateWithoutTenantInput, CreditNoteUncheckedCreateWithoutTenantInput> | CreditNoteCreateWithoutTenantInput[] | CreditNoteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutTenantInput | CreditNoteCreateOrConnectWithoutTenantInput[]
    createMany?: CreditNoteCreateManyTenantInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PartUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PartCreateWithoutTenantInput, PartUncheckedCreateWithoutTenantInput> | PartCreateWithoutTenantInput[] | PartUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PartCreateOrConnectWithoutTenantInput | PartCreateOrConnectWithoutTenantInput[]
    createMany?: PartCreateManyTenantInputEnvelope
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type POSSaleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<POSSaleCreateWithoutTenantInput, POSSaleUncheckedCreateWithoutTenantInput> | POSSaleCreateWithoutTenantInput[] | POSSaleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutTenantInput | POSSaleCreateOrConnectWithoutTenantInput[]
    createMany?: POSSaleCreateManyTenantInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type POSQuotationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<POSQuotationCreateWithoutTenantInput, POSQuotationUncheckedCreateWithoutTenantInput> | POSQuotationCreateWithoutTenantInput[] | POSQuotationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutTenantInput | POSQuotationCreateOrConnectWithoutTenantInput[]
    createMany?: POSQuotationCreateManyTenantInputEnvelope
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ServiceTemplateCreateWithoutTenantInput, ServiceTemplateUncheckedCreateWithoutTenantInput> | ServiceTemplateCreateWithoutTenantInput[] | ServiceTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutTenantInput | ServiceTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ServiceTemplateCreateManyTenantInputEnvelope
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
  }

  export type TenantSettingsUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantSettingsCreateOrConnectWithoutTenantInput
    connect?: TenantSettingsWhereUniqueInput
  }

  export type TicketUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput> | TicketCreateWithoutTenantInput[] | TicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTenantInput | TicketCreateOrConnectWithoutTenantInput[]
    createMany?: TicketCreateManyTenantInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SessionLogCreateWithoutTenantInput, SessionLogUncheckedCreateWithoutTenantInput> | SessionLogCreateWithoutTenantInput[] | SessionLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutTenantInput | SessionLogCreateOrConnectWithoutTenantInput[]
    upsert?: SessionLogUpsertWithWhereUniqueWithoutTenantInput | SessionLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SessionLogCreateManyTenantInputEnvelope
    set?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    disconnect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    delete?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    update?: SessionLogUpdateWithWhereUniqueWithoutTenantInput | SessionLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SessionLogUpdateManyWithWhereWithoutTenantInput | SessionLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
  }

  export type UserPresenceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserPresenceCreateWithoutTenantInput, UserPresenceUncheckedCreateWithoutTenantInput> | UserPresenceCreateWithoutTenantInput[] | UserPresenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserPresenceCreateOrConnectWithoutTenantInput | UserPresenceCreateOrConnectWithoutTenantInput[]
    upsert?: UserPresenceUpsertWithWhereUniqueWithoutTenantInput | UserPresenceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserPresenceCreateManyTenantInputEnvelope
    set?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    disconnect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    delete?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    connect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    update?: UserPresenceUpdateWithWhereUniqueWithoutTenantInput | UserPresenceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserPresenceUpdateManyWithWhereWithoutTenantInput | UserPresenceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserPresenceScalarWhereInput | UserPresenceScalarWhereInput[]
  }

  export type CashRegisterUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput> | CashRegisterCreateWithoutTenantInput[] | CashRegisterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTenantInput | CashRegisterCreateOrConnectWithoutTenantInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutTenantInput | CashRegisterUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashRegisterCreateManyTenantInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutTenantInput | CashRegisterUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutTenantInput | CashRegisterUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type CashTransactionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashTransactionCreateWithoutTenantInput, CashTransactionUncheckedCreateWithoutTenantInput> | CashTransactionCreateWithoutTenantInput[] | CashTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutTenantInput | CashTransactionCreateOrConnectWithoutTenantInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutTenantInput | CashTransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashTransactionCreateManyTenantInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutTenantInput | CashTransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutTenantInput | CashTransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CreditNoteUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CreditNoteCreateWithoutTenantInput, CreditNoteUncheckedCreateWithoutTenantInput> | CreditNoteCreateWithoutTenantInput[] | CreditNoteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutTenantInput | CreditNoteCreateOrConnectWithoutTenantInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutTenantInput | CreditNoteUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CreditNoteCreateManyTenantInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutTenantInput | CreditNoteUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutTenantInput | CreditNoteUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PartUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PartCreateWithoutTenantInput, PartUncheckedCreateWithoutTenantInput> | PartCreateWithoutTenantInput[] | PartUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PartCreateOrConnectWithoutTenantInput | PartCreateOrConnectWithoutTenantInput[]
    upsert?: PartUpsertWithWhereUniqueWithoutTenantInput | PartUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PartCreateManyTenantInputEnvelope
    set?: PartWhereUniqueInput | PartWhereUniqueInput[]
    disconnect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    delete?: PartWhereUniqueInput | PartWhereUniqueInput[]
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    update?: PartUpdateWithWhereUniqueWithoutTenantInput | PartUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PartUpdateManyWithWhereWithoutTenantInput | PartUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PartScalarWhereInput | PartScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type POSSaleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<POSSaleCreateWithoutTenantInput, POSSaleUncheckedCreateWithoutTenantInput> | POSSaleCreateWithoutTenantInput[] | POSSaleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutTenantInput | POSSaleCreateOrConnectWithoutTenantInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutTenantInput | POSSaleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: POSSaleCreateManyTenantInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutTenantInput | POSSaleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutTenantInput | POSSaleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type POSQuotationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<POSQuotationCreateWithoutTenantInput, POSQuotationUncheckedCreateWithoutTenantInput> | POSQuotationCreateWithoutTenantInput[] | POSQuotationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutTenantInput | POSQuotationCreateOrConnectWithoutTenantInput[]
    upsert?: POSQuotationUpsertWithWhereUniqueWithoutTenantInput | POSQuotationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: POSQuotationCreateManyTenantInputEnvelope
    set?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    disconnect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    delete?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    update?: POSQuotationUpdateWithWhereUniqueWithoutTenantInput | POSQuotationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: POSQuotationUpdateManyWithWhereWithoutTenantInput | POSQuotationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: POSQuotationScalarWhereInput | POSQuotationScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput | PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput | PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutTenantInput | PurchaseOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type ServiceTemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutTenantInput, ServiceTemplateUncheckedCreateWithoutTenantInput> | ServiceTemplateCreateWithoutTenantInput[] | ServiceTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutTenantInput | ServiceTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ServiceTemplateUpsertWithWhereUniqueWithoutTenantInput | ServiceTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ServiceTemplateCreateManyTenantInputEnvelope
    set?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    disconnect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    delete?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    update?: ServiceTemplateUpdateWithWhereUniqueWithoutTenantInput | ServiceTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ServiceTemplateUpdateManyWithWhereWithoutTenantInput | ServiceTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ServiceTemplateScalarWhereInput | ServiceTemplateScalarWhereInput[]
  }

  export type TenantSettingsUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantSettingsCreateOrConnectWithoutTenantInput
    upsert?: TenantSettingsUpsertWithoutTenantInput
    disconnect?: TenantSettingsWhereInput | boolean
    delete?: TenantSettingsWhereInput | boolean
    connect?: TenantSettingsWhereUniqueInput
    update?: XOR<XOR<TenantSettingsUpdateToOneWithWhereWithoutTenantInput, TenantSettingsUpdateWithoutTenantInput>, TenantSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type TicketUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput> | TicketCreateWithoutTenantInput[] | TicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTenantInput | TicketCreateOrConnectWithoutTenantInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTenantInput | TicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TicketCreateManyTenantInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTenantInput | TicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTenantInput | TicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SessionLogCreateWithoutTenantInput, SessionLogUncheckedCreateWithoutTenantInput> | SessionLogCreateWithoutTenantInput[] | SessionLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutTenantInput | SessionLogCreateOrConnectWithoutTenantInput[]
    upsert?: SessionLogUpsertWithWhereUniqueWithoutTenantInput | SessionLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SessionLogCreateManyTenantInputEnvelope
    set?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    disconnect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    delete?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    update?: SessionLogUpdateWithWhereUniqueWithoutTenantInput | SessionLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SessionLogUpdateManyWithWhereWithoutTenantInput | SessionLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
  }

  export type UserPresenceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserPresenceCreateWithoutTenantInput, UserPresenceUncheckedCreateWithoutTenantInput> | UserPresenceCreateWithoutTenantInput[] | UserPresenceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserPresenceCreateOrConnectWithoutTenantInput | UserPresenceCreateOrConnectWithoutTenantInput[]
    upsert?: UserPresenceUpsertWithWhereUniqueWithoutTenantInput | UserPresenceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserPresenceCreateManyTenantInputEnvelope
    set?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    disconnect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    delete?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    connect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    update?: UserPresenceUpdateWithWhereUniqueWithoutTenantInput | UserPresenceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserPresenceUpdateManyWithWhereWithoutTenantInput | UserPresenceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserPresenceScalarWhereInput | UserPresenceScalarWhereInput[]
  }

  export type CashRegisterUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput> | CashRegisterCreateWithoutTenantInput[] | CashRegisterUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTenantInput | CashRegisterCreateOrConnectWithoutTenantInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutTenantInput | CashRegisterUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashRegisterCreateManyTenantInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutTenantInput | CashRegisterUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutTenantInput | CashRegisterUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CashTransactionCreateWithoutTenantInput, CashTransactionUncheckedCreateWithoutTenantInput> | CashTransactionCreateWithoutTenantInput[] | CashTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutTenantInput | CashTransactionCreateOrConnectWithoutTenantInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutTenantInput | CashTransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CashTransactionCreateManyTenantInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutTenantInput | CashTransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutTenantInput | CashTransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CreditNoteUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CreditNoteCreateWithoutTenantInput, CreditNoteUncheckedCreateWithoutTenantInput> | CreditNoteCreateWithoutTenantInput[] | CreditNoteUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutTenantInput | CreditNoteCreateOrConnectWithoutTenantInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutTenantInput | CreditNoteUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CreditNoteCreateManyTenantInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutTenantInput | CreditNoteUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutTenantInput | CreditNoteUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PartUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PartCreateWithoutTenantInput, PartUncheckedCreateWithoutTenantInput> | PartCreateWithoutTenantInput[] | PartUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PartCreateOrConnectWithoutTenantInput | PartCreateOrConnectWithoutTenantInput[]
    upsert?: PartUpsertWithWhereUniqueWithoutTenantInput | PartUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PartCreateManyTenantInputEnvelope
    set?: PartWhereUniqueInput | PartWhereUniqueInput[]
    disconnect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    delete?: PartWhereUniqueInput | PartWhereUniqueInput[]
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    update?: PartUpdateWithWhereUniqueWithoutTenantInput | PartUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PartUpdateManyWithWhereWithoutTenantInput | PartUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PartScalarWhereInput | PartScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type POSSaleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<POSSaleCreateWithoutTenantInput, POSSaleUncheckedCreateWithoutTenantInput> | POSSaleCreateWithoutTenantInput[] | POSSaleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutTenantInput | POSSaleCreateOrConnectWithoutTenantInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutTenantInput | POSSaleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: POSSaleCreateManyTenantInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutTenantInput | POSSaleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutTenantInput | POSSaleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type POSQuotationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<POSQuotationCreateWithoutTenantInput, POSQuotationUncheckedCreateWithoutTenantInput> | POSQuotationCreateWithoutTenantInput[] | POSQuotationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutTenantInput | POSQuotationCreateOrConnectWithoutTenantInput[]
    upsert?: POSQuotationUpsertWithWhereUniqueWithoutTenantInput | POSQuotationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: POSQuotationCreateManyTenantInputEnvelope
    set?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    disconnect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    delete?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    update?: POSQuotationUpdateWithWhereUniqueWithoutTenantInput | POSQuotationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: POSQuotationUpdateManyWithWhereWithoutTenantInput | POSQuotationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: POSQuotationScalarWhereInput | POSQuotationScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput | PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput | PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutTenantInput | PurchaseOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutTenantInput, ServiceTemplateUncheckedCreateWithoutTenantInput> | ServiceTemplateCreateWithoutTenantInput[] | ServiceTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutTenantInput | ServiceTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ServiceTemplateUpsertWithWhereUniqueWithoutTenantInput | ServiceTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ServiceTemplateCreateManyTenantInputEnvelope
    set?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    disconnect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    delete?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    update?: ServiceTemplateUpdateWithWhereUniqueWithoutTenantInput | ServiceTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ServiceTemplateUpdateManyWithWhereWithoutTenantInput | ServiceTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ServiceTemplateScalarWhereInput | ServiceTemplateScalarWhereInput[]
  }

  export type TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantSettingsCreateOrConnectWithoutTenantInput
    upsert?: TenantSettingsUpsertWithoutTenantInput
    disconnect?: TenantSettingsWhereInput | boolean
    delete?: TenantSettingsWhereInput | boolean
    connect?: TenantSettingsWhereUniqueInput
    update?: XOR<XOR<TenantSettingsUpdateToOneWithWhereWithoutTenantInput, TenantSettingsUpdateWithoutTenantInput>, TenantSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type TicketUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput> | TicketCreateWithoutTenantInput[] | TicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTenantInput | TicketCreateOrConnectWithoutTenantInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTenantInput | TicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TicketCreateManyTenantInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTenantInput | TicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTenantInput | TicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUsersCreatedInput = {
    create?: XOR<UserCreateWithoutUsersCreatedInput, UserUncheckedCreateWithoutUsersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUsersUpdatedInput = {
    create?: XOR<UserCreateWithoutUsersUpdatedInput, UserUncheckedCreateWithoutUsersUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersUpdatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput> | SessionLogCreateWithoutUserInput[] | SessionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutUserInput | SessionLogCreateOrConnectWithoutUserInput[]
    createMany?: SessionLogCreateManyUserInputEnvelope
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
  }

  export type UserPresenceCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPresenceCreateOrConnectWithoutUserInput
    connect?: UserPresenceWhereUniqueInput
  }

  export type CashRegisterCreateNestedManyWithoutClosedByInput = {
    create?: XOR<CashRegisterCreateWithoutClosedByInput, CashRegisterUncheckedCreateWithoutClosedByInput> | CashRegisterCreateWithoutClosedByInput[] | CashRegisterUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutClosedByInput | CashRegisterCreateOrConnectWithoutClosedByInput[]
    createMany?: CashRegisterCreateManyClosedByInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type CashRegisterCreateNestedManyWithoutOpenedByInput = {
    create?: XOR<CashRegisterCreateWithoutOpenedByInput, CashRegisterUncheckedCreateWithoutOpenedByInput> | CashRegisterCreateWithoutOpenedByInput[] | CashRegisterUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutOpenedByInput | CashRegisterCreateOrConnectWithoutOpenedByInput[]
    createMany?: CashRegisterCreateManyOpenedByInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type CashTransactionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CashTransactionCreateWithoutCreatedByInput, CashTransactionUncheckedCreateWithoutCreatedByInput> | CashTransactionCreateWithoutCreatedByInput[] | CashTransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCreatedByInput | CashTransactionCreateOrConnectWithoutCreatedByInput[]
    createMany?: CashTransactionCreateManyCreatedByInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CreditNoteCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CreditNoteCreateWithoutCreatedByInput, CreditNoteUncheckedCreateWithoutCreatedByInput> | CreditNoteCreateWithoutCreatedByInput[] | CreditNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutCreatedByInput | CreditNoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: CreditNoteCreateManyCreatedByInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type CreditNoteCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<CreditNoteCreateWithoutProcessedByInput, CreditNoteUncheckedCreateWithoutProcessedByInput> | CreditNoteCreateWithoutProcessedByInput[] | CreditNoteUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutProcessedByInput | CreditNoteCreateOrConnectWithoutProcessedByInput[]
    createMany?: CreditNoteCreateManyProcessedByInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput> | CustomerCreateWithoutCreatedByInput[] | CustomerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatedByInput | CustomerCreateOrConnectWithoutCreatedByInput[]
    createMany?: CustomerCreateManyCreatedByInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<CustomerCreateWithoutUpdatedByInput, CustomerUncheckedCreateWithoutUpdatedByInput> | CustomerCreateWithoutUpdatedByInput[] | CustomerUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUpdatedByInput | CustomerCreateOrConnectWithoutUpdatedByInput[]
    createMany?: CustomerCreateManyUpdatedByInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<InvoiceCreateWithoutUpdatedByInput, InvoiceUncheckedCreateWithoutUpdatedByInput> | InvoiceCreateWithoutUpdatedByInput[] | InvoiceUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUpdatedByInput | InvoiceCreateOrConnectWithoutUpdatedByInput[]
    createMany?: InvoiceCreateManyUpdatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceHistoryCreateWithoutUserInput, InvoiceHistoryUncheckedCreateWithoutUserInput> | InvoiceHistoryCreateWithoutUserInput[] | InvoiceHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceHistoryCreateOrConnectWithoutUserInput | InvoiceHistoryCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceHistoryCreateManyUserInputEnvelope
    connect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PartCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PartCreateWithoutCreatedByInput, PartUncheckedCreateWithoutCreatedByInput> | PartCreateWithoutCreatedByInput[] | PartUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PartCreateOrConnectWithoutCreatedByInput | PartCreateOrConnectWithoutCreatedByInput[]
    createMany?: PartCreateManyCreatedByInputEnvelope
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
  }

  export type PartCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PartCreateWithoutUpdatedByInput, PartUncheckedCreateWithoutUpdatedByInput> | PartCreateWithoutUpdatedByInput[] | PartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PartCreateOrConnectWithoutUpdatedByInput | PartCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PartCreateManyUpdatedByInputEnvelope
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
  }

  export type POSSaleCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<POSSaleCreateWithoutCreatedByInput, POSSaleUncheckedCreateWithoutCreatedByInput> | POSSaleCreateWithoutCreatedByInput[] | POSSaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCreatedByInput | POSSaleCreateOrConnectWithoutCreatedByInput[]
    createMany?: POSSaleCreateManyCreatedByInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type POSQuotationCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<POSQuotationCreateWithoutCreatedByInput, POSQuotationUncheckedCreateWithoutCreatedByInput> | POSQuotationCreateWithoutCreatedByInput[] | POSQuotationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutCreatedByInput | POSQuotationCreateOrConnectWithoutCreatedByInput[]
    createMany?: POSQuotationCreateManyCreatedByInputEnvelope
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ServiceTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ServiceTemplateCreateWithoutCreatedByInput, ServiceTemplateUncheckedCreateWithoutCreatedByInput> | ServiceTemplateCreateWithoutCreatedByInput[] | ServiceTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutCreatedByInput | ServiceTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: ServiceTemplateCreateManyCreatedByInputEnvelope
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
  }

  export type ServiceTemplateCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ServiceTemplateCreateWithoutUpdatedByInput, ServiceTemplateUncheckedCreateWithoutUpdatedByInput> | ServiceTemplateCreateWithoutUpdatedByInput[] | ServiceTemplateUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutUpdatedByInput | ServiceTemplateCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ServiceTemplateCreateManyUpdatedByInputEnvelope
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
  }

  export type TechnicianSpecializationCreateNestedManyWithoutUserInput = {
    create?: XOR<TechnicianSpecializationCreateWithoutUserInput, TechnicianSpecializationUncheckedCreateWithoutUserInput> | TechnicianSpecializationCreateWithoutUserInput[] | TechnicianSpecializationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TechnicianSpecializationCreateOrConnectWithoutUserInput | TechnicianSpecializationCreateOrConnectWithoutUserInput[]
    createMany?: TechnicianSpecializationCreateManyUserInputEnvelope
    connect?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
  }

  export type TechnicianUnavailabilityCreateNestedManyWithoutUserInput = {
    create?: XOR<TechnicianUnavailabilityCreateWithoutUserInput, TechnicianUnavailabilityUncheckedCreateWithoutUserInput> | TechnicianUnavailabilityCreateWithoutUserInput[] | TechnicianUnavailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TechnicianUnavailabilityCreateOrConnectWithoutUserInput | TechnicianUnavailabilityCreateOrConnectWithoutUserInput[]
    createMany?: TechnicianUnavailabilityCreateManyUserInputEnvelope
    connect?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
  }

  export type TicketNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketNoteCreateWithoutAuthorInput, TicketNoteUncheckedCreateWithoutAuthorInput> | TicketNoteCreateWithoutAuthorInput[] | TicketNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutAuthorInput | TicketNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketNoteCreateManyAuthorInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TicketCreateWithoutCreatedByInput, TicketUncheckedCreateWithoutCreatedByInput> | TicketCreateWithoutCreatedByInput[] | TicketUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCreatedByInput | TicketCreateOrConnectWithoutCreatedByInput[]
    createMany?: TicketCreateManyCreatedByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<TicketCreateWithoutUpdatedByInput, TicketUncheckedCreateWithoutUpdatedByInput> | TicketCreateWithoutUpdatedByInput[] | TicketUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUpdatedByInput | TicketCreateOrConnectWithoutUpdatedByInput[]
    createMany?: TicketCreateManyUpdatedByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketAttachmentCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TicketAttachmentCreateWithoutUploadedByInput, TicketAttachmentUncheckedCreateWithoutUploadedByInput> | TicketAttachmentCreateWithoutUploadedByInput[] | TicketAttachmentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUploadedByInput | TicketAttachmentCreateOrConnectWithoutUploadedByInput[]
    createMany?: TicketAttachmentCreateManyUploadedByInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SessionLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput> | SessionLogCreateWithoutUserInput[] | SessionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutUserInput | SessionLogCreateOrConnectWithoutUserInput[]
    createMany?: SessionLogCreateManyUserInputEnvelope
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
  }

  export type UserPresenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPresenceCreateOrConnectWithoutUserInput
    connect?: UserPresenceWhereUniqueInput
  }

  export type CashRegisterUncheckedCreateNestedManyWithoutClosedByInput = {
    create?: XOR<CashRegisterCreateWithoutClosedByInput, CashRegisterUncheckedCreateWithoutClosedByInput> | CashRegisterCreateWithoutClosedByInput[] | CashRegisterUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutClosedByInput | CashRegisterCreateOrConnectWithoutClosedByInput[]
    createMany?: CashRegisterCreateManyClosedByInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput = {
    create?: XOR<CashRegisterCreateWithoutOpenedByInput, CashRegisterUncheckedCreateWithoutOpenedByInput> | CashRegisterCreateWithoutOpenedByInput[] | CashRegisterUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutOpenedByInput | CashRegisterCreateOrConnectWithoutOpenedByInput[]
    createMany?: CashRegisterCreateManyOpenedByInputEnvelope
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CashTransactionCreateWithoutCreatedByInput, CashTransactionUncheckedCreateWithoutCreatedByInput> | CashTransactionCreateWithoutCreatedByInput[] | CashTransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCreatedByInput | CashTransactionCreateOrConnectWithoutCreatedByInput[]
    createMany?: CashTransactionCreateManyCreatedByInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CreditNoteCreateWithoutCreatedByInput, CreditNoteUncheckedCreateWithoutCreatedByInput> | CreditNoteCreateWithoutCreatedByInput[] | CreditNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutCreatedByInput | CreditNoteCreateOrConnectWithoutCreatedByInput[]
    createMany?: CreditNoteCreateManyCreatedByInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput = {
    create?: XOR<CreditNoteCreateWithoutProcessedByInput, CreditNoteUncheckedCreateWithoutProcessedByInput> | CreditNoteCreateWithoutProcessedByInput[] | CreditNoteUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutProcessedByInput | CreditNoteCreateOrConnectWithoutProcessedByInput[]
    createMany?: CreditNoteCreateManyProcessedByInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput> | CustomerCreateWithoutCreatedByInput[] | CustomerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatedByInput | CustomerCreateOrConnectWithoutCreatedByInput[]
    createMany?: CustomerCreateManyCreatedByInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<CustomerCreateWithoutUpdatedByInput, CustomerUncheckedCreateWithoutUpdatedByInput> | CustomerCreateWithoutUpdatedByInput[] | CustomerUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUpdatedByInput | CustomerCreateOrConnectWithoutUpdatedByInput[]
    createMany?: CustomerCreateManyUpdatedByInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<InvoiceCreateWithoutUpdatedByInput, InvoiceUncheckedCreateWithoutUpdatedByInput> | InvoiceCreateWithoutUpdatedByInput[] | InvoiceUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUpdatedByInput | InvoiceCreateOrConnectWithoutUpdatedByInput[]
    createMany?: InvoiceCreateManyUpdatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceHistoryCreateWithoutUserInput, InvoiceHistoryUncheckedCreateWithoutUserInput> | InvoiceHistoryCreateWithoutUserInput[] | InvoiceHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceHistoryCreateOrConnectWithoutUserInput | InvoiceHistoryCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceHistoryCreateManyUserInputEnvelope
    connect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PartUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PartCreateWithoutCreatedByInput, PartUncheckedCreateWithoutCreatedByInput> | PartCreateWithoutCreatedByInput[] | PartUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PartCreateOrConnectWithoutCreatedByInput | PartCreateOrConnectWithoutCreatedByInput[]
    createMany?: PartCreateManyCreatedByInputEnvelope
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
  }

  export type PartUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PartCreateWithoutUpdatedByInput, PartUncheckedCreateWithoutUpdatedByInput> | PartCreateWithoutUpdatedByInput[] | PartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PartCreateOrConnectWithoutUpdatedByInput | PartCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PartCreateManyUpdatedByInputEnvelope
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
  }

  export type POSSaleUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<POSSaleCreateWithoutCreatedByInput, POSSaleUncheckedCreateWithoutCreatedByInput> | POSSaleCreateWithoutCreatedByInput[] | POSSaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCreatedByInput | POSSaleCreateOrConnectWithoutCreatedByInput[]
    createMany?: POSSaleCreateManyCreatedByInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<POSQuotationCreateWithoutCreatedByInput, POSQuotationUncheckedCreateWithoutCreatedByInput> | POSQuotationCreateWithoutCreatedByInput[] | POSQuotationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutCreatedByInput | POSQuotationCreateOrConnectWithoutCreatedByInput[]
    createMany?: POSQuotationCreateManyCreatedByInputEnvelope
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ServiceTemplateCreateWithoutCreatedByInput, ServiceTemplateUncheckedCreateWithoutCreatedByInput> | ServiceTemplateCreateWithoutCreatedByInput[] | ServiceTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutCreatedByInput | ServiceTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: ServiceTemplateCreateManyCreatedByInputEnvelope
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
  }

  export type ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ServiceTemplateCreateWithoutUpdatedByInput, ServiceTemplateUncheckedCreateWithoutUpdatedByInput> | ServiceTemplateCreateWithoutUpdatedByInput[] | ServiceTemplateUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutUpdatedByInput | ServiceTemplateCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ServiceTemplateCreateManyUpdatedByInputEnvelope
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
  }

  export type TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TechnicianSpecializationCreateWithoutUserInput, TechnicianSpecializationUncheckedCreateWithoutUserInput> | TechnicianSpecializationCreateWithoutUserInput[] | TechnicianSpecializationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TechnicianSpecializationCreateOrConnectWithoutUserInput | TechnicianSpecializationCreateOrConnectWithoutUserInput[]
    createMany?: TechnicianSpecializationCreateManyUserInputEnvelope
    connect?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
  }

  export type TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TechnicianUnavailabilityCreateWithoutUserInput, TechnicianUnavailabilityUncheckedCreateWithoutUserInput> | TechnicianUnavailabilityCreateWithoutUserInput[] | TechnicianUnavailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TechnicianUnavailabilityCreateOrConnectWithoutUserInput | TechnicianUnavailabilityCreateOrConnectWithoutUserInput[]
    createMany?: TechnicianUnavailabilityCreateManyUserInputEnvelope
    connect?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
  }

  export type TicketNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketNoteCreateWithoutAuthorInput, TicketNoteUncheckedCreateWithoutAuthorInput> | TicketNoteCreateWithoutAuthorInput[] | TicketNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutAuthorInput | TicketNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketNoteCreateManyAuthorInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TicketCreateWithoutCreatedByInput, TicketUncheckedCreateWithoutCreatedByInput> | TicketCreateWithoutCreatedByInput[] | TicketUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCreatedByInput | TicketCreateOrConnectWithoutCreatedByInput[]
    createMany?: TicketCreateManyCreatedByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<TicketCreateWithoutUpdatedByInput, TicketUncheckedCreateWithoutUpdatedByInput> | TicketCreateWithoutUpdatedByInput[] | TicketUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUpdatedByInput | TicketCreateOrConnectWithoutUpdatedByInput[]
    createMany?: TicketCreateManyUpdatedByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<TicketAttachmentCreateWithoutUploadedByInput, TicketAttachmentUncheckedCreateWithoutUploadedByInput> | TicketAttachmentCreateWithoutUploadedByInput[] | TicketAttachmentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUploadedByInput | TicketAttachmentCreateOrConnectWithoutUploadedByInput[]
    createMany?: TicketAttachmentCreateManyUploadedByInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumTechnicianStatusFieldUpdateOperationsInput = {
    set?: $Enums.TechnicianStatus
  }

  export type UserUpdateOneWithoutUsersCreatedNestedInput = {
    create?: XOR<UserCreateWithoutUsersCreatedInput, UserUncheckedCreateWithoutUsersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersCreatedInput
    upsert?: UserUpsertWithoutUsersCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsersCreatedInput, UserUpdateWithoutUsersCreatedInput>, UserUncheckedUpdateWithoutUsersCreatedInput>
  }

  export type UserUpdateOneWithoutUsersUpdatedNestedInput = {
    create?: XOR<UserCreateWithoutUsersUpdatedInput, UserUncheckedCreateWithoutUsersUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersUpdatedInput
    upsert?: UserUpsertWithoutUsersUpdatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsersUpdatedInput, UserUpdateWithoutUsersUpdatedInput>, UserUncheckedUpdateWithoutUsersUpdatedInput>
  }

  export type UserUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUpdatedByInput | UserUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUpdatedByInput | UserUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUpdatedByInput | UserUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput> | SessionLogCreateWithoutUserInput[] | SessionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutUserInput | SessionLogCreateOrConnectWithoutUserInput[]
    upsert?: SessionLogUpsertWithWhereUniqueWithoutUserInput | SessionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionLogCreateManyUserInputEnvelope
    set?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    disconnect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    delete?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    update?: SessionLogUpdateWithWhereUniqueWithoutUserInput | SessionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionLogUpdateManyWithWhereWithoutUserInput | SessionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
  }

  export type UserPresenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPresenceCreateOrConnectWithoutUserInput
    upsert?: UserPresenceUpsertWithoutUserInput
    disconnect?: UserPresenceWhereInput | boolean
    delete?: UserPresenceWhereInput | boolean
    connect?: UserPresenceWhereUniqueInput
    update?: XOR<XOR<UserPresenceUpdateToOneWithWhereWithoutUserInput, UserPresenceUpdateWithoutUserInput>, UserPresenceUncheckedUpdateWithoutUserInput>
  }

  export type CashRegisterUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<CashRegisterCreateWithoutClosedByInput, CashRegisterUncheckedCreateWithoutClosedByInput> | CashRegisterCreateWithoutClosedByInput[] | CashRegisterUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutClosedByInput | CashRegisterCreateOrConnectWithoutClosedByInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutClosedByInput | CashRegisterUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: CashRegisterCreateManyClosedByInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutClosedByInput | CashRegisterUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutClosedByInput | CashRegisterUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type CashRegisterUpdateManyWithoutOpenedByNestedInput = {
    create?: XOR<CashRegisterCreateWithoutOpenedByInput, CashRegisterUncheckedCreateWithoutOpenedByInput> | CashRegisterCreateWithoutOpenedByInput[] | CashRegisterUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutOpenedByInput | CashRegisterCreateOrConnectWithoutOpenedByInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutOpenedByInput | CashRegisterUpsertWithWhereUniqueWithoutOpenedByInput[]
    createMany?: CashRegisterCreateManyOpenedByInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutOpenedByInput | CashRegisterUpdateWithWhereUniqueWithoutOpenedByInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutOpenedByInput | CashRegisterUpdateManyWithWhereWithoutOpenedByInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type CashTransactionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCreatedByInput, CashTransactionUncheckedCreateWithoutCreatedByInput> | CashTransactionCreateWithoutCreatedByInput[] | CashTransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCreatedByInput | CashTransactionCreateOrConnectWithoutCreatedByInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCreatedByInput | CashTransactionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CashTransactionCreateManyCreatedByInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCreatedByInput | CashTransactionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCreatedByInput | CashTransactionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CreditNoteUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CreditNoteCreateWithoutCreatedByInput, CreditNoteUncheckedCreateWithoutCreatedByInput> | CreditNoteCreateWithoutCreatedByInput[] | CreditNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutCreatedByInput | CreditNoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutCreatedByInput | CreditNoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CreditNoteCreateManyCreatedByInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutCreatedByInput | CreditNoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutCreatedByInput | CreditNoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type CreditNoteUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<CreditNoteCreateWithoutProcessedByInput, CreditNoteUncheckedCreateWithoutProcessedByInput> | CreditNoteCreateWithoutProcessedByInput[] | CreditNoteUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutProcessedByInput | CreditNoteCreateOrConnectWithoutProcessedByInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutProcessedByInput | CreditNoteUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: CreditNoteCreateManyProcessedByInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutProcessedByInput | CreditNoteUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutProcessedByInput | CreditNoteUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput> | CustomerCreateWithoutCreatedByInput[] | CustomerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatedByInput | CustomerCreateOrConnectWithoutCreatedByInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCreatedByInput | CustomerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CustomerCreateManyCreatedByInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCreatedByInput | CustomerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCreatedByInput | CustomerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<CustomerCreateWithoutUpdatedByInput, CustomerUncheckedCreateWithoutUpdatedByInput> | CustomerCreateWithoutUpdatedByInput[] | CustomerUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUpdatedByInput | CustomerCreateOrConnectWithoutUpdatedByInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutUpdatedByInput | CustomerUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: CustomerCreateManyUpdatedByInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutUpdatedByInput | CustomerUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutUpdatedByInput | CustomerUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatedByInput | InvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutUpdatedByInput, InvoiceUncheckedCreateWithoutUpdatedByInput> | InvoiceCreateWithoutUpdatedByInput[] | InvoiceUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUpdatedByInput | InvoiceCreateOrConnectWithoutUpdatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUpdatedByInput | InvoiceUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: InvoiceCreateManyUpdatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUpdatedByInput | InvoiceUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUpdatedByInput | InvoiceUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceHistoryCreateWithoutUserInput, InvoiceHistoryUncheckedCreateWithoutUserInput> | InvoiceHistoryCreateWithoutUserInput[] | InvoiceHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceHistoryCreateOrConnectWithoutUserInput | InvoiceHistoryCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceHistoryUpsertWithWhereUniqueWithoutUserInput | InvoiceHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceHistoryCreateManyUserInputEnvelope
    set?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    disconnect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    delete?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    connect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    update?: InvoiceHistoryUpdateWithWhereUniqueWithoutUserInput | InvoiceHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceHistoryUpdateManyWithWhereWithoutUserInput | InvoiceHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceHistoryScalarWhereInput | InvoiceHistoryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PartUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PartCreateWithoutCreatedByInput, PartUncheckedCreateWithoutCreatedByInput> | PartCreateWithoutCreatedByInput[] | PartUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PartCreateOrConnectWithoutCreatedByInput | PartCreateOrConnectWithoutCreatedByInput[]
    upsert?: PartUpsertWithWhereUniqueWithoutCreatedByInput | PartUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PartCreateManyCreatedByInputEnvelope
    set?: PartWhereUniqueInput | PartWhereUniqueInput[]
    disconnect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    delete?: PartWhereUniqueInput | PartWhereUniqueInput[]
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    update?: PartUpdateWithWhereUniqueWithoutCreatedByInput | PartUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PartUpdateManyWithWhereWithoutCreatedByInput | PartUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PartScalarWhereInput | PartScalarWhereInput[]
  }

  export type PartUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PartCreateWithoutUpdatedByInput, PartUncheckedCreateWithoutUpdatedByInput> | PartCreateWithoutUpdatedByInput[] | PartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PartCreateOrConnectWithoutUpdatedByInput | PartCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PartUpsertWithWhereUniqueWithoutUpdatedByInput | PartUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PartCreateManyUpdatedByInputEnvelope
    set?: PartWhereUniqueInput | PartWhereUniqueInput[]
    disconnect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    delete?: PartWhereUniqueInput | PartWhereUniqueInput[]
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    update?: PartUpdateWithWhereUniqueWithoutUpdatedByInput | PartUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PartUpdateManyWithWhereWithoutUpdatedByInput | PartUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PartScalarWhereInput | PartScalarWhereInput[]
  }

  export type POSSaleUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<POSSaleCreateWithoutCreatedByInput, POSSaleUncheckedCreateWithoutCreatedByInput> | POSSaleCreateWithoutCreatedByInput[] | POSSaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCreatedByInput | POSSaleCreateOrConnectWithoutCreatedByInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutCreatedByInput | POSSaleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: POSSaleCreateManyCreatedByInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutCreatedByInput | POSSaleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutCreatedByInput | POSSaleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type POSQuotationUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<POSQuotationCreateWithoutCreatedByInput, POSQuotationUncheckedCreateWithoutCreatedByInput> | POSQuotationCreateWithoutCreatedByInput[] | POSQuotationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutCreatedByInput | POSQuotationCreateOrConnectWithoutCreatedByInput[]
    upsert?: POSQuotationUpsertWithWhereUniqueWithoutCreatedByInput | POSQuotationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: POSQuotationCreateManyCreatedByInputEnvelope
    set?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    disconnect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    delete?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    update?: POSQuotationUpdateWithWhereUniqueWithoutCreatedByInput | POSQuotationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: POSQuotationUpdateManyWithWhereWithoutCreatedByInput | POSQuotationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: POSQuotationScalarWhereInput | POSQuotationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceivedByInput | PaymentUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceivedByInput | PaymentUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceivedByInput | PaymentUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ServiceTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutCreatedByInput, ServiceTemplateUncheckedCreateWithoutCreatedByInput> | ServiceTemplateCreateWithoutCreatedByInput[] | ServiceTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutCreatedByInput | ServiceTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: ServiceTemplateUpsertWithWhereUniqueWithoutCreatedByInput | ServiceTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ServiceTemplateCreateManyCreatedByInputEnvelope
    set?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    disconnect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    delete?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    update?: ServiceTemplateUpdateWithWhereUniqueWithoutCreatedByInput | ServiceTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ServiceTemplateUpdateManyWithWhereWithoutCreatedByInput | ServiceTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ServiceTemplateScalarWhereInput | ServiceTemplateScalarWhereInput[]
  }

  export type ServiceTemplateUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutUpdatedByInput, ServiceTemplateUncheckedCreateWithoutUpdatedByInput> | ServiceTemplateCreateWithoutUpdatedByInput[] | ServiceTemplateUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutUpdatedByInput | ServiceTemplateCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ServiceTemplateUpsertWithWhereUniqueWithoutUpdatedByInput | ServiceTemplateUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ServiceTemplateCreateManyUpdatedByInputEnvelope
    set?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    disconnect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    delete?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    update?: ServiceTemplateUpdateWithWhereUniqueWithoutUpdatedByInput | ServiceTemplateUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ServiceTemplateUpdateManyWithWhereWithoutUpdatedByInput | ServiceTemplateUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ServiceTemplateScalarWhereInput | ServiceTemplateScalarWhereInput[]
  }

  export type TechnicianSpecializationUpdateManyWithoutUserNestedInput = {
    create?: XOR<TechnicianSpecializationCreateWithoutUserInput, TechnicianSpecializationUncheckedCreateWithoutUserInput> | TechnicianSpecializationCreateWithoutUserInput[] | TechnicianSpecializationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TechnicianSpecializationCreateOrConnectWithoutUserInput | TechnicianSpecializationCreateOrConnectWithoutUserInput[]
    upsert?: TechnicianSpecializationUpsertWithWhereUniqueWithoutUserInput | TechnicianSpecializationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TechnicianSpecializationCreateManyUserInputEnvelope
    set?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
    disconnect?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
    delete?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
    connect?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
    update?: TechnicianSpecializationUpdateWithWhereUniqueWithoutUserInput | TechnicianSpecializationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TechnicianSpecializationUpdateManyWithWhereWithoutUserInput | TechnicianSpecializationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TechnicianSpecializationScalarWhereInput | TechnicianSpecializationScalarWhereInput[]
  }

  export type TechnicianUnavailabilityUpdateManyWithoutUserNestedInput = {
    create?: XOR<TechnicianUnavailabilityCreateWithoutUserInput, TechnicianUnavailabilityUncheckedCreateWithoutUserInput> | TechnicianUnavailabilityCreateWithoutUserInput[] | TechnicianUnavailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TechnicianUnavailabilityCreateOrConnectWithoutUserInput | TechnicianUnavailabilityCreateOrConnectWithoutUserInput[]
    upsert?: TechnicianUnavailabilityUpsertWithWhereUniqueWithoutUserInput | TechnicianUnavailabilityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TechnicianUnavailabilityCreateManyUserInputEnvelope
    set?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
    disconnect?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
    delete?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
    connect?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
    update?: TechnicianUnavailabilityUpdateWithWhereUniqueWithoutUserInput | TechnicianUnavailabilityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TechnicianUnavailabilityUpdateManyWithWhereWithoutUserInput | TechnicianUnavailabilityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TechnicianUnavailabilityScalarWhereInput | TechnicianUnavailabilityScalarWhereInput[]
  }

  export type TicketNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketNoteCreateWithoutAuthorInput, TicketNoteUncheckedCreateWithoutAuthorInput> | TicketNoteCreateWithoutAuthorInput[] | TicketNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutAuthorInput | TicketNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutAuthorInput | TicketNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketNoteCreateManyAuthorInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutAuthorInput | TicketNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutAuthorInput | TicketNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedToInput | TicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedToInput | TicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedToInput | TicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TicketCreateWithoutCreatedByInput, TicketUncheckedCreateWithoutCreatedByInput> | TicketCreateWithoutCreatedByInput[] | TicketUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCreatedByInput | TicketCreateOrConnectWithoutCreatedByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCreatedByInput | TicketUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TicketCreateManyCreatedByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCreatedByInput | TicketUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCreatedByInput | TicketUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<TicketCreateWithoutUpdatedByInput, TicketUncheckedCreateWithoutUpdatedByInput> | TicketCreateWithoutUpdatedByInput[] | TicketUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUpdatedByInput | TicketCreateOrConnectWithoutUpdatedByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUpdatedByInput | TicketUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: TicketCreateManyUpdatedByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUpdatedByInput | TicketUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUpdatedByInput | TicketUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketAttachmentUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutUploadedByInput, TicketAttachmentUncheckedCreateWithoutUploadedByInput> | TicketAttachmentCreateWithoutUploadedByInput[] | TicketAttachmentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUploadedByInput | TicketAttachmentCreateOrConnectWithoutUploadedByInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutUploadedByInput | TicketAttachmentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TicketAttachmentCreateManyUploadedByInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutUploadedByInput | TicketAttachmentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutUploadedByInput | TicketAttachmentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type UserUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput> | UserCreateWithoutCreatedByInput[] | UserUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCreatedByInput | UserCreateOrConnectWithoutCreatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCreatedByInput | UserUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: UserCreateManyCreatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCreatedByInput | UserUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCreatedByInput | UserUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput> | UserCreateWithoutUpdatedByInput[] | UserUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedByInput | UserCreateOrConnectWithoutUpdatedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUpdatedByInput | UserUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: UserCreateManyUpdatedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUpdatedByInput | UserUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUpdatedByInput | UserUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SessionLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput> | SessionLogCreateWithoutUserInput[] | SessionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionLogCreateOrConnectWithoutUserInput | SessionLogCreateOrConnectWithoutUserInput[]
    upsert?: SessionLogUpsertWithWhereUniqueWithoutUserInput | SessionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionLogCreateManyUserInputEnvelope
    set?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    disconnect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    delete?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    connect?: SessionLogWhereUniqueInput | SessionLogWhereUniqueInput[]
    update?: SessionLogUpdateWithWhereUniqueWithoutUserInput | SessionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionLogUpdateManyWithWhereWithoutUserInput | SessionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
  }

  export type UserPresenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPresenceCreateOrConnectWithoutUserInput
    upsert?: UserPresenceUpsertWithoutUserInput
    disconnect?: UserPresenceWhereInput | boolean
    delete?: UserPresenceWhereInput | boolean
    connect?: UserPresenceWhereUniqueInput
    update?: XOR<XOR<UserPresenceUpdateToOneWithWhereWithoutUserInput, UserPresenceUpdateWithoutUserInput>, UserPresenceUncheckedUpdateWithoutUserInput>
  }

  export type CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput = {
    create?: XOR<CashRegisterCreateWithoutClosedByInput, CashRegisterUncheckedCreateWithoutClosedByInput> | CashRegisterCreateWithoutClosedByInput[] | CashRegisterUncheckedCreateWithoutClosedByInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutClosedByInput | CashRegisterCreateOrConnectWithoutClosedByInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutClosedByInput | CashRegisterUpsertWithWhereUniqueWithoutClosedByInput[]
    createMany?: CashRegisterCreateManyClosedByInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutClosedByInput | CashRegisterUpdateWithWhereUniqueWithoutClosedByInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutClosedByInput | CashRegisterUpdateManyWithWhereWithoutClosedByInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput = {
    create?: XOR<CashRegisterCreateWithoutOpenedByInput, CashRegisterUncheckedCreateWithoutOpenedByInput> | CashRegisterCreateWithoutOpenedByInput[] | CashRegisterUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: CashRegisterCreateOrConnectWithoutOpenedByInput | CashRegisterCreateOrConnectWithoutOpenedByInput[]
    upsert?: CashRegisterUpsertWithWhereUniqueWithoutOpenedByInput | CashRegisterUpsertWithWhereUniqueWithoutOpenedByInput[]
    createMany?: CashRegisterCreateManyOpenedByInputEnvelope
    set?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    disconnect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    delete?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    connect?: CashRegisterWhereUniqueInput | CashRegisterWhereUniqueInput[]
    update?: CashRegisterUpdateWithWhereUniqueWithoutOpenedByInput | CashRegisterUpdateWithWhereUniqueWithoutOpenedByInput[]
    updateMany?: CashRegisterUpdateManyWithWhereWithoutOpenedByInput | CashRegisterUpdateManyWithWhereWithoutOpenedByInput[]
    deleteMany?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCreatedByInput, CashTransactionUncheckedCreateWithoutCreatedByInput> | CashTransactionCreateWithoutCreatedByInput[] | CashTransactionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCreatedByInput | CashTransactionCreateOrConnectWithoutCreatedByInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCreatedByInput | CashTransactionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CashTransactionCreateManyCreatedByInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCreatedByInput | CashTransactionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCreatedByInput | CashTransactionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CreditNoteCreateWithoutCreatedByInput, CreditNoteUncheckedCreateWithoutCreatedByInput> | CreditNoteCreateWithoutCreatedByInput[] | CreditNoteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutCreatedByInput | CreditNoteCreateOrConnectWithoutCreatedByInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutCreatedByInput | CreditNoteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CreditNoteCreateManyCreatedByInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutCreatedByInput | CreditNoteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutCreatedByInput | CreditNoteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput = {
    create?: XOR<CreditNoteCreateWithoutProcessedByInput, CreditNoteUncheckedCreateWithoutProcessedByInput> | CreditNoteCreateWithoutProcessedByInput[] | CreditNoteUncheckedCreateWithoutProcessedByInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutProcessedByInput | CreditNoteCreateOrConnectWithoutProcessedByInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutProcessedByInput | CreditNoteUpsertWithWhereUniqueWithoutProcessedByInput[]
    createMany?: CreditNoteCreateManyProcessedByInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutProcessedByInput | CreditNoteUpdateWithWhereUniqueWithoutProcessedByInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutProcessedByInput | CreditNoteUpdateManyWithWhereWithoutProcessedByInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput> | CustomerCreateWithoutCreatedByInput[] | CustomerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatedByInput | CustomerCreateOrConnectWithoutCreatedByInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCreatedByInput | CustomerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CustomerCreateManyCreatedByInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCreatedByInput | CustomerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCreatedByInput | CustomerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<CustomerCreateWithoutUpdatedByInput, CustomerUncheckedCreateWithoutUpdatedByInput> | CustomerCreateWithoutUpdatedByInput[] | CustomerUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUpdatedByInput | CustomerCreateOrConnectWithoutUpdatedByInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutUpdatedByInput | CustomerUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: CustomerCreateManyUpdatedByInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutUpdatedByInput | CustomerUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutUpdatedByInput | CustomerUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatedByInput | InvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutUpdatedByInput, InvoiceUncheckedCreateWithoutUpdatedByInput> | InvoiceCreateWithoutUpdatedByInput[] | InvoiceUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUpdatedByInput | InvoiceCreateOrConnectWithoutUpdatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUpdatedByInput | InvoiceUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: InvoiceCreateManyUpdatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUpdatedByInput | InvoiceUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUpdatedByInput | InvoiceUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceHistoryCreateWithoutUserInput, InvoiceHistoryUncheckedCreateWithoutUserInput> | InvoiceHistoryCreateWithoutUserInput[] | InvoiceHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceHistoryCreateOrConnectWithoutUserInput | InvoiceHistoryCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceHistoryUpsertWithWhereUniqueWithoutUserInput | InvoiceHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceHistoryCreateManyUserInputEnvelope
    set?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    disconnect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    delete?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    connect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    update?: InvoiceHistoryUpdateWithWhereUniqueWithoutUserInput | InvoiceHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceHistoryUpdateManyWithWhereWithoutUserInput | InvoiceHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceHistoryScalarWhereInput | InvoiceHistoryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PartUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PartCreateWithoutCreatedByInput, PartUncheckedCreateWithoutCreatedByInput> | PartCreateWithoutCreatedByInput[] | PartUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PartCreateOrConnectWithoutCreatedByInput | PartCreateOrConnectWithoutCreatedByInput[]
    upsert?: PartUpsertWithWhereUniqueWithoutCreatedByInput | PartUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PartCreateManyCreatedByInputEnvelope
    set?: PartWhereUniqueInput | PartWhereUniqueInput[]
    disconnect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    delete?: PartWhereUniqueInput | PartWhereUniqueInput[]
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    update?: PartUpdateWithWhereUniqueWithoutCreatedByInput | PartUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PartUpdateManyWithWhereWithoutCreatedByInput | PartUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PartScalarWhereInput | PartScalarWhereInput[]
  }

  export type PartUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PartCreateWithoutUpdatedByInput, PartUncheckedCreateWithoutUpdatedByInput> | PartCreateWithoutUpdatedByInput[] | PartUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PartCreateOrConnectWithoutUpdatedByInput | PartCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PartUpsertWithWhereUniqueWithoutUpdatedByInput | PartUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PartCreateManyUpdatedByInputEnvelope
    set?: PartWhereUniqueInput | PartWhereUniqueInput[]
    disconnect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    delete?: PartWhereUniqueInput | PartWhereUniqueInput[]
    connect?: PartWhereUniqueInput | PartWhereUniqueInput[]
    update?: PartUpdateWithWhereUniqueWithoutUpdatedByInput | PartUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PartUpdateManyWithWhereWithoutUpdatedByInput | PartUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PartScalarWhereInput | PartScalarWhereInput[]
  }

  export type POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<POSSaleCreateWithoutCreatedByInput, POSSaleUncheckedCreateWithoutCreatedByInput> | POSSaleCreateWithoutCreatedByInput[] | POSSaleUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCreatedByInput | POSSaleCreateOrConnectWithoutCreatedByInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutCreatedByInput | POSSaleUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: POSSaleCreateManyCreatedByInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutCreatedByInput | POSSaleUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutCreatedByInput | POSSaleUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<POSQuotationCreateWithoutCreatedByInput, POSQuotationUncheckedCreateWithoutCreatedByInput> | POSQuotationCreateWithoutCreatedByInput[] | POSQuotationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutCreatedByInput | POSQuotationCreateOrConnectWithoutCreatedByInput[]
    upsert?: POSQuotationUpsertWithWhereUniqueWithoutCreatedByInput | POSQuotationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: POSQuotationCreateManyCreatedByInputEnvelope
    set?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    disconnect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    delete?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    update?: POSQuotationUpdateWithWhereUniqueWithoutCreatedByInput | POSQuotationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: POSQuotationUpdateManyWithWhereWithoutCreatedByInput | POSQuotationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: POSQuotationScalarWhereInput | POSQuotationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceivedByInput | PaymentUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceivedByInput | PaymentUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceivedByInput | PaymentUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutCreatedByInput, ServiceTemplateUncheckedCreateWithoutCreatedByInput> | ServiceTemplateCreateWithoutCreatedByInput[] | ServiceTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutCreatedByInput | ServiceTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: ServiceTemplateUpsertWithWhereUniqueWithoutCreatedByInput | ServiceTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ServiceTemplateCreateManyCreatedByInputEnvelope
    set?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    disconnect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    delete?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    update?: ServiceTemplateUpdateWithWhereUniqueWithoutCreatedByInput | ServiceTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ServiceTemplateUpdateManyWithWhereWithoutCreatedByInput | ServiceTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ServiceTemplateScalarWhereInput | ServiceTemplateScalarWhereInput[]
  }

  export type ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutUpdatedByInput, ServiceTemplateUncheckedCreateWithoutUpdatedByInput> | ServiceTemplateCreateWithoutUpdatedByInput[] | ServiceTemplateUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutUpdatedByInput | ServiceTemplateCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ServiceTemplateUpsertWithWhereUniqueWithoutUpdatedByInput | ServiceTemplateUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ServiceTemplateCreateManyUpdatedByInputEnvelope
    set?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    disconnect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    delete?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    connect?: ServiceTemplateWhereUniqueInput | ServiceTemplateWhereUniqueInput[]
    update?: ServiceTemplateUpdateWithWhereUniqueWithoutUpdatedByInput | ServiceTemplateUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ServiceTemplateUpdateManyWithWhereWithoutUpdatedByInput | ServiceTemplateUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ServiceTemplateScalarWhereInput | ServiceTemplateScalarWhereInput[]
  }

  export type TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TechnicianSpecializationCreateWithoutUserInput, TechnicianSpecializationUncheckedCreateWithoutUserInput> | TechnicianSpecializationCreateWithoutUserInput[] | TechnicianSpecializationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TechnicianSpecializationCreateOrConnectWithoutUserInput | TechnicianSpecializationCreateOrConnectWithoutUserInput[]
    upsert?: TechnicianSpecializationUpsertWithWhereUniqueWithoutUserInput | TechnicianSpecializationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TechnicianSpecializationCreateManyUserInputEnvelope
    set?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
    disconnect?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
    delete?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
    connect?: TechnicianSpecializationWhereUniqueInput | TechnicianSpecializationWhereUniqueInput[]
    update?: TechnicianSpecializationUpdateWithWhereUniqueWithoutUserInput | TechnicianSpecializationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TechnicianSpecializationUpdateManyWithWhereWithoutUserInput | TechnicianSpecializationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TechnicianSpecializationScalarWhereInput | TechnicianSpecializationScalarWhereInput[]
  }

  export type TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TechnicianUnavailabilityCreateWithoutUserInput, TechnicianUnavailabilityUncheckedCreateWithoutUserInput> | TechnicianUnavailabilityCreateWithoutUserInput[] | TechnicianUnavailabilityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TechnicianUnavailabilityCreateOrConnectWithoutUserInput | TechnicianUnavailabilityCreateOrConnectWithoutUserInput[]
    upsert?: TechnicianUnavailabilityUpsertWithWhereUniqueWithoutUserInput | TechnicianUnavailabilityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TechnicianUnavailabilityCreateManyUserInputEnvelope
    set?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
    disconnect?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
    delete?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
    connect?: TechnicianUnavailabilityWhereUniqueInput | TechnicianUnavailabilityWhereUniqueInput[]
    update?: TechnicianUnavailabilityUpdateWithWhereUniqueWithoutUserInput | TechnicianUnavailabilityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TechnicianUnavailabilityUpdateManyWithWhereWithoutUserInput | TechnicianUnavailabilityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TechnicianUnavailabilityScalarWhereInput | TechnicianUnavailabilityScalarWhereInput[]
  }

  export type TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketNoteCreateWithoutAuthorInput, TicketNoteUncheckedCreateWithoutAuthorInput> | TicketNoteCreateWithoutAuthorInput[] | TicketNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutAuthorInput | TicketNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutAuthorInput | TicketNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketNoteCreateManyAuthorInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutAuthorInput | TicketNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutAuthorInput | TicketNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput> | TicketCreateWithoutAssignedToInput[] | TicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedToInput | TicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedToInput | TicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: TicketCreateManyAssignedToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedToInput | TicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedToInput | TicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TicketCreateWithoutCreatedByInput, TicketUncheckedCreateWithoutCreatedByInput> | TicketCreateWithoutCreatedByInput[] | TicketUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCreatedByInput | TicketCreateOrConnectWithoutCreatedByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCreatedByInput | TicketUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TicketCreateManyCreatedByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCreatedByInput | TicketUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCreatedByInput | TicketUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<TicketCreateWithoutUpdatedByInput, TicketUncheckedCreateWithoutUpdatedByInput> | TicketCreateWithoutUpdatedByInput[] | TicketUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUpdatedByInput | TicketCreateOrConnectWithoutUpdatedByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUpdatedByInput | TicketUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: TicketCreateManyUpdatedByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUpdatedByInput | TicketUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUpdatedByInput | TicketUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutUploadedByInput, TicketAttachmentUncheckedCreateWithoutUploadedByInput> | TicketAttachmentCreateWithoutUploadedByInput[] | TicketAttachmentUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutUploadedByInput | TicketAttachmentCreateOrConnectWithoutUploadedByInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutUploadedByInput | TicketAttachmentUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: TicketAttachmentCreateManyUploadedByInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutUploadedByInput | TicketAttachmentUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutUploadedByInput | TicketAttachmentUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedCustomersInput = {
    create?: XOR<UserCreateWithoutCreatedCustomersInput, UserUncheckedCreateWithoutCreatedCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type CreditNoteCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CreditNoteCreateWithoutCustomerInput, CreditNoteUncheckedCreateWithoutCustomerInput> | CreditNoteCreateWithoutCustomerInput[] | CreditNoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutCustomerInput | CreditNoteCreateOrConnectWithoutCustomerInput[]
    createMany?: CreditNoteCreateManyCustomerInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type POSSaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<POSSaleCreateWithoutCustomerInput, POSSaleUncheckedCreateWithoutCustomerInput> | POSSaleCreateWithoutCustomerInput[] | POSSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCustomerInput | POSSaleCreateOrConnectWithoutCustomerInput[]
    createMany?: POSSaleCreateManyCustomerInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type POSQuotationCreateNestedManyWithoutCustomerInput = {
    create?: XOR<POSQuotationCreateWithoutCustomerInput, POSQuotationUncheckedCreateWithoutCustomerInput> | POSQuotationCreateWithoutCustomerInput[] | POSQuotationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutCustomerInput | POSQuotationCreateOrConnectWithoutCustomerInput[]
    createMany?: POSQuotationCreateManyCustomerInputEnvelope
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutCustomersInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    connect?: TenantWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput> | TicketCreateWithoutCustomerInput[] | TicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCustomerInput | TicketCreateOrConnectWithoutCustomerInput[]
    createMany?: TicketCreateManyCustomerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutUpdatedCustomersInput = {
    create?: XOR<UserCreateWithoutUpdatedCustomersInput, UserUncheckedCreateWithoutUpdatedCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type CreditNoteUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CreditNoteCreateWithoutCustomerInput, CreditNoteUncheckedCreateWithoutCustomerInput> | CreditNoteCreateWithoutCustomerInput[] | CreditNoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutCustomerInput | CreditNoteCreateOrConnectWithoutCustomerInput[]
    createMany?: CreditNoteCreateManyCustomerInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type POSSaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<POSSaleCreateWithoutCustomerInput, POSSaleUncheckedCreateWithoutCustomerInput> | POSSaleCreateWithoutCustomerInput[] | POSSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCustomerInput | POSSaleCreateOrConnectWithoutCustomerInput[]
    createMany?: POSSaleCreateManyCustomerInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type POSQuotationUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<POSQuotationCreateWithoutCustomerInput, POSQuotationUncheckedCreateWithoutCustomerInput> | POSQuotationCreateWithoutCustomerInput[] | POSQuotationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutCustomerInput | POSQuotationCreateOrConnectWithoutCustomerInput[]
    createMany?: POSQuotationCreateManyCustomerInputEnvelope
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput> | TicketCreateWithoutCustomerInput[] | TicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCustomerInput | TicketCreateOrConnectWithoutCustomerInput[]
    createMany?: TicketCreateManyCustomerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedCustomersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCustomersInput, UserUncheckedCreateWithoutCreatedCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCustomersInput
    upsert?: UserUpsertWithoutCreatedCustomersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCustomersInput, UserUpdateWithoutCreatedCustomersInput>, UserUncheckedUpdateWithoutCreatedCustomersInput>
  }

  export type CreditNoteUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CreditNoteCreateWithoutCustomerInput, CreditNoteUncheckedCreateWithoutCustomerInput> | CreditNoteCreateWithoutCustomerInput[] | CreditNoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutCustomerInput | CreditNoteCreateOrConnectWithoutCustomerInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutCustomerInput | CreditNoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CreditNoteCreateManyCustomerInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutCustomerInput | CreditNoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutCustomerInput | CreditNoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type POSSaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<POSSaleCreateWithoutCustomerInput, POSSaleUncheckedCreateWithoutCustomerInput> | POSSaleCreateWithoutCustomerInput[] | POSSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCustomerInput | POSSaleCreateOrConnectWithoutCustomerInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutCustomerInput | POSSaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: POSSaleCreateManyCustomerInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutCustomerInput | POSSaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutCustomerInput | POSSaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type POSQuotationUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<POSQuotationCreateWithoutCustomerInput, POSQuotationUncheckedCreateWithoutCustomerInput> | POSQuotationCreateWithoutCustomerInput[] | POSQuotationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutCustomerInput | POSQuotationCreateOrConnectWithoutCustomerInput[]
    upsert?: POSQuotationUpsertWithWhereUniqueWithoutCustomerInput | POSQuotationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: POSQuotationCreateManyCustomerInputEnvelope
    set?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    disconnect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    delete?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    update?: POSQuotationUpdateWithWhereUniqueWithoutCustomerInput | POSQuotationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: POSQuotationUpdateManyWithWhereWithoutCustomerInput | POSQuotationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: POSQuotationScalarWhereInput | POSQuotationScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    upsert?: TenantUpsertWithoutCustomersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCustomersInput, TenantUpdateWithoutCustomersInput>, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type TicketUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput> | TicketCreateWithoutCustomerInput[] | TicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCustomerInput | TicketCreateOrConnectWithoutCustomerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCustomerInput | TicketUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TicketCreateManyCustomerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCustomerInput | TicketUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCustomerInput | TicketUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserUpdateOneWithoutUpdatedCustomersNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedCustomersInput, UserUncheckedCreateWithoutUpdatedCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedCustomersInput
    upsert?: UserUpsertWithoutUpdatedCustomersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedCustomersInput, UserUpdateWithoutUpdatedCustomersInput>, UserUncheckedUpdateWithoutUpdatedCustomersInput>
  }

  export type CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CreditNoteCreateWithoutCustomerInput, CreditNoteUncheckedCreateWithoutCustomerInput> | CreditNoteCreateWithoutCustomerInput[] | CreditNoteUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutCustomerInput | CreditNoteCreateOrConnectWithoutCustomerInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutCustomerInput | CreditNoteUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CreditNoteCreateManyCustomerInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutCustomerInput | CreditNoteUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutCustomerInput | CreditNoteUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type POSSaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<POSSaleCreateWithoutCustomerInput, POSSaleUncheckedCreateWithoutCustomerInput> | POSSaleCreateWithoutCustomerInput[] | POSSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCustomerInput | POSSaleCreateOrConnectWithoutCustomerInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutCustomerInput | POSSaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: POSSaleCreateManyCustomerInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutCustomerInput | POSSaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutCustomerInput | POSSaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<POSQuotationCreateWithoutCustomerInput, POSQuotationUncheckedCreateWithoutCustomerInput> | POSQuotationCreateWithoutCustomerInput[] | POSQuotationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: POSQuotationCreateOrConnectWithoutCustomerInput | POSQuotationCreateOrConnectWithoutCustomerInput[]
    upsert?: POSQuotationUpsertWithWhereUniqueWithoutCustomerInput | POSQuotationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: POSQuotationCreateManyCustomerInputEnvelope
    set?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    disconnect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    delete?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    connect?: POSQuotationWhereUniqueInput | POSQuotationWhereUniqueInput[]
    update?: POSQuotationUpdateWithWhereUniqueWithoutCustomerInput | POSQuotationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: POSQuotationUpdateManyWithWhereWithoutCustomerInput | POSQuotationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: POSQuotationScalarWhereInput | POSQuotationScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput> | TicketCreateWithoutCustomerInput[] | TicketUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCustomerInput | TicketCreateOrConnectWithoutCustomerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCustomerInput | TicketUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TicketCreateManyCustomerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCustomerInput | TicketUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCustomerInput | TicketUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketAttachmentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutTicketInput = {
    create?: XOR<InvoiceCreateWithoutTicketInput, InvoiceUncheckedCreateWithoutTicketInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTicketInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PartUsageCreateNestedManyWithoutTicketInput = {
    create?: XOR<PartUsageCreateWithoutTicketInput, PartUsageUncheckedCreateWithoutTicketInput> | PartUsageCreateWithoutTicketInput[] | PartUsageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: PartUsageCreateOrConnectWithoutTicketInput | PartUsageCreateOrConnectWithoutTicketInput[]
    createMany?: PartUsageCreateManyTicketInputEnvelope
    connect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
  }

  export type TicketNoteCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput> | TicketNoteCreateWithoutTicketInput[] | TicketNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutTicketInput | TicketNoteCreateOrConnectWithoutTicketInput[]
    createMany?: TicketNoteCreateManyTicketInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type TicketServiceCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketServiceCreateWithoutTicketInput, TicketServiceUncheckedCreateWithoutTicketInput> | TicketServiceCreateWithoutTicketInput[] | TicketServiceUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketServiceCreateOrConnectWithoutTicketInput | TicketServiceCreateOrConnectWithoutTicketInput[]
    createMany?: TicketServiceCreateManyTicketInputEnvelope
    connect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTicketsInput = {
    create?: XOR<UserCreateWithoutCreatedTicketsInput, UserUncheckedCreateWithoutCreatedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutTicketsInput = {
    create?: XOR<CustomerCreateWithoutTicketsInput, CustomerUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTicketsInput
    connect?: CustomerWhereUniqueInput
  }

  export type ServiceTemplateCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ServiceTemplateCreateWithoutTicketsInput, ServiceTemplateUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutTicketsInput
    connect?: ServiceTemplateWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutTicketsInput = {
    create?: XOR<TenantCreateWithoutTicketsInput, TenantUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTicketsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedTicketsInput = {
    create?: XOR<UserCreateWithoutUpdatedTicketsInput, UserUncheckedCreateWithoutUpdatedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserPresenceCreateNestedManyWithoutCurrentTicketInput = {
    create?: XOR<UserPresenceCreateWithoutCurrentTicketInput, UserPresenceUncheckedCreateWithoutCurrentTicketInput> | UserPresenceCreateWithoutCurrentTicketInput[] | UserPresenceUncheckedCreateWithoutCurrentTicketInput[]
    connectOrCreate?: UserPresenceCreateOrConnectWithoutCurrentTicketInput | UserPresenceCreateOrConnectWithoutCurrentTicketInput[]
    createMany?: UserPresenceCreateManyCurrentTicketInputEnvelope
    connect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
  }

  export type TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutTicketInput = {
    create?: XOR<InvoiceCreateWithoutTicketInput, InvoiceUncheckedCreateWithoutTicketInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTicketInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PartUsageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<PartUsageCreateWithoutTicketInput, PartUsageUncheckedCreateWithoutTicketInput> | PartUsageCreateWithoutTicketInput[] | PartUsageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: PartUsageCreateOrConnectWithoutTicketInput | PartUsageCreateOrConnectWithoutTicketInput[]
    createMany?: PartUsageCreateManyTicketInputEnvelope
    connect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
  }

  export type TicketNoteUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput> | TicketNoteCreateWithoutTicketInput[] | TicketNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutTicketInput | TicketNoteCreateOrConnectWithoutTicketInput[]
    createMany?: TicketNoteCreateManyTicketInputEnvelope
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
  }

  export type TicketServiceUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketServiceCreateWithoutTicketInput, TicketServiceUncheckedCreateWithoutTicketInput> | TicketServiceCreateWithoutTicketInput[] | TicketServiceUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketServiceCreateOrConnectWithoutTicketInput | TicketServiceCreateOrConnectWithoutTicketInput[]
    createMany?: TicketServiceCreateManyTicketInputEnvelope
    connect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
  }

  export type UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput = {
    create?: XOR<UserPresenceCreateWithoutCurrentTicketInput, UserPresenceUncheckedCreateWithoutCurrentTicketInput> | UserPresenceCreateWithoutCurrentTicketInput[] | UserPresenceUncheckedCreateWithoutCurrentTicketInput[]
    connectOrCreate?: UserPresenceCreateOrConnectWithoutCurrentTicketInput | UserPresenceCreateOrConnectWithoutCurrentTicketInput[]
    createMany?: UserPresenceCreateManyCurrentTicketInputEnvelope
    connect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type TicketAttachmentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutTicketNestedInput = {
    create?: XOR<InvoiceCreateWithoutTicketInput, InvoiceUncheckedCreateWithoutTicketInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTicketInput
    upsert?: InvoiceUpsertWithoutTicketInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTicketInput, InvoiceUpdateWithoutTicketInput>, InvoiceUncheckedUpdateWithoutTicketInput>
  }

  export type PartUsageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<PartUsageCreateWithoutTicketInput, PartUsageUncheckedCreateWithoutTicketInput> | PartUsageCreateWithoutTicketInput[] | PartUsageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: PartUsageCreateOrConnectWithoutTicketInput | PartUsageCreateOrConnectWithoutTicketInput[]
    upsert?: PartUsageUpsertWithWhereUniqueWithoutTicketInput | PartUsageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: PartUsageCreateManyTicketInputEnvelope
    set?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    disconnect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    delete?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    connect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    update?: PartUsageUpdateWithWhereUniqueWithoutTicketInput | PartUsageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: PartUsageUpdateManyWithWhereWithoutTicketInput | PartUsageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: PartUsageScalarWhereInput | PartUsageScalarWhereInput[]
  }

  export type TicketNoteUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput> | TicketNoteCreateWithoutTicketInput[] | TicketNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutTicketInput | TicketNoteCreateOrConnectWithoutTicketInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutTicketInput | TicketNoteUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketNoteCreateManyTicketInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutTicketInput | TicketNoteUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutTicketInput | TicketNoteUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type TicketServiceUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketServiceCreateWithoutTicketInput, TicketServiceUncheckedCreateWithoutTicketInput> | TicketServiceCreateWithoutTicketInput[] | TicketServiceUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketServiceCreateOrConnectWithoutTicketInput | TicketServiceCreateOrConnectWithoutTicketInput[]
    upsert?: TicketServiceUpsertWithWhereUniqueWithoutTicketInput | TicketServiceUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketServiceCreateManyTicketInputEnvelope
    set?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    disconnect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    delete?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    connect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    update?: TicketServiceUpdateWithWhereUniqueWithoutTicketInput | TicketServiceUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketServiceUpdateManyWithWhereWithoutTicketInput | TicketServiceUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketServiceScalarWhereInput | TicketServiceScalarWhereInput[]
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateOneWithoutCreatedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTicketsInput, UserUncheckedCreateWithoutCreatedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTicketsInput
    upsert?: UserUpsertWithoutCreatedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTicketsInput, UserUpdateWithoutCreatedTicketsInput>, UserUncheckedUpdateWithoutCreatedTicketsInput>
  }

  export type CustomerUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<CustomerCreateWithoutTicketsInput, CustomerUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTicketsInput
    upsert?: CustomerUpsertWithoutTicketsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTicketsInput, CustomerUpdateWithoutTicketsInput>, CustomerUncheckedUpdateWithoutTicketsInput>
  }

  export type ServiceTemplateUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutTicketsInput, ServiceTemplateUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutTicketsInput
    upsert?: ServiceTemplateUpsertWithoutTicketsInput
    disconnect?: ServiceTemplateWhereInput | boolean
    delete?: ServiceTemplateWhereInput | boolean
    connect?: ServiceTemplateWhereUniqueInput
    update?: XOR<XOR<ServiceTemplateUpdateToOneWithWhereWithoutTicketsInput, ServiceTemplateUpdateWithoutTicketsInput>, ServiceTemplateUncheckedUpdateWithoutTicketsInput>
  }

  export type TenantUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<TenantCreateWithoutTicketsInput, TenantUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTicketsInput
    upsert?: TenantUpsertWithoutTicketsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTicketsInput, TenantUpdateWithoutTicketsInput>, TenantUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneWithoutUpdatedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedTicketsInput, UserUncheckedCreateWithoutUpdatedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedTicketsInput
    upsert?: UserUpsertWithoutUpdatedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedTicketsInput, UserUpdateWithoutUpdatedTicketsInput>, UserUncheckedUpdateWithoutUpdatedTicketsInput>
  }

  export type UserPresenceUpdateManyWithoutCurrentTicketNestedInput = {
    create?: XOR<UserPresenceCreateWithoutCurrentTicketInput, UserPresenceUncheckedCreateWithoutCurrentTicketInput> | UserPresenceCreateWithoutCurrentTicketInput[] | UserPresenceUncheckedCreateWithoutCurrentTicketInput[]
    connectOrCreate?: UserPresenceCreateOrConnectWithoutCurrentTicketInput | UserPresenceCreateOrConnectWithoutCurrentTicketInput[]
    upsert?: UserPresenceUpsertWithWhereUniqueWithoutCurrentTicketInput | UserPresenceUpsertWithWhereUniqueWithoutCurrentTicketInput[]
    createMany?: UserPresenceCreateManyCurrentTicketInputEnvelope
    set?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    disconnect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    delete?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    connect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    update?: UserPresenceUpdateWithWhereUniqueWithoutCurrentTicketInput | UserPresenceUpdateWithWhereUniqueWithoutCurrentTicketInput[]
    updateMany?: UserPresenceUpdateManyWithWhereWithoutCurrentTicketInput | UserPresenceUpdateManyWithWhereWithoutCurrentTicketInput[]
    deleteMany?: UserPresenceScalarWhereInput | UserPresenceScalarWhereInput[]
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput> | TicketAttachmentCreateWithoutTicketInput[] | TicketAttachmentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketAttachmentCreateOrConnectWithoutTicketInput | TicketAttachmentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput | TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketAttachmentCreateManyTicketInputEnvelope
    set?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    disconnect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    delete?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    connect?: TicketAttachmentWhereUniqueInput | TicketAttachmentWhereUniqueInput[]
    update?: TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput | TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketAttachmentUpdateManyWithWhereWithoutTicketInput | TicketAttachmentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutTicketNestedInput = {
    create?: XOR<InvoiceCreateWithoutTicketInput, InvoiceUncheckedCreateWithoutTicketInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTicketInput
    upsert?: InvoiceUpsertWithoutTicketInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTicketInput, InvoiceUpdateWithoutTicketInput>, InvoiceUncheckedUpdateWithoutTicketInput>
  }

  export type PartUsageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<PartUsageCreateWithoutTicketInput, PartUsageUncheckedCreateWithoutTicketInput> | PartUsageCreateWithoutTicketInput[] | PartUsageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: PartUsageCreateOrConnectWithoutTicketInput | PartUsageCreateOrConnectWithoutTicketInput[]
    upsert?: PartUsageUpsertWithWhereUniqueWithoutTicketInput | PartUsageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: PartUsageCreateManyTicketInputEnvelope
    set?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    disconnect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    delete?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    connect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    update?: PartUsageUpdateWithWhereUniqueWithoutTicketInput | PartUsageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: PartUsageUpdateManyWithWhereWithoutTicketInput | PartUsageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: PartUsageScalarWhereInput | PartUsageScalarWhereInput[]
  }

  export type TicketNoteUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput> | TicketNoteCreateWithoutTicketInput[] | TicketNoteUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketNoteCreateOrConnectWithoutTicketInput | TicketNoteCreateOrConnectWithoutTicketInput[]
    upsert?: TicketNoteUpsertWithWhereUniqueWithoutTicketInput | TicketNoteUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketNoteCreateManyTicketInputEnvelope
    set?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    disconnect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    delete?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    connect?: TicketNoteWhereUniqueInput | TicketNoteWhereUniqueInput[]
    update?: TicketNoteUpdateWithWhereUniqueWithoutTicketInput | TicketNoteUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketNoteUpdateManyWithWhereWithoutTicketInput | TicketNoteUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
  }

  export type TicketServiceUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketServiceCreateWithoutTicketInput, TicketServiceUncheckedCreateWithoutTicketInput> | TicketServiceCreateWithoutTicketInput[] | TicketServiceUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketServiceCreateOrConnectWithoutTicketInput | TicketServiceCreateOrConnectWithoutTicketInput[]
    upsert?: TicketServiceUpsertWithWhereUniqueWithoutTicketInput | TicketServiceUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketServiceCreateManyTicketInputEnvelope
    set?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    disconnect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    delete?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    connect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    update?: TicketServiceUpdateWithWhereUniqueWithoutTicketInput | TicketServiceUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketServiceUpdateManyWithWhereWithoutTicketInput | TicketServiceUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketServiceScalarWhereInput | TicketServiceScalarWhereInput[]
  }

  export type UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput = {
    create?: XOR<UserPresenceCreateWithoutCurrentTicketInput, UserPresenceUncheckedCreateWithoutCurrentTicketInput> | UserPresenceCreateWithoutCurrentTicketInput[] | UserPresenceUncheckedCreateWithoutCurrentTicketInput[]
    connectOrCreate?: UserPresenceCreateOrConnectWithoutCurrentTicketInput | UserPresenceCreateOrConnectWithoutCurrentTicketInput[]
    upsert?: UserPresenceUpsertWithWhereUniqueWithoutCurrentTicketInput | UserPresenceUpsertWithWhereUniqueWithoutCurrentTicketInput[]
    createMany?: UserPresenceCreateManyCurrentTicketInputEnvelope
    set?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    disconnect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    delete?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    connect?: UserPresenceWhereUniqueInput | UserPresenceWhereUniqueInput[]
    update?: UserPresenceUpdateWithWhereUniqueWithoutCurrentTicketInput | UserPresenceUpdateWithWhereUniqueWithoutCurrentTicketInput[]
    updateMany?: UserPresenceUpdateManyWithWhereWithoutCurrentTicketInput | UserPresenceUpdateManyWithWhereWithoutCurrentTicketInput[]
    deleteMany?: UserPresenceScalarWhereInput | UserPresenceScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedAttachmentsInput = {
    create?: XOR<UserCreateWithoutUploadedAttachmentsInput, UserUncheckedCreateWithoutUploadedAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedAttachmentsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutAttachmentsInput
    upsert?: TicketUpsertWithoutAttachmentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutAttachmentsInput, TicketUpdateWithoutAttachmentsInput>, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedAttachmentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedAttachmentsInput, UserUncheckedCreateWithoutUploadedAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedAttachmentsInput
    upsert?: UserUpsertWithoutUploadedAttachmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedAttachmentsInput, UserUpdateWithoutUploadedAttachmentsInput>, UserUncheckedUpdateWithoutUploadedAttachmentsInput>
  }

  export type CreditNoteItemCreateNestedManyWithoutPartInput = {
    create?: XOR<CreditNoteItemCreateWithoutPartInput, CreditNoteItemUncheckedCreateWithoutPartInput> | CreditNoteItemCreateWithoutPartInput[] | CreditNoteItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: CreditNoteItemCreateOrConnectWithoutPartInput | CreditNoteItemCreateOrConnectWithoutPartInput[]
    createMany?: CreditNoteItemCreateManyPartInputEnvelope
    connect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedPartsInput = {
    create?: XOR<UserCreateWithoutCreatedPartsInput, UserUncheckedCreateWithoutCreatedPartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPartsInput
    connect?: UserWhereUniqueInput
  }

  export type POSQuotationItemCreateNestedManyWithoutPartInput = {
    create?: XOR<POSQuotationItemCreateWithoutPartInput, POSQuotationItemUncheckedCreateWithoutPartInput> | POSQuotationItemCreateWithoutPartInput[] | POSQuotationItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: POSQuotationItemCreateOrConnectWithoutPartInput | POSQuotationItemCreateOrConnectWithoutPartInput[]
    createMany?: POSQuotationItemCreateManyPartInputEnvelope
    connect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
  }

  export type POSSaleItemCreateNestedManyWithoutPartInput = {
    create?: XOR<POSSaleItemCreateWithoutPartInput, POSSaleItemUncheckedCreateWithoutPartInput> | POSSaleItemCreateWithoutPartInput[] | POSSaleItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: POSSaleItemCreateOrConnectWithoutPartInput | POSSaleItemCreateOrConnectWithoutPartInput[]
    createMany?: POSSaleItemCreateManyPartInputEnvelope
    connect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutPartInput = {
    create?: XOR<PurchaseItemCreateWithoutPartInput, PurchaseItemUncheckedCreateWithoutPartInput> | PurchaseItemCreateWithoutPartInput[] | PurchaseItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPartInput | PurchaseItemCreateOrConnectWithoutPartInput[]
    createMany?: PurchaseItemCreateManyPartInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TemplateDefaultPartCreateNestedManyWithoutPartInput = {
    create?: XOR<TemplateDefaultPartCreateWithoutPartInput, TemplateDefaultPartUncheckedCreateWithoutPartInput> | TemplateDefaultPartCreateWithoutPartInput[] | TemplateDefaultPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: TemplateDefaultPartCreateOrConnectWithoutPartInput | TemplateDefaultPartCreateOrConnectWithoutPartInput[]
    createMany?: TemplateDefaultPartCreateManyPartInputEnvelope
    connect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutPartsInput = {
    create?: XOR<TenantCreateWithoutPartsInput, TenantUncheckedCreateWithoutPartsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPartsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedPartsInput = {
    create?: XOR<UserCreateWithoutUpdatedPartsInput, UserUncheckedCreateWithoutUpdatedPartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedPartsInput
    connect?: UserWhereUniqueInput
  }

  export type PartUsageCreateNestedManyWithoutPartInput = {
    create?: XOR<PartUsageCreateWithoutPartInput, PartUsageUncheckedCreateWithoutPartInput> | PartUsageCreateWithoutPartInput[] | PartUsageUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PartUsageCreateOrConnectWithoutPartInput | PartUsageCreateOrConnectWithoutPartInput[]
    createMany?: PartUsageCreateManyPartInputEnvelope
    connect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
  }

  export type CreditNoteItemUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<CreditNoteItemCreateWithoutPartInput, CreditNoteItemUncheckedCreateWithoutPartInput> | CreditNoteItemCreateWithoutPartInput[] | CreditNoteItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: CreditNoteItemCreateOrConnectWithoutPartInput | CreditNoteItemCreateOrConnectWithoutPartInput[]
    createMany?: CreditNoteItemCreateManyPartInputEnvelope
    connect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
  }

  export type POSQuotationItemUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<POSQuotationItemCreateWithoutPartInput, POSQuotationItemUncheckedCreateWithoutPartInput> | POSQuotationItemCreateWithoutPartInput[] | POSQuotationItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: POSQuotationItemCreateOrConnectWithoutPartInput | POSQuotationItemCreateOrConnectWithoutPartInput[]
    createMany?: POSQuotationItemCreateManyPartInputEnvelope
    connect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
  }

  export type POSSaleItemUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<POSSaleItemCreateWithoutPartInput, POSSaleItemUncheckedCreateWithoutPartInput> | POSSaleItemCreateWithoutPartInput[] | POSSaleItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: POSSaleItemCreateOrConnectWithoutPartInput | POSSaleItemCreateOrConnectWithoutPartInput[]
    createMany?: POSSaleItemCreateManyPartInputEnvelope
    connect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<PurchaseItemCreateWithoutPartInput, PurchaseItemUncheckedCreateWithoutPartInput> | PurchaseItemCreateWithoutPartInput[] | PurchaseItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPartInput | PurchaseItemCreateOrConnectWithoutPartInput[]
    createMany?: PurchaseItemCreateManyPartInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<TemplateDefaultPartCreateWithoutPartInput, TemplateDefaultPartUncheckedCreateWithoutPartInput> | TemplateDefaultPartCreateWithoutPartInput[] | TemplateDefaultPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: TemplateDefaultPartCreateOrConnectWithoutPartInput | TemplateDefaultPartCreateOrConnectWithoutPartInput[]
    createMany?: TemplateDefaultPartCreateManyPartInputEnvelope
    connect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
  }

  export type PartUsageUncheckedCreateNestedManyWithoutPartInput = {
    create?: XOR<PartUsageCreateWithoutPartInput, PartUsageUncheckedCreateWithoutPartInput> | PartUsageCreateWithoutPartInput[] | PartUsageUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PartUsageCreateOrConnectWithoutPartInput | PartUsageCreateOrConnectWithoutPartInput[]
    createMany?: PartUsageCreateManyPartInputEnvelope
    connect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CreditNoteItemUpdateManyWithoutPartNestedInput = {
    create?: XOR<CreditNoteItemCreateWithoutPartInput, CreditNoteItemUncheckedCreateWithoutPartInput> | CreditNoteItemCreateWithoutPartInput[] | CreditNoteItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: CreditNoteItemCreateOrConnectWithoutPartInput | CreditNoteItemCreateOrConnectWithoutPartInput[]
    upsert?: CreditNoteItemUpsertWithWhereUniqueWithoutPartInput | CreditNoteItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: CreditNoteItemCreateManyPartInputEnvelope
    set?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    disconnect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    delete?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    connect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    update?: CreditNoteItemUpdateWithWhereUniqueWithoutPartInput | CreditNoteItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: CreditNoteItemUpdateManyWithWhereWithoutPartInput | CreditNoteItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: CreditNoteItemScalarWhereInput | CreditNoteItemScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedPartsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPartsInput, UserUncheckedCreateWithoutCreatedPartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPartsInput
    upsert?: UserUpsertWithoutCreatedPartsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPartsInput, UserUpdateWithoutCreatedPartsInput>, UserUncheckedUpdateWithoutCreatedPartsInput>
  }

  export type POSQuotationItemUpdateManyWithoutPartNestedInput = {
    create?: XOR<POSQuotationItemCreateWithoutPartInput, POSQuotationItemUncheckedCreateWithoutPartInput> | POSQuotationItemCreateWithoutPartInput[] | POSQuotationItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: POSQuotationItemCreateOrConnectWithoutPartInput | POSQuotationItemCreateOrConnectWithoutPartInput[]
    upsert?: POSQuotationItemUpsertWithWhereUniqueWithoutPartInput | POSQuotationItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: POSQuotationItemCreateManyPartInputEnvelope
    set?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    disconnect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    delete?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    connect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    update?: POSQuotationItemUpdateWithWhereUniqueWithoutPartInput | POSQuotationItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: POSQuotationItemUpdateManyWithWhereWithoutPartInput | POSQuotationItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: POSQuotationItemScalarWhereInput | POSQuotationItemScalarWhereInput[]
  }

  export type POSSaleItemUpdateManyWithoutPartNestedInput = {
    create?: XOR<POSSaleItemCreateWithoutPartInput, POSSaleItemUncheckedCreateWithoutPartInput> | POSSaleItemCreateWithoutPartInput[] | POSSaleItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: POSSaleItemCreateOrConnectWithoutPartInput | POSSaleItemCreateOrConnectWithoutPartInput[]
    upsert?: POSSaleItemUpsertWithWhereUniqueWithoutPartInput | POSSaleItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: POSSaleItemCreateManyPartInputEnvelope
    set?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    disconnect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    delete?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    connect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    update?: POSSaleItemUpdateWithWhereUniqueWithoutPartInput | POSSaleItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: POSSaleItemUpdateManyWithWhereWithoutPartInput | POSSaleItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: POSSaleItemScalarWhereInput | POSSaleItemScalarWhereInput[]
  }

  export type PurchaseItemUpdateManyWithoutPartNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPartInput, PurchaseItemUncheckedCreateWithoutPartInput> | PurchaseItemCreateWithoutPartInput[] | PurchaseItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPartInput | PurchaseItemCreateOrConnectWithoutPartInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPartInput | PurchaseItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: PurchaseItemCreateManyPartInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPartInput | PurchaseItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPartInput | PurchaseItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TemplateDefaultPartUpdateManyWithoutPartNestedInput = {
    create?: XOR<TemplateDefaultPartCreateWithoutPartInput, TemplateDefaultPartUncheckedCreateWithoutPartInput> | TemplateDefaultPartCreateWithoutPartInput[] | TemplateDefaultPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: TemplateDefaultPartCreateOrConnectWithoutPartInput | TemplateDefaultPartCreateOrConnectWithoutPartInput[]
    upsert?: TemplateDefaultPartUpsertWithWhereUniqueWithoutPartInput | TemplateDefaultPartUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: TemplateDefaultPartCreateManyPartInputEnvelope
    set?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    disconnect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    delete?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    connect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    update?: TemplateDefaultPartUpdateWithWhereUniqueWithoutPartInput | TemplateDefaultPartUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: TemplateDefaultPartUpdateManyWithWhereWithoutPartInput | TemplateDefaultPartUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: TemplateDefaultPartScalarWhereInput | TemplateDefaultPartScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutPartsNestedInput = {
    create?: XOR<TenantCreateWithoutPartsInput, TenantUncheckedCreateWithoutPartsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPartsInput
    upsert?: TenantUpsertWithoutPartsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPartsInput, TenantUpdateWithoutPartsInput>, TenantUncheckedUpdateWithoutPartsInput>
  }

  export type UserUpdateOneWithoutUpdatedPartsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedPartsInput, UserUncheckedCreateWithoutUpdatedPartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedPartsInput
    upsert?: UserUpsertWithoutUpdatedPartsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedPartsInput, UserUpdateWithoutUpdatedPartsInput>, UserUncheckedUpdateWithoutUpdatedPartsInput>
  }

  export type PartUsageUpdateManyWithoutPartNestedInput = {
    create?: XOR<PartUsageCreateWithoutPartInput, PartUsageUncheckedCreateWithoutPartInput> | PartUsageCreateWithoutPartInput[] | PartUsageUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PartUsageCreateOrConnectWithoutPartInput | PartUsageCreateOrConnectWithoutPartInput[]
    upsert?: PartUsageUpsertWithWhereUniqueWithoutPartInput | PartUsageUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: PartUsageCreateManyPartInputEnvelope
    set?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    disconnect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    delete?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    connect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    update?: PartUsageUpdateWithWhereUniqueWithoutPartInput | PartUsageUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: PartUsageUpdateManyWithWhereWithoutPartInput | PartUsageUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: PartUsageScalarWhereInput | PartUsageScalarWhereInput[]
  }

  export type CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<CreditNoteItemCreateWithoutPartInput, CreditNoteItemUncheckedCreateWithoutPartInput> | CreditNoteItemCreateWithoutPartInput[] | CreditNoteItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: CreditNoteItemCreateOrConnectWithoutPartInput | CreditNoteItemCreateOrConnectWithoutPartInput[]
    upsert?: CreditNoteItemUpsertWithWhereUniqueWithoutPartInput | CreditNoteItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: CreditNoteItemCreateManyPartInputEnvelope
    set?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    disconnect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    delete?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    connect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    update?: CreditNoteItemUpdateWithWhereUniqueWithoutPartInput | CreditNoteItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: CreditNoteItemUpdateManyWithWhereWithoutPartInput | CreditNoteItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: CreditNoteItemScalarWhereInput | CreditNoteItemScalarWhereInput[]
  }

  export type POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<POSQuotationItemCreateWithoutPartInput, POSQuotationItemUncheckedCreateWithoutPartInput> | POSQuotationItemCreateWithoutPartInput[] | POSQuotationItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: POSQuotationItemCreateOrConnectWithoutPartInput | POSQuotationItemCreateOrConnectWithoutPartInput[]
    upsert?: POSQuotationItemUpsertWithWhereUniqueWithoutPartInput | POSQuotationItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: POSQuotationItemCreateManyPartInputEnvelope
    set?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    disconnect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    delete?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    connect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    update?: POSQuotationItemUpdateWithWhereUniqueWithoutPartInput | POSQuotationItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: POSQuotationItemUpdateManyWithWhereWithoutPartInput | POSQuotationItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: POSQuotationItemScalarWhereInput | POSQuotationItemScalarWhereInput[]
  }

  export type POSSaleItemUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<POSSaleItemCreateWithoutPartInput, POSSaleItemUncheckedCreateWithoutPartInput> | POSSaleItemCreateWithoutPartInput[] | POSSaleItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: POSSaleItemCreateOrConnectWithoutPartInput | POSSaleItemCreateOrConnectWithoutPartInput[]
    upsert?: POSSaleItemUpsertWithWhereUniqueWithoutPartInput | POSSaleItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: POSSaleItemCreateManyPartInputEnvelope
    set?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    disconnect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    delete?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    connect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    update?: POSSaleItemUpdateWithWhereUniqueWithoutPartInput | POSSaleItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: POSSaleItemUpdateManyWithWhereWithoutPartInput | POSSaleItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: POSSaleItemScalarWhereInput | POSSaleItemScalarWhereInput[]
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPartInput, PurchaseItemUncheckedCreateWithoutPartInput> | PurchaseItemCreateWithoutPartInput[] | PurchaseItemUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPartInput | PurchaseItemCreateOrConnectWithoutPartInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPartInput | PurchaseItemUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: PurchaseItemCreateManyPartInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPartInput | PurchaseItemUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPartInput | PurchaseItemUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<TemplateDefaultPartCreateWithoutPartInput, TemplateDefaultPartUncheckedCreateWithoutPartInput> | TemplateDefaultPartCreateWithoutPartInput[] | TemplateDefaultPartUncheckedCreateWithoutPartInput[]
    connectOrCreate?: TemplateDefaultPartCreateOrConnectWithoutPartInput | TemplateDefaultPartCreateOrConnectWithoutPartInput[]
    upsert?: TemplateDefaultPartUpsertWithWhereUniqueWithoutPartInput | TemplateDefaultPartUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: TemplateDefaultPartCreateManyPartInputEnvelope
    set?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    disconnect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    delete?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    connect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    update?: TemplateDefaultPartUpdateWithWhereUniqueWithoutPartInput | TemplateDefaultPartUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: TemplateDefaultPartUpdateManyWithWhereWithoutPartInput | TemplateDefaultPartUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: TemplateDefaultPartScalarWhereInput | TemplateDefaultPartScalarWhereInput[]
  }

  export type PartUsageUncheckedUpdateManyWithoutPartNestedInput = {
    create?: XOR<PartUsageCreateWithoutPartInput, PartUsageUncheckedCreateWithoutPartInput> | PartUsageCreateWithoutPartInput[] | PartUsageUncheckedCreateWithoutPartInput[]
    connectOrCreate?: PartUsageCreateOrConnectWithoutPartInput | PartUsageCreateOrConnectWithoutPartInput[]
    upsert?: PartUsageUpsertWithWhereUniqueWithoutPartInput | PartUsageUpsertWithWhereUniqueWithoutPartInput[]
    createMany?: PartUsageCreateManyPartInputEnvelope
    set?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    disconnect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    delete?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    connect?: PartUsageWhereUniqueInput | PartUsageWhereUniqueInput[]
    update?: PartUsageUpdateWithWhereUniqueWithoutPartInput | PartUsageUpdateWithWhereUniqueWithoutPartInput[]
    updateMany?: PartUsageUpdateManyWithWhereWithoutPartInput | PartUsageUpdateManyWithWhereWithoutPartInput[]
    deleteMany?: PartUsageScalarWhereInput | PartUsageScalarWhereInput[]
  }

  export type PurchaseItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseOrderInput, PurchaseItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseItemCreateWithoutPurchaseOrderInput[] | PurchaseItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPurchaseOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type PurchaseItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseOrderInput, PurchaseItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseItemCreateWithoutPurchaseOrderInput[] | PurchaseItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
  }

  export type EnumPurchaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseStatus
  }

  export type PurchaseItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseOrderInput, PurchaseItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseItemCreateWithoutPurchaseOrderInput[] | PurchaseItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: TenantUpsertWithoutPurchaseOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPurchaseOrdersInput, TenantUpdateWithoutPurchaseOrdersInput>, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseItemCreateWithoutPurchaseOrderInput, PurchaseItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseItemCreateWithoutPurchaseOrderInput[] | PurchaseItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    disconnect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    delete?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    connect?: PurchaseItemWhereUniqueInput | PurchaseItemWhereUniqueInput[]
    update?: PurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
  }

  export type PartCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<PartCreateWithoutPurchaseItemsInput, PartUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutPurchaseItemsInput
    connect?: PartWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type PartUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<PartCreateWithoutPurchaseItemsInput, PartUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutPurchaseItemsInput
    upsert?: PartUpsertWithoutPurchaseItemsInput
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutPurchaseItemsInput, PartUpdateWithoutPurchaseItemsInput>, PartUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PartCreateNestedOneWithoutUsagesInput = {
    create?: XOR<PartCreateWithoutUsagesInput, PartUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: PartCreateOrConnectWithoutUsagesInput
    connect?: PartWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutPartsUsedInput = {
    create?: XOR<TicketCreateWithoutPartsUsedInput, TicketUncheckedCreateWithoutPartsUsedInput>
    connectOrCreate?: TicketCreateOrConnectWithoutPartsUsedInput
    connect?: TicketWhereUniqueInput
  }

  export type PartUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<PartCreateWithoutUsagesInput, PartUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: PartCreateOrConnectWithoutUsagesInput
    upsert?: PartUpsertWithoutUsagesInput
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutUsagesInput, PartUpdateWithoutUsagesInput>, PartUncheckedUpdateWithoutUsagesInput>
  }

  export type TicketUpdateOneRequiredWithoutPartsUsedNestedInput = {
    create?: XOR<TicketCreateWithoutPartsUsedInput, TicketUncheckedCreateWithoutPartsUsedInput>
    connectOrCreate?: TicketCreateOrConnectWithoutPartsUsedInput
    upsert?: TicketUpsertWithoutPartsUsedInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutPartsUsedInput, TicketUpdateWithoutPartsUsedInput>, TicketUncheckedUpdateWithoutPartsUsedInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type EnumAuditModuleFieldUpdateOperationsInput = {
    set?: $Enums.AuditModule
  }

  export type TenantUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutTicketNotesInput = {
    create?: XOR<UserCreateWithoutTicketNotesInput, UserUncheckedCreateWithoutTicketNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketNotesInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutNotesInput = {
    create?: XOR<TicketCreateWithoutNotesInput, TicketUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutNotesInput
    connect?: TicketWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTicketNotesNestedInput = {
    create?: XOR<UserCreateWithoutTicketNotesInput, UserUncheckedCreateWithoutTicketNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketNotesInput
    upsert?: UserUpsertWithoutTicketNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketNotesInput, UserUpdateWithoutTicketNotesInput>, UserUncheckedUpdateWithoutTicketNotesInput>
  }

  export type TicketUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<TicketCreateWithoutNotesInput, TicketUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutNotesInput
    upsert?: TicketUpsertWithoutNotesInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutNotesInput, TicketUpdateWithoutNotesInput>, TicketUncheckedUpdateWithoutNotesInput>
  }

  export type UserCreateNestedOneWithoutCreatedTemplatesInput = {
    create?: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutServiceTemplatesInput = {
    create?: XOR<TenantCreateWithoutServiceTemplatesInput, TenantUncheckedCreateWithoutServiceTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutServiceTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedTemplatesInput = {
    create?: XOR<UserCreateWithoutUpdatedTemplatesInput, UserUncheckedCreateWithoutUpdatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type TemplateDefaultPartCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateDefaultPartCreateWithoutTemplateInput, TemplateDefaultPartUncheckedCreateWithoutTemplateInput> | TemplateDefaultPartCreateWithoutTemplateInput[] | TemplateDefaultPartUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateDefaultPartCreateOrConnectWithoutTemplateInput | TemplateDefaultPartCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateDefaultPartCreateManyTemplateInputEnvelope
    connect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
  }

  export type TicketServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<TicketServiceCreateWithoutServiceInput, TicketServiceUncheckedCreateWithoutServiceInput> | TicketServiceCreateWithoutServiceInput[] | TicketServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TicketServiceCreateOrConnectWithoutServiceInput | TicketServiceCreateOrConnectWithoutServiceInput[]
    createMany?: TicketServiceCreateManyServiceInputEnvelope
    connect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutServiceTemplateInput = {
    create?: XOR<TicketCreateWithoutServiceTemplateInput, TicketUncheckedCreateWithoutServiceTemplateInput> | TicketCreateWithoutServiceTemplateInput[] | TicketUncheckedCreateWithoutServiceTemplateInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutServiceTemplateInput | TicketCreateOrConnectWithoutServiceTemplateInput[]
    createMany?: TicketCreateManyServiceTemplateInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TemplateDefaultPartUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateDefaultPartCreateWithoutTemplateInput, TemplateDefaultPartUncheckedCreateWithoutTemplateInput> | TemplateDefaultPartCreateWithoutTemplateInput[] | TemplateDefaultPartUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateDefaultPartCreateOrConnectWithoutTemplateInput | TemplateDefaultPartCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateDefaultPartCreateManyTemplateInputEnvelope
    connect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
  }

  export type TicketServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<TicketServiceCreateWithoutServiceInput, TicketServiceUncheckedCreateWithoutServiceInput> | TicketServiceCreateWithoutServiceInput[] | TicketServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TicketServiceCreateOrConnectWithoutServiceInput | TicketServiceCreateOrConnectWithoutServiceInput[]
    createMany?: TicketServiceCreateManyServiceInputEnvelope
    connect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutServiceTemplateInput = {
    create?: XOR<TicketCreateWithoutServiceTemplateInput, TicketUncheckedCreateWithoutServiceTemplateInput> | TicketCreateWithoutServiceTemplateInput[] | TicketUncheckedCreateWithoutServiceTemplateInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutServiceTemplateInput | TicketCreateOrConnectWithoutServiceTemplateInput[]
    createMany?: TicketCreateManyServiceTemplateInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ServiceCategory
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneWithoutCreatedTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTemplatesInput
    upsert?: UserUpsertWithoutCreatedTemplatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTemplatesInput, UserUpdateWithoutCreatedTemplatesInput>, UserUncheckedUpdateWithoutCreatedTemplatesInput>
  }

  export type TenantUpdateOneRequiredWithoutServiceTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutServiceTemplatesInput, TenantUncheckedCreateWithoutServiceTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutServiceTemplatesInput
    upsert?: TenantUpsertWithoutServiceTemplatesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutServiceTemplatesInput, TenantUpdateWithoutServiceTemplatesInput>, TenantUncheckedUpdateWithoutServiceTemplatesInput>
  }

  export type UserUpdateOneWithoutUpdatedTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedTemplatesInput, UserUncheckedCreateWithoutUpdatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedTemplatesInput
    upsert?: UserUpsertWithoutUpdatedTemplatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedTemplatesInput, UserUpdateWithoutUpdatedTemplatesInput>, UserUncheckedUpdateWithoutUpdatedTemplatesInput>
  }

  export type TemplateDefaultPartUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateDefaultPartCreateWithoutTemplateInput, TemplateDefaultPartUncheckedCreateWithoutTemplateInput> | TemplateDefaultPartCreateWithoutTemplateInput[] | TemplateDefaultPartUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateDefaultPartCreateOrConnectWithoutTemplateInput | TemplateDefaultPartCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateDefaultPartUpsertWithWhereUniqueWithoutTemplateInput | TemplateDefaultPartUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateDefaultPartCreateManyTemplateInputEnvelope
    set?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    disconnect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    delete?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    connect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    update?: TemplateDefaultPartUpdateWithWhereUniqueWithoutTemplateInput | TemplateDefaultPartUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateDefaultPartUpdateManyWithWhereWithoutTemplateInput | TemplateDefaultPartUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateDefaultPartScalarWhereInput | TemplateDefaultPartScalarWhereInput[]
  }

  export type TicketServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TicketServiceCreateWithoutServiceInput, TicketServiceUncheckedCreateWithoutServiceInput> | TicketServiceCreateWithoutServiceInput[] | TicketServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TicketServiceCreateOrConnectWithoutServiceInput | TicketServiceCreateOrConnectWithoutServiceInput[]
    upsert?: TicketServiceUpsertWithWhereUniqueWithoutServiceInput | TicketServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TicketServiceCreateManyServiceInputEnvelope
    set?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    disconnect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    delete?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    connect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    update?: TicketServiceUpdateWithWhereUniqueWithoutServiceInput | TicketServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TicketServiceUpdateManyWithWhereWithoutServiceInput | TicketServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TicketServiceScalarWhereInput | TicketServiceScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutServiceTemplateNestedInput = {
    create?: XOR<TicketCreateWithoutServiceTemplateInput, TicketUncheckedCreateWithoutServiceTemplateInput> | TicketCreateWithoutServiceTemplateInput[] | TicketUncheckedCreateWithoutServiceTemplateInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutServiceTemplateInput | TicketCreateOrConnectWithoutServiceTemplateInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutServiceTemplateInput | TicketUpsertWithWhereUniqueWithoutServiceTemplateInput[]
    createMany?: TicketCreateManyServiceTemplateInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutServiceTemplateInput | TicketUpdateWithWhereUniqueWithoutServiceTemplateInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutServiceTemplateInput | TicketUpdateManyWithWhereWithoutServiceTemplateInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TemplateDefaultPartUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateDefaultPartCreateWithoutTemplateInput, TemplateDefaultPartUncheckedCreateWithoutTemplateInput> | TemplateDefaultPartCreateWithoutTemplateInput[] | TemplateDefaultPartUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateDefaultPartCreateOrConnectWithoutTemplateInput | TemplateDefaultPartCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateDefaultPartUpsertWithWhereUniqueWithoutTemplateInput | TemplateDefaultPartUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateDefaultPartCreateManyTemplateInputEnvelope
    set?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    disconnect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    delete?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    connect?: TemplateDefaultPartWhereUniqueInput | TemplateDefaultPartWhereUniqueInput[]
    update?: TemplateDefaultPartUpdateWithWhereUniqueWithoutTemplateInput | TemplateDefaultPartUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateDefaultPartUpdateManyWithWhereWithoutTemplateInput | TemplateDefaultPartUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateDefaultPartScalarWhereInput | TemplateDefaultPartScalarWhereInput[]
  }

  export type TicketServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TicketServiceCreateWithoutServiceInput, TicketServiceUncheckedCreateWithoutServiceInput> | TicketServiceCreateWithoutServiceInput[] | TicketServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TicketServiceCreateOrConnectWithoutServiceInput | TicketServiceCreateOrConnectWithoutServiceInput[]
    upsert?: TicketServiceUpsertWithWhereUniqueWithoutServiceInput | TicketServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TicketServiceCreateManyServiceInputEnvelope
    set?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    disconnect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    delete?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    connect?: TicketServiceWhereUniqueInput | TicketServiceWhereUniqueInput[]
    update?: TicketServiceUpdateWithWhereUniqueWithoutServiceInput | TicketServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TicketServiceUpdateManyWithWhereWithoutServiceInput | TicketServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TicketServiceScalarWhereInput | TicketServiceScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutServiceTemplateNestedInput = {
    create?: XOR<TicketCreateWithoutServiceTemplateInput, TicketUncheckedCreateWithoutServiceTemplateInput> | TicketCreateWithoutServiceTemplateInput[] | TicketUncheckedCreateWithoutServiceTemplateInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutServiceTemplateInput | TicketCreateOrConnectWithoutServiceTemplateInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutServiceTemplateInput | TicketUpsertWithWhereUniqueWithoutServiceTemplateInput[]
    createMany?: TicketCreateManyServiceTemplateInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutServiceTemplateInput | TicketUpdateWithWhereUniqueWithoutServiceTemplateInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutServiceTemplateInput | TicketUpdateManyWithWhereWithoutServiceTemplateInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type PartCreateNestedOneWithoutTemplateDefaultPartsInput = {
    create?: XOR<PartCreateWithoutTemplateDefaultPartsInput, PartUncheckedCreateWithoutTemplateDefaultPartsInput>
    connectOrCreate?: PartCreateOrConnectWithoutTemplateDefaultPartsInput
    connect?: PartWhereUniqueInput
  }

  export type ServiceTemplateCreateNestedOneWithoutDefaultPartsInput = {
    create?: XOR<ServiceTemplateCreateWithoutDefaultPartsInput, ServiceTemplateUncheckedCreateWithoutDefaultPartsInput>
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutDefaultPartsInput
    connect?: ServiceTemplateWhereUniqueInput
  }

  export type PartUpdateOneRequiredWithoutTemplateDefaultPartsNestedInput = {
    create?: XOR<PartCreateWithoutTemplateDefaultPartsInput, PartUncheckedCreateWithoutTemplateDefaultPartsInput>
    connectOrCreate?: PartCreateOrConnectWithoutTemplateDefaultPartsInput
    upsert?: PartUpsertWithoutTemplateDefaultPartsInput
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutTemplateDefaultPartsInput, PartUpdateWithoutTemplateDefaultPartsInput>, PartUncheckedUpdateWithoutTemplateDefaultPartsInput>
  }

  export type ServiceTemplateUpdateOneRequiredWithoutDefaultPartsNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutDefaultPartsInput, ServiceTemplateUncheckedCreateWithoutDefaultPartsInput>
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutDefaultPartsInput
    upsert?: ServiceTemplateUpsertWithoutDefaultPartsInput
    connect?: ServiceTemplateWhereUniqueInput
    update?: XOR<XOR<ServiceTemplateUpdateToOneWithWhereWithoutDefaultPartsInput, ServiceTemplateUpdateWithoutDefaultPartsInput>, ServiceTemplateUncheckedUpdateWithoutDefaultPartsInput>
  }

  export type ServiceTemplateCreateNestedOneWithoutUsagesInput = {
    create?: XOR<ServiceTemplateCreateWithoutUsagesInput, ServiceTemplateUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutUsagesInput
    connect?: ServiceTemplateWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutServicesInput = {
    create?: XOR<TicketCreateWithoutServicesInput, TicketUncheckedCreateWithoutServicesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutServicesInput
    connect?: TicketWhereUniqueInput
  }

  export type ServiceTemplateUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<ServiceTemplateCreateWithoutUsagesInput, ServiceTemplateUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: ServiceTemplateCreateOrConnectWithoutUsagesInput
    upsert?: ServiceTemplateUpsertWithoutUsagesInput
    connect?: ServiceTemplateWhereUniqueInput
    update?: XOR<XOR<ServiceTemplateUpdateToOneWithWhereWithoutUsagesInput, ServiceTemplateUpdateWithoutUsagesInput>, ServiceTemplateUncheckedUpdateWithoutUsagesInput>
  }

  export type TicketUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<TicketCreateWithoutServicesInput, TicketUncheckedCreateWithoutServicesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutServicesInput
    upsert?: TicketUpsertWithoutServicesInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutServicesInput, TicketUpdateWithoutServicesInput>, TicketUncheckedUpdateWithoutServicesInput>
  }

  export type UserCreateNestedOneWithoutSpecializationsInput = {
    create?: XOR<UserCreateWithoutSpecializationsInput, UserUncheckedCreateWithoutSpecializationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecializationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSpecializationFieldUpdateOperationsInput = {
    set?: $Enums.Specialization
  }

  export type UserUpdateOneRequiredWithoutSpecializationsNestedInput = {
    create?: XOR<UserCreateWithoutSpecializationsInput, UserUncheckedCreateWithoutSpecializationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpecializationsInput
    upsert?: UserUpsertWithoutSpecializationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpecializationsInput, UserUpdateWithoutSpecializationsInput>, UserUncheckedUpdateWithoutSpecializationsInput>
  }

  export type UserCreateNestedOneWithoutUnavailabilitiesInput = {
    create?: XOR<UserCreateWithoutUnavailabilitiesInput, UserUncheckedCreateWithoutUnavailabilitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUnavailabilitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUnavailabilitiesNestedInput = {
    create?: XOR<UserCreateWithoutUnavailabilitiesInput, UserUncheckedCreateWithoutUnavailabilitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUnavailabilitiesInput
    upsert?: UserUpsertWithoutUnavailabilitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUnavailabilitiesInput, UserUpdateWithoutUnavailabilitiesInput>, UserUncheckedUpdateWithoutUnavailabilitiesInput>
  }

  export type TenantCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    upsert?: TenantUpsertWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationsInput, TenantUpdateWithoutNotificationsInput>, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutCreatedInvoicesInput = {
    create?: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type InvoiceHistoryCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceHistoryCreateWithoutInvoiceInput, InvoiceHistoryUncheckedCreateWithoutInvoiceInput> | InvoiceHistoryCreateWithoutInvoiceInput[] | InvoiceHistoryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceHistoryCreateOrConnectWithoutInvoiceInput | InvoiceHistoryCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceHistoryCreateManyInvoiceInputEnvelope
    connect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<TicketCreateWithoutInvoiceInput, TicketUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: TicketCreateOrConnectWithoutInvoiceInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedInvoicesInput = {
    create?: XOR<UserCreateWithoutUpdatedInvoicesInput, UserUncheckedCreateWithoutUpdatedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceHistoryUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceHistoryCreateWithoutInvoiceInput, InvoiceHistoryUncheckedCreateWithoutInvoiceInput> | InvoiceHistoryCreateWithoutInvoiceInput[] | InvoiceHistoryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceHistoryCreateOrConnectWithoutInvoiceInput | InvoiceHistoryCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceHistoryCreateManyInvoiceInputEnvelope
    connect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvoicesInput
    upsert?: UserUpsertWithoutCreatedInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedInvoicesInput, UserUpdateWithoutCreatedInvoicesInput>, UserUncheckedUpdateWithoutCreatedInvoicesInput>
  }

  export type CustomerUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvoicesInput, CustomerUpdateWithoutInvoicesInput>, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceHistoryUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceHistoryCreateWithoutInvoiceInput, InvoiceHistoryUncheckedCreateWithoutInvoiceInput> | InvoiceHistoryCreateWithoutInvoiceInput[] | InvoiceHistoryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceHistoryCreateOrConnectWithoutInvoiceInput | InvoiceHistoryCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceHistoryUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceHistoryUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceHistoryCreateManyInvoiceInputEnvelope
    set?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    disconnect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    delete?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    connect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    update?: InvoiceHistoryUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceHistoryUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceHistoryUpdateManyWithWhereWithoutInvoiceInput | InvoiceHistoryUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceHistoryScalarWhereInput | InvoiceHistoryScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    upsert?: TenantUpsertWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicesInput, TenantUpdateWithoutInvoicesInput>, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TicketUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<TicketCreateWithoutInvoiceInput, TicketUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: TicketCreateOrConnectWithoutInvoiceInput
    upsert?: TicketUpsertWithoutInvoiceInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutInvoiceInput, TicketUpdateWithoutInvoiceInput>, TicketUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserUpdateOneRequiredWithoutUpdatedInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedInvoicesInput, UserUncheckedCreateWithoutUpdatedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedInvoicesInput
    upsert?: UserUpsertWithoutUpdatedInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedInvoicesInput, UserUpdateWithoutUpdatedInvoicesInput>, UserUncheckedUpdateWithoutUpdatedInvoicesInput>
  }

  export type InvoiceHistoryUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceHistoryCreateWithoutInvoiceInput, InvoiceHistoryUncheckedCreateWithoutInvoiceInput> | InvoiceHistoryCreateWithoutInvoiceInput[] | InvoiceHistoryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceHistoryCreateOrConnectWithoutInvoiceInput | InvoiceHistoryCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceHistoryUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceHistoryUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceHistoryCreateManyInvoiceInputEnvelope
    set?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    disconnect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    delete?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    connect?: InvoiceHistoryWhereUniqueInput | InvoiceHistoryWhereUniqueInput[]
    update?: InvoiceHistoryUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceHistoryUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceHistoryUpdateManyWithWhereWithoutInvoiceInput | InvoiceHistoryUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceHistoryScalarWhereInput | InvoiceHistoryScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedPaymentsInput = {
    create?: XOR<UserCreateWithoutReceivedPaymentsInput, UserUncheckedCreateWithoutReceivedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedPaymentsInput, UserUncheckedCreateWithoutReceivedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedPaymentsInput
    upsert?: UserUpsertWithoutReceivedPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedPaymentsInput, UserUpdateWithoutReceivedPaymentsInput>, UserUncheckedUpdateWithoutReceivedPaymentsInput>
  }

  export type TenantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    upsert?: TenantUpsertWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentsInput, TenantUpdateWithoutPaymentsInput>, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutClosedCashRegistersInput = {
    create?: XOR<UserCreateWithoutClosedCashRegistersInput, UserUncheckedCreateWithoutClosedCashRegistersInput>
    connectOrCreate?: UserCreateOrConnectWithoutClosedCashRegistersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOpenedCashRegistersInput = {
    create?: XOR<UserCreateWithoutOpenedCashRegistersInput, UserUncheckedCreateWithoutOpenedCashRegistersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpenedCashRegistersInput
    connect?: UserWhereUniqueInput
  }

  export type POSSaleCreateNestedManyWithoutCashRegisterInput = {
    create?: XOR<POSSaleCreateWithoutCashRegisterInput, POSSaleUncheckedCreateWithoutCashRegisterInput> | POSSaleCreateWithoutCashRegisterInput[] | POSSaleUncheckedCreateWithoutCashRegisterInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCashRegisterInput | POSSaleCreateOrConnectWithoutCashRegisterInput[]
    createMany?: POSSaleCreateManyCashRegisterInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutCashRegistersInput = {
    create?: XOR<TenantCreateWithoutCashRegistersInput, TenantUncheckedCreateWithoutCashRegistersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashRegistersInput
    connect?: TenantWhereUniqueInput
  }

  export type CashTransactionCreateNestedManyWithoutCashRegisterInput = {
    create?: XOR<CashTransactionCreateWithoutCashRegisterInput, CashTransactionUncheckedCreateWithoutCashRegisterInput> | CashTransactionCreateWithoutCashRegisterInput[] | CashTransactionUncheckedCreateWithoutCashRegisterInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCashRegisterInput | CashTransactionCreateOrConnectWithoutCashRegisterInput[]
    createMany?: CashTransactionCreateManyCashRegisterInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type POSSaleUncheckedCreateNestedManyWithoutCashRegisterInput = {
    create?: XOR<POSSaleCreateWithoutCashRegisterInput, POSSaleUncheckedCreateWithoutCashRegisterInput> | POSSaleCreateWithoutCashRegisterInput[] | POSSaleUncheckedCreateWithoutCashRegisterInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCashRegisterInput | POSSaleCreateOrConnectWithoutCashRegisterInput[]
    createMany?: POSSaleCreateManyCashRegisterInputEnvelope
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutCashRegisterInput = {
    create?: XOR<CashTransactionCreateWithoutCashRegisterInput, CashTransactionUncheckedCreateWithoutCashRegisterInput> | CashTransactionCreateWithoutCashRegisterInput[] | CashTransactionUncheckedCreateWithoutCashRegisterInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCashRegisterInput | CashTransactionCreateOrConnectWithoutCashRegisterInput[]
    createMany?: CashTransactionCreateManyCashRegisterInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutClosedCashRegistersNestedInput = {
    create?: XOR<UserCreateWithoutClosedCashRegistersInput, UserUncheckedCreateWithoutClosedCashRegistersInput>
    connectOrCreate?: UserCreateOrConnectWithoutClosedCashRegistersInput
    upsert?: UserUpsertWithoutClosedCashRegistersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClosedCashRegistersInput, UserUpdateWithoutClosedCashRegistersInput>, UserUncheckedUpdateWithoutClosedCashRegistersInput>
  }

  export type UserUpdateOneWithoutOpenedCashRegistersNestedInput = {
    create?: XOR<UserCreateWithoutOpenedCashRegistersInput, UserUncheckedCreateWithoutOpenedCashRegistersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpenedCashRegistersInput
    upsert?: UserUpsertWithoutOpenedCashRegistersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOpenedCashRegistersInput, UserUpdateWithoutOpenedCashRegistersInput>, UserUncheckedUpdateWithoutOpenedCashRegistersInput>
  }

  export type POSSaleUpdateManyWithoutCashRegisterNestedInput = {
    create?: XOR<POSSaleCreateWithoutCashRegisterInput, POSSaleUncheckedCreateWithoutCashRegisterInput> | POSSaleCreateWithoutCashRegisterInput[] | POSSaleUncheckedCreateWithoutCashRegisterInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCashRegisterInput | POSSaleCreateOrConnectWithoutCashRegisterInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutCashRegisterInput | POSSaleUpsertWithWhereUniqueWithoutCashRegisterInput[]
    createMany?: POSSaleCreateManyCashRegisterInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutCashRegisterInput | POSSaleUpdateWithWhereUniqueWithoutCashRegisterInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutCashRegisterInput | POSSaleUpdateManyWithWhereWithoutCashRegisterInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutCashRegistersNestedInput = {
    create?: XOR<TenantCreateWithoutCashRegistersInput, TenantUncheckedCreateWithoutCashRegistersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashRegistersInput
    upsert?: TenantUpsertWithoutCashRegistersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCashRegistersInput, TenantUpdateWithoutCashRegistersInput>, TenantUncheckedUpdateWithoutCashRegistersInput>
  }

  export type CashTransactionUpdateManyWithoutCashRegisterNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCashRegisterInput, CashTransactionUncheckedCreateWithoutCashRegisterInput> | CashTransactionCreateWithoutCashRegisterInput[] | CashTransactionUncheckedCreateWithoutCashRegisterInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCashRegisterInput | CashTransactionCreateOrConnectWithoutCashRegisterInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCashRegisterInput | CashTransactionUpsertWithWhereUniqueWithoutCashRegisterInput[]
    createMany?: CashTransactionCreateManyCashRegisterInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCashRegisterInput | CashTransactionUpdateWithWhereUniqueWithoutCashRegisterInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCashRegisterInput | CashTransactionUpdateManyWithWhereWithoutCashRegisterInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type POSSaleUncheckedUpdateManyWithoutCashRegisterNestedInput = {
    create?: XOR<POSSaleCreateWithoutCashRegisterInput, POSSaleUncheckedCreateWithoutCashRegisterInput> | POSSaleCreateWithoutCashRegisterInput[] | POSSaleUncheckedCreateWithoutCashRegisterInput[]
    connectOrCreate?: POSSaleCreateOrConnectWithoutCashRegisterInput | POSSaleCreateOrConnectWithoutCashRegisterInput[]
    upsert?: POSSaleUpsertWithWhereUniqueWithoutCashRegisterInput | POSSaleUpsertWithWhereUniqueWithoutCashRegisterInput[]
    createMany?: POSSaleCreateManyCashRegisterInputEnvelope
    set?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    disconnect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    delete?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    connect?: POSSaleWhereUniqueInput | POSSaleWhereUniqueInput[]
    update?: POSSaleUpdateWithWhereUniqueWithoutCashRegisterInput | POSSaleUpdateWithWhereUniqueWithoutCashRegisterInput[]
    updateMany?: POSSaleUpdateManyWithWhereWithoutCashRegisterInput | POSSaleUpdateManyWithWhereWithoutCashRegisterInput[]
    deleteMany?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutCashRegisterNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCashRegisterInput, CashTransactionUncheckedCreateWithoutCashRegisterInput> | CashTransactionCreateWithoutCashRegisterInput[] | CashTransactionUncheckedCreateWithoutCashRegisterInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCashRegisterInput | CashTransactionCreateOrConnectWithoutCashRegisterInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCashRegisterInput | CashTransactionUpsertWithWhereUniqueWithoutCashRegisterInput[]
    createMany?: CashTransactionCreateManyCashRegisterInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCashRegisterInput | CashTransactionUpdateWithWhereUniqueWithoutCashRegisterInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCashRegisterInput | CashTransactionUpdateManyWithWhereWithoutCashRegisterInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CashRegisterCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CashRegisterCreateWithoutTransactionsInput, CashRegisterUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTransactionsInput
    connect?: CashRegisterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCashTransactionsInput = {
    create?: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCashTransactionsInput = {
    create?: XOR<TenantCreateWithoutCashTransactionsInput, TenantUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashTransactionsInput
    connect?: TenantWhereUniqueInput
  }

  export type CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CashRegisterCreateWithoutTransactionsInput, CashRegisterUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutTransactionsInput
    upsert?: CashRegisterUpsertWithoutTransactionsInput
    connect?: CashRegisterWhereUniqueInput
    update?: XOR<XOR<CashRegisterUpdateToOneWithWhereWithoutTransactionsInput, CashRegisterUpdateWithoutTransactionsInput>, CashRegisterUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneRequiredWithoutCashTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashTransactionsInput
    upsert?: UserUpsertWithoutCashTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashTransactionsInput, UserUpdateWithoutCashTransactionsInput>, UserUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type TenantUpdateOneRequiredWithoutCashTransactionsNestedInput = {
    create?: XOR<TenantCreateWithoutCashTransactionsInput, TenantUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCashTransactionsInput
    upsert?: TenantUpsertWithoutCashTransactionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCashTransactionsInput, TenantUpdateWithoutCashTransactionsInput>, TenantUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type TenantCreateNestedOneWithoutSettingsInput = {
    create?: XOR<TenantCreateWithoutSettingsInput, TenantUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSettingsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<TenantCreateWithoutSettingsInput, TenantUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSettingsInput
    upsert?: TenantUpsertWithoutSettingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSettingsInput, TenantUpdateWithoutSettingsInput>, TenantUncheckedUpdateWithoutSettingsInput>
  }

  export type InvoiceCreateNestedOneWithoutHistoryInput = {
    create?: XOR<InvoiceCreateWithoutHistoryInput, InvoiceUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutHistoryInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoiceHistoryInput = {
    create?: XOR<UserCreateWithoutInvoiceHistoryInput, UserUncheckedCreateWithoutInvoiceHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<InvoiceCreateWithoutHistoryInput, InvoiceUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutHistoryInput
    upsert?: InvoiceUpsertWithoutHistoryInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutHistoryInput, InvoiceUpdateWithoutHistoryInput>, InvoiceUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutInvoiceHistoryNestedInput = {
    create?: XOR<UserCreateWithoutInvoiceHistoryInput, UserUncheckedCreateWithoutInvoiceHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceHistoryInput
    upsert?: UserUpsertWithoutInvoiceHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoiceHistoryInput, UserUpdateWithoutInvoiceHistoryInput>, UserUncheckedUpdateWithoutInvoiceHistoryInput>
  }

  export type CashRegisterCreateNestedOneWithoutPosSalesInput = {
    create?: XOR<CashRegisterCreateWithoutPosSalesInput, CashRegisterUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutPosSalesInput
    connect?: CashRegisterWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPosSalesInput = {
    create?: XOR<UserCreateWithoutPosSalesInput, UserUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPosSalesInput
    connect?: UserWhereUniqueInput
  }

  export type CreditNoteCreateNestedManyWithoutPosSaleInput = {
    create?: XOR<CreditNoteCreateWithoutPosSaleInput, CreditNoteUncheckedCreateWithoutPosSaleInput> | CreditNoteCreateWithoutPosSaleInput[] | CreditNoteUncheckedCreateWithoutPosSaleInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutPosSaleInput | CreditNoteCreateOrConnectWithoutPosSaleInput[]
    createMany?: CreditNoteCreateManyPosSaleInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutPosSalesInput = {
    create?: XOR<CustomerCreateWithoutPosSalesInput, CustomerUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPosSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type POSSaleItemCreateNestedManyWithoutSaleInput = {
    create?: XOR<POSSaleItemCreateWithoutSaleInput, POSSaleItemUncheckedCreateWithoutSaleInput> | POSSaleItemCreateWithoutSaleInput[] | POSSaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: POSSaleItemCreateOrConnectWithoutSaleInput | POSSaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: POSSaleItemCreateManySaleInputEnvelope
    connect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
  }

  export type POSSalePaymentCreateNestedManyWithoutSaleInput = {
    create?: XOR<POSSalePaymentCreateWithoutSaleInput, POSSalePaymentUncheckedCreateWithoutSaleInput> | POSSalePaymentCreateWithoutSaleInput[] | POSSalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: POSSalePaymentCreateOrConnectWithoutSaleInput | POSSalePaymentCreateOrConnectWithoutSaleInput[]
    createMany?: POSSalePaymentCreateManySaleInputEnvelope
    connect?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
  }

  export type POSQuotationCreateNestedOneWithoutConvertedToSaleInput = {
    create?: XOR<POSQuotationCreateWithoutConvertedToSaleInput, POSQuotationUncheckedCreateWithoutConvertedToSaleInput>
    connectOrCreate?: POSQuotationCreateOrConnectWithoutConvertedToSaleInput
    connect?: POSQuotationWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutPosSalesInput = {
    create?: XOR<TenantCreateWithoutPosSalesInput, TenantUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPosSalesInput
    connect?: TenantWhereUniqueInput
  }

  export type CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput = {
    create?: XOR<CreditNoteCreateWithoutPosSaleInput, CreditNoteUncheckedCreateWithoutPosSaleInput> | CreditNoteCreateWithoutPosSaleInput[] | CreditNoteUncheckedCreateWithoutPosSaleInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutPosSaleInput | CreditNoteCreateOrConnectWithoutPosSaleInput[]
    createMany?: CreditNoteCreateManyPosSaleInputEnvelope
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
  }

  export type POSSaleItemUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<POSSaleItemCreateWithoutSaleInput, POSSaleItemUncheckedCreateWithoutSaleInput> | POSSaleItemCreateWithoutSaleInput[] | POSSaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: POSSaleItemCreateOrConnectWithoutSaleInput | POSSaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: POSSaleItemCreateManySaleInputEnvelope
    connect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
  }

  export type POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<POSSalePaymentCreateWithoutSaleInput, POSSalePaymentUncheckedCreateWithoutSaleInput> | POSSalePaymentCreateWithoutSaleInput[] | POSSalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: POSSalePaymentCreateOrConnectWithoutSaleInput | POSSalePaymentCreateOrConnectWithoutSaleInput[]
    createMany?: POSSalePaymentCreateManySaleInputEnvelope
    connect?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
  }

  export type EnumPOSSaleStatusFieldUpdateOperationsInput = {
    set?: $Enums.POSSaleStatus
  }

  export type CashRegisterUpdateOneWithoutPosSalesNestedInput = {
    create?: XOR<CashRegisterCreateWithoutPosSalesInput, CashRegisterUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: CashRegisterCreateOrConnectWithoutPosSalesInput
    upsert?: CashRegisterUpsertWithoutPosSalesInput
    disconnect?: CashRegisterWhereInput | boolean
    delete?: CashRegisterWhereInput | boolean
    connect?: CashRegisterWhereUniqueInput
    update?: XOR<XOR<CashRegisterUpdateToOneWithWhereWithoutPosSalesInput, CashRegisterUpdateWithoutPosSalesInput>, CashRegisterUncheckedUpdateWithoutPosSalesInput>
  }

  export type UserUpdateOneRequiredWithoutPosSalesNestedInput = {
    create?: XOR<UserCreateWithoutPosSalesInput, UserUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPosSalesInput
    upsert?: UserUpsertWithoutPosSalesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPosSalesInput, UserUpdateWithoutPosSalesInput>, UserUncheckedUpdateWithoutPosSalesInput>
  }

  export type CreditNoteUpdateManyWithoutPosSaleNestedInput = {
    create?: XOR<CreditNoteCreateWithoutPosSaleInput, CreditNoteUncheckedCreateWithoutPosSaleInput> | CreditNoteCreateWithoutPosSaleInput[] | CreditNoteUncheckedCreateWithoutPosSaleInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutPosSaleInput | CreditNoteCreateOrConnectWithoutPosSaleInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutPosSaleInput | CreditNoteUpsertWithWhereUniqueWithoutPosSaleInput[]
    createMany?: CreditNoteCreateManyPosSaleInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutPosSaleInput | CreditNoteUpdateWithWhereUniqueWithoutPosSaleInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutPosSaleInput | CreditNoteUpdateManyWithWhereWithoutPosSaleInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutPosSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutPosSalesInput, CustomerUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPosSalesInput
    upsert?: CustomerUpsertWithoutPosSalesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPosSalesInput, CustomerUpdateWithoutPosSalesInput>, CustomerUncheckedUpdateWithoutPosSalesInput>
  }

  export type POSSaleItemUpdateManyWithoutSaleNestedInput = {
    create?: XOR<POSSaleItemCreateWithoutSaleInput, POSSaleItemUncheckedCreateWithoutSaleInput> | POSSaleItemCreateWithoutSaleInput[] | POSSaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: POSSaleItemCreateOrConnectWithoutSaleInput | POSSaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: POSSaleItemUpsertWithWhereUniqueWithoutSaleInput | POSSaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: POSSaleItemCreateManySaleInputEnvelope
    set?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    disconnect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    delete?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    connect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    update?: POSSaleItemUpdateWithWhereUniqueWithoutSaleInput | POSSaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: POSSaleItemUpdateManyWithWhereWithoutSaleInput | POSSaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: POSSaleItemScalarWhereInput | POSSaleItemScalarWhereInput[]
  }

  export type POSSalePaymentUpdateManyWithoutSaleNestedInput = {
    create?: XOR<POSSalePaymentCreateWithoutSaleInput, POSSalePaymentUncheckedCreateWithoutSaleInput> | POSSalePaymentCreateWithoutSaleInput[] | POSSalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: POSSalePaymentCreateOrConnectWithoutSaleInput | POSSalePaymentCreateOrConnectWithoutSaleInput[]
    upsert?: POSSalePaymentUpsertWithWhereUniqueWithoutSaleInput | POSSalePaymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: POSSalePaymentCreateManySaleInputEnvelope
    set?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
    disconnect?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
    delete?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
    connect?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
    update?: POSSalePaymentUpdateWithWhereUniqueWithoutSaleInput | POSSalePaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: POSSalePaymentUpdateManyWithWhereWithoutSaleInput | POSSalePaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: POSSalePaymentScalarWhereInput | POSSalePaymentScalarWhereInput[]
  }

  export type POSQuotationUpdateOneWithoutConvertedToSaleNestedInput = {
    create?: XOR<POSQuotationCreateWithoutConvertedToSaleInput, POSQuotationUncheckedCreateWithoutConvertedToSaleInput>
    connectOrCreate?: POSQuotationCreateOrConnectWithoutConvertedToSaleInput
    upsert?: POSQuotationUpsertWithoutConvertedToSaleInput
    disconnect?: POSQuotationWhereInput | boolean
    delete?: POSQuotationWhereInput | boolean
    connect?: POSQuotationWhereUniqueInput
    update?: XOR<XOR<POSQuotationUpdateToOneWithWhereWithoutConvertedToSaleInput, POSQuotationUpdateWithoutConvertedToSaleInput>, POSQuotationUncheckedUpdateWithoutConvertedToSaleInput>
  }

  export type TenantUpdateOneRequiredWithoutPosSalesNestedInput = {
    create?: XOR<TenantCreateWithoutPosSalesInput, TenantUncheckedCreateWithoutPosSalesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPosSalesInput
    upsert?: TenantUpsertWithoutPosSalesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPosSalesInput, TenantUpdateWithoutPosSalesInput>, TenantUncheckedUpdateWithoutPosSalesInput>
  }

  export type CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput = {
    create?: XOR<CreditNoteCreateWithoutPosSaleInput, CreditNoteUncheckedCreateWithoutPosSaleInput> | CreditNoteCreateWithoutPosSaleInput[] | CreditNoteUncheckedCreateWithoutPosSaleInput[]
    connectOrCreate?: CreditNoteCreateOrConnectWithoutPosSaleInput | CreditNoteCreateOrConnectWithoutPosSaleInput[]
    upsert?: CreditNoteUpsertWithWhereUniqueWithoutPosSaleInput | CreditNoteUpsertWithWhereUniqueWithoutPosSaleInput[]
    createMany?: CreditNoteCreateManyPosSaleInputEnvelope
    set?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    disconnect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    delete?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    connect?: CreditNoteWhereUniqueInput | CreditNoteWhereUniqueInput[]
    update?: CreditNoteUpdateWithWhereUniqueWithoutPosSaleInput | CreditNoteUpdateWithWhereUniqueWithoutPosSaleInput[]
    updateMany?: CreditNoteUpdateManyWithWhereWithoutPosSaleInput | CreditNoteUpdateManyWithWhereWithoutPosSaleInput[]
    deleteMany?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
  }

  export type POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<POSSaleItemCreateWithoutSaleInput, POSSaleItemUncheckedCreateWithoutSaleInput> | POSSaleItemCreateWithoutSaleInput[] | POSSaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: POSSaleItemCreateOrConnectWithoutSaleInput | POSSaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: POSSaleItemUpsertWithWhereUniqueWithoutSaleInput | POSSaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: POSSaleItemCreateManySaleInputEnvelope
    set?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    disconnect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    delete?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    connect?: POSSaleItemWhereUniqueInput | POSSaleItemWhereUniqueInput[]
    update?: POSSaleItemUpdateWithWhereUniqueWithoutSaleInput | POSSaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: POSSaleItemUpdateManyWithWhereWithoutSaleInput | POSSaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: POSSaleItemScalarWhereInput | POSSaleItemScalarWhereInput[]
  }

  export type POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<POSSalePaymentCreateWithoutSaleInput, POSSalePaymentUncheckedCreateWithoutSaleInput> | POSSalePaymentCreateWithoutSaleInput[] | POSSalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: POSSalePaymentCreateOrConnectWithoutSaleInput | POSSalePaymentCreateOrConnectWithoutSaleInput[]
    upsert?: POSSalePaymentUpsertWithWhereUniqueWithoutSaleInput | POSSalePaymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: POSSalePaymentCreateManySaleInputEnvelope
    set?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
    disconnect?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
    delete?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
    connect?: POSSalePaymentWhereUniqueInput | POSSalePaymentWhereUniqueInput[]
    update?: POSSalePaymentUpdateWithWhereUniqueWithoutSaleInput | POSSalePaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: POSSalePaymentUpdateManyWithWhereWithoutSaleInput | POSSalePaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: POSSalePaymentScalarWhereInput | POSSalePaymentScalarWhereInput[]
  }

  export type PartCreateNestedOneWithoutPosSaleItemsInput = {
    create?: XOR<PartCreateWithoutPosSaleItemsInput, PartUncheckedCreateWithoutPosSaleItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutPosSaleItemsInput
    connect?: PartWhereUniqueInput
  }

  export type POSSaleCreateNestedOneWithoutItemsInput = {
    create?: XOR<POSSaleCreateWithoutItemsInput, POSSaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutItemsInput
    connect?: POSSaleWhereUniqueInput
  }

  export type PartUpdateOneRequiredWithoutPosSaleItemsNestedInput = {
    create?: XOR<PartCreateWithoutPosSaleItemsInput, PartUncheckedCreateWithoutPosSaleItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutPosSaleItemsInput
    upsert?: PartUpsertWithoutPosSaleItemsInput
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutPosSaleItemsInput, PartUpdateWithoutPosSaleItemsInput>, PartUncheckedUpdateWithoutPosSaleItemsInput>
  }

  export type POSSaleUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<POSSaleCreateWithoutItemsInput, POSSaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutItemsInput
    upsert?: POSSaleUpsertWithoutItemsInput
    connect?: POSSaleWhereUniqueInput
    update?: XOR<XOR<POSSaleUpdateToOneWithWhereWithoutItemsInput, POSSaleUpdateWithoutItemsInput>, POSSaleUncheckedUpdateWithoutItemsInput>
  }

  export type POSSaleCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<POSSaleCreateWithoutPaymentsInput, POSSaleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutPaymentsInput
    connect?: POSSaleWhereUniqueInput
  }

  export type POSSaleUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<POSSaleCreateWithoutPaymentsInput, POSSaleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutPaymentsInput
    upsert?: POSSaleUpsertWithoutPaymentsInput
    connect?: POSSaleWhereUniqueInput
    update?: XOR<XOR<POSSaleUpdateToOneWithWhereWithoutPaymentsInput, POSSaleUpdateWithoutPaymentsInput>, POSSaleUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutPosQuotationsInput = {
    create?: XOR<UserCreateWithoutPosQuotationsInput, UserUncheckedCreateWithoutPosQuotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPosQuotationsInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPosQuotationsInput = {
    create?: XOR<CustomerCreateWithoutPosQuotationsInput, CustomerUncheckedCreateWithoutPosQuotationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPosQuotationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type POSQuotationItemCreateNestedManyWithoutQuotationInput = {
    create?: XOR<POSQuotationItemCreateWithoutQuotationInput, POSQuotationItemUncheckedCreateWithoutQuotationInput> | POSQuotationItemCreateWithoutQuotationInput[] | POSQuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: POSQuotationItemCreateOrConnectWithoutQuotationInput | POSQuotationItemCreateOrConnectWithoutQuotationInput[]
    createMany?: POSQuotationItemCreateManyQuotationInputEnvelope
    connect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
  }

  export type POSSaleCreateNestedOneWithoutQuotationInput = {
    create?: XOR<POSSaleCreateWithoutQuotationInput, POSSaleUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutQuotationInput
    connect?: POSSaleWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutPosQuotationsInput = {
    create?: XOR<TenantCreateWithoutPosQuotationsInput, TenantUncheckedCreateWithoutPosQuotationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPosQuotationsInput
    connect?: TenantWhereUniqueInput
  }

  export type POSQuotationItemUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<POSQuotationItemCreateWithoutQuotationInput, POSQuotationItemUncheckedCreateWithoutQuotationInput> | POSQuotationItemCreateWithoutQuotationInput[] | POSQuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: POSQuotationItemCreateOrConnectWithoutQuotationInput | POSQuotationItemCreateOrConnectWithoutQuotationInput[]
    createMany?: POSQuotationItemCreateManyQuotationInputEnvelope
    connect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
  }

  export type POSSaleUncheckedCreateNestedOneWithoutQuotationInput = {
    create?: XOR<POSSaleCreateWithoutQuotationInput, POSSaleUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutQuotationInput
    connect?: POSSaleWhereUniqueInput
  }

  export type EnumQuotationStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuotationStatus
  }

  export type UserUpdateOneRequiredWithoutPosQuotationsNestedInput = {
    create?: XOR<UserCreateWithoutPosQuotationsInput, UserUncheckedCreateWithoutPosQuotationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPosQuotationsInput
    upsert?: UserUpsertWithoutPosQuotationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPosQuotationsInput, UserUpdateWithoutPosQuotationsInput>, UserUncheckedUpdateWithoutPosQuotationsInput>
  }

  export type CustomerUpdateOneWithoutPosQuotationsNestedInput = {
    create?: XOR<CustomerCreateWithoutPosQuotationsInput, CustomerUncheckedCreateWithoutPosQuotationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPosQuotationsInput
    upsert?: CustomerUpsertWithoutPosQuotationsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPosQuotationsInput, CustomerUpdateWithoutPosQuotationsInput>, CustomerUncheckedUpdateWithoutPosQuotationsInput>
  }

  export type POSQuotationItemUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<POSQuotationItemCreateWithoutQuotationInput, POSQuotationItemUncheckedCreateWithoutQuotationInput> | POSQuotationItemCreateWithoutQuotationInput[] | POSQuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: POSQuotationItemCreateOrConnectWithoutQuotationInput | POSQuotationItemCreateOrConnectWithoutQuotationInput[]
    upsert?: POSQuotationItemUpsertWithWhereUniqueWithoutQuotationInput | POSQuotationItemUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: POSQuotationItemCreateManyQuotationInputEnvelope
    set?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    disconnect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    delete?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    connect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    update?: POSQuotationItemUpdateWithWhereUniqueWithoutQuotationInput | POSQuotationItemUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: POSQuotationItemUpdateManyWithWhereWithoutQuotationInput | POSQuotationItemUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: POSQuotationItemScalarWhereInput | POSQuotationItemScalarWhereInput[]
  }

  export type POSSaleUpdateOneWithoutQuotationNestedInput = {
    create?: XOR<POSSaleCreateWithoutQuotationInput, POSSaleUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutQuotationInput
    upsert?: POSSaleUpsertWithoutQuotationInput
    disconnect?: POSSaleWhereInput | boolean
    delete?: POSSaleWhereInput | boolean
    connect?: POSSaleWhereUniqueInput
    update?: XOR<XOR<POSSaleUpdateToOneWithWhereWithoutQuotationInput, POSSaleUpdateWithoutQuotationInput>, POSSaleUncheckedUpdateWithoutQuotationInput>
  }

  export type TenantUpdateOneRequiredWithoutPosQuotationsNestedInput = {
    create?: XOR<TenantCreateWithoutPosQuotationsInput, TenantUncheckedCreateWithoutPosQuotationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPosQuotationsInput
    upsert?: TenantUpsertWithoutPosQuotationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPosQuotationsInput, TenantUpdateWithoutPosQuotationsInput>, TenantUncheckedUpdateWithoutPosQuotationsInput>
  }

  export type POSQuotationItemUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<POSQuotationItemCreateWithoutQuotationInput, POSQuotationItemUncheckedCreateWithoutQuotationInput> | POSQuotationItemCreateWithoutQuotationInput[] | POSQuotationItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: POSQuotationItemCreateOrConnectWithoutQuotationInput | POSQuotationItemCreateOrConnectWithoutQuotationInput[]
    upsert?: POSQuotationItemUpsertWithWhereUniqueWithoutQuotationInput | POSQuotationItemUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: POSQuotationItemCreateManyQuotationInputEnvelope
    set?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    disconnect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    delete?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    connect?: POSQuotationItemWhereUniqueInput | POSQuotationItemWhereUniqueInput[]
    update?: POSQuotationItemUpdateWithWhereUniqueWithoutQuotationInput | POSQuotationItemUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: POSQuotationItemUpdateManyWithWhereWithoutQuotationInput | POSQuotationItemUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: POSQuotationItemScalarWhereInput | POSQuotationItemScalarWhereInput[]
  }

  export type POSSaleUncheckedUpdateOneWithoutQuotationNestedInput = {
    create?: XOR<POSSaleCreateWithoutQuotationInput, POSSaleUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutQuotationInput
    upsert?: POSSaleUpsertWithoutQuotationInput
    disconnect?: POSSaleWhereInput | boolean
    delete?: POSSaleWhereInput | boolean
    connect?: POSSaleWhereUniqueInput
    update?: XOR<XOR<POSSaleUpdateToOneWithWhereWithoutQuotationInput, POSSaleUpdateWithoutQuotationInput>, POSSaleUncheckedUpdateWithoutQuotationInput>
  }

  export type PartCreateNestedOneWithoutPosQuotationItemsInput = {
    create?: XOR<PartCreateWithoutPosQuotationItemsInput, PartUncheckedCreateWithoutPosQuotationItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutPosQuotationItemsInput
    connect?: PartWhereUniqueInput
  }

  export type POSQuotationCreateNestedOneWithoutItemsInput = {
    create?: XOR<POSQuotationCreateWithoutItemsInput, POSQuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: POSQuotationCreateOrConnectWithoutItemsInput
    connect?: POSQuotationWhereUniqueInput
  }

  export type PartUpdateOneRequiredWithoutPosQuotationItemsNestedInput = {
    create?: XOR<PartCreateWithoutPosQuotationItemsInput, PartUncheckedCreateWithoutPosQuotationItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutPosQuotationItemsInput
    upsert?: PartUpsertWithoutPosQuotationItemsInput
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutPosQuotationItemsInput, PartUpdateWithoutPosQuotationItemsInput>, PartUncheckedUpdateWithoutPosQuotationItemsInput>
  }

  export type POSQuotationUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<POSQuotationCreateWithoutItemsInput, POSQuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: POSQuotationCreateOrConnectWithoutItemsInput
    upsert?: POSQuotationUpsertWithoutItemsInput
    connect?: POSQuotationWhereUniqueInput
    update?: XOR<XOR<POSQuotationUpdateToOneWithWhereWithoutItemsInput, POSQuotationUpdateWithoutItemsInput>, POSQuotationUncheckedUpdateWithoutItemsInput>
  }

  export type UserCreateNestedOneWithoutCreditNotesCreatedInput = {
    create?: XOR<UserCreateWithoutCreditNotesCreatedInput, UserUncheckedCreateWithoutCreditNotesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditNotesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreditNotesProcessedInput = {
    create?: XOR<UserCreateWithoutCreditNotesProcessedInput, UserUncheckedCreateWithoutCreditNotesProcessedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditNotesProcessedInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutCreditNotesInput = {
    create?: XOR<CustomerCreateWithoutCreditNotesInput, CustomerUncheckedCreateWithoutCreditNotesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCreditNotesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CreditNoteItemCreateNestedManyWithoutCreditNoteInput = {
    create?: XOR<CreditNoteItemCreateWithoutCreditNoteInput, CreditNoteItemUncheckedCreateWithoutCreditNoteInput> | CreditNoteItemCreateWithoutCreditNoteInput[] | CreditNoteItemUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteItemCreateOrConnectWithoutCreditNoteInput | CreditNoteItemCreateOrConnectWithoutCreditNoteInput[]
    createMany?: CreditNoteItemCreateManyCreditNoteInputEnvelope
    connect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
  }

  export type POSSaleCreateNestedOneWithoutCreditNotesInput = {
    create?: XOR<POSSaleCreateWithoutCreditNotesInput, POSSaleUncheckedCreateWithoutCreditNotesInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutCreditNotesInput
    connect?: POSSaleWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCreditNotesInput = {
    create?: XOR<TenantCreateWithoutCreditNotesInput, TenantUncheckedCreateWithoutCreditNotesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCreditNotesInput
    connect?: TenantWhereUniqueInput
  }

  export type CreditNoteItemUncheckedCreateNestedManyWithoutCreditNoteInput = {
    create?: XOR<CreditNoteItemCreateWithoutCreditNoteInput, CreditNoteItemUncheckedCreateWithoutCreditNoteInput> | CreditNoteItemCreateWithoutCreditNoteInput[] | CreditNoteItemUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteItemCreateOrConnectWithoutCreditNoteInput | CreditNoteItemCreateOrConnectWithoutCreditNoteInput[]
    createMany?: CreditNoteItemCreateManyCreditNoteInputEnvelope
    connect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
  }

  export type EnumCreditNoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.CreditNoteStatus
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type UserUpdateOneRequiredWithoutCreditNotesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutCreditNotesCreatedInput, UserUncheckedCreateWithoutCreditNotesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditNotesCreatedInput
    upsert?: UserUpsertWithoutCreditNotesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreditNotesCreatedInput, UserUpdateWithoutCreditNotesCreatedInput>, UserUncheckedUpdateWithoutCreditNotesCreatedInput>
  }

  export type UserUpdateOneWithoutCreditNotesProcessedNestedInput = {
    create?: XOR<UserCreateWithoutCreditNotesProcessedInput, UserUncheckedCreateWithoutCreditNotesProcessedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditNotesProcessedInput
    upsert?: UserUpsertWithoutCreditNotesProcessedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreditNotesProcessedInput, UserUpdateWithoutCreditNotesProcessedInput>, UserUncheckedUpdateWithoutCreditNotesProcessedInput>
  }

  export type CustomerUpdateOneWithoutCreditNotesNestedInput = {
    create?: XOR<CustomerCreateWithoutCreditNotesInput, CustomerUncheckedCreateWithoutCreditNotesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCreditNotesInput
    upsert?: CustomerUpsertWithoutCreditNotesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCreditNotesInput, CustomerUpdateWithoutCreditNotesInput>, CustomerUncheckedUpdateWithoutCreditNotesInput>
  }

  export type CreditNoteItemUpdateManyWithoutCreditNoteNestedInput = {
    create?: XOR<CreditNoteItemCreateWithoutCreditNoteInput, CreditNoteItemUncheckedCreateWithoutCreditNoteInput> | CreditNoteItemCreateWithoutCreditNoteInput[] | CreditNoteItemUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteItemCreateOrConnectWithoutCreditNoteInput | CreditNoteItemCreateOrConnectWithoutCreditNoteInput[]
    upsert?: CreditNoteItemUpsertWithWhereUniqueWithoutCreditNoteInput | CreditNoteItemUpsertWithWhereUniqueWithoutCreditNoteInput[]
    createMany?: CreditNoteItemCreateManyCreditNoteInputEnvelope
    set?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    disconnect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    delete?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    connect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    update?: CreditNoteItemUpdateWithWhereUniqueWithoutCreditNoteInput | CreditNoteItemUpdateWithWhereUniqueWithoutCreditNoteInput[]
    updateMany?: CreditNoteItemUpdateManyWithWhereWithoutCreditNoteInput | CreditNoteItemUpdateManyWithWhereWithoutCreditNoteInput[]
    deleteMany?: CreditNoteItemScalarWhereInput | CreditNoteItemScalarWhereInput[]
  }

  export type POSSaleUpdateOneRequiredWithoutCreditNotesNestedInput = {
    create?: XOR<POSSaleCreateWithoutCreditNotesInput, POSSaleUncheckedCreateWithoutCreditNotesInput>
    connectOrCreate?: POSSaleCreateOrConnectWithoutCreditNotesInput
    upsert?: POSSaleUpsertWithoutCreditNotesInput
    connect?: POSSaleWhereUniqueInput
    update?: XOR<XOR<POSSaleUpdateToOneWithWhereWithoutCreditNotesInput, POSSaleUpdateWithoutCreditNotesInput>, POSSaleUncheckedUpdateWithoutCreditNotesInput>
  }

  export type TenantUpdateOneRequiredWithoutCreditNotesNestedInput = {
    create?: XOR<TenantCreateWithoutCreditNotesInput, TenantUncheckedCreateWithoutCreditNotesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCreditNotesInput
    upsert?: TenantUpsertWithoutCreditNotesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCreditNotesInput, TenantUpdateWithoutCreditNotesInput>, TenantUncheckedUpdateWithoutCreditNotesInput>
  }

  export type CreditNoteItemUncheckedUpdateManyWithoutCreditNoteNestedInput = {
    create?: XOR<CreditNoteItemCreateWithoutCreditNoteInput, CreditNoteItemUncheckedCreateWithoutCreditNoteInput> | CreditNoteItemCreateWithoutCreditNoteInput[] | CreditNoteItemUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteItemCreateOrConnectWithoutCreditNoteInput | CreditNoteItemCreateOrConnectWithoutCreditNoteInput[]
    upsert?: CreditNoteItemUpsertWithWhereUniqueWithoutCreditNoteInput | CreditNoteItemUpsertWithWhereUniqueWithoutCreditNoteInput[]
    createMany?: CreditNoteItemCreateManyCreditNoteInputEnvelope
    set?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    disconnect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    delete?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    connect?: CreditNoteItemWhereUniqueInput | CreditNoteItemWhereUniqueInput[]
    update?: CreditNoteItemUpdateWithWhereUniqueWithoutCreditNoteInput | CreditNoteItemUpdateWithWhereUniqueWithoutCreditNoteInput[]
    updateMany?: CreditNoteItemUpdateManyWithWhereWithoutCreditNoteInput | CreditNoteItemUpdateManyWithWhereWithoutCreditNoteInput[]
    deleteMany?: CreditNoteItemScalarWhereInput | CreditNoteItemScalarWhereInput[]
  }

  export type CreditNoteCreateNestedOneWithoutItemsInput = {
    create?: XOR<CreditNoteCreateWithoutItemsInput, CreditNoteUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CreditNoteCreateOrConnectWithoutItemsInput
    connect?: CreditNoteWhereUniqueInput
  }

  export type PartCreateNestedOneWithoutCreditNoteItemsInput = {
    create?: XOR<PartCreateWithoutCreditNoteItemsInput, PartUncheckedCreateWithoutCreditNoteItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutCreditNoteItemsInput
    connect?: PartWhereUniqueInput
  }

  export type CreditNoteUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CreditNoteCreateWithoutItemsInput, CreditNoteUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CreditNoteCreateOrConnectWithoutItemsInput
    upsert?: CreditNoteUpsertWithoutItemsInput
    connect?: CreditNoteWhereUniqueInput
    update?: XOR<XOR<CreditNoteUpdateToOneWithWhereWithoutItemsInput, CreditNoteUpdateWithoutItemsInput>, CreditNoteUncheckedUpdateWithoutItemsInput>
  }

  export type PartUpdateOneRequiredWithoutCreditNoteItemsNestedInput = {
    create?: XOR<PartCreateWithoutCreditNoteItemsInput, PartUncheckedCreateWithoutCreditNoteItemsInput>
    connectOrCreate?: PartCreateOrConnectWithoutCreditNoteItemsInput
    upsert?: PartUpsertWithoutCreditNoteItemsInput
    connect?: PartWhereUniqueInput
    update?: XOR<XOR<PartUpdateToOneWithWhereWithoutCreditNoteItemsInput, PartUpdateWithoutCreditNoteItemsInput>, PartUncheckedUpdateWithoutCreditNoteItemsInput>
  }

  export type TenantCreateNestedOneWithoutSessionLogsInput = {
    create?: XOR<TenantCreateWithoutSessionLogsInput, TenantUncheckedCreateWithoutSessionLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSessionLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSessionLogsInput = {
    create?: XOR<UserCreateWithoutSessionLogsInput, UserUncheckedCreateWithoutSessionLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type TenantUpdateOneRequiredWithoutSessionLogsNestedInput = {
    create?: XOR<TenantCreateWithoutSessionLogsInput, TenantUncheckedCreateWithoutSessionLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSessionLogsInput
    upsert?: TenantUpsertWithoutSessionLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSessionLogsInput, TenantUpdateWithoutSessionLogsInput>, TenantUncheckedUpdateWithoutSessionLogsInput>
  }

  export type UserUpdateOneRequiredWithoutSessionLogsNestedInput = {
    create?: XOR<UserCreateWithoutSessionLogsInput, UserUncheckedCreateWithoutSessionLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionLogsInput
    upsert?: UserUpsertWithoutSessionLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionLogsInput, UserUpdateWithoutSessionLogsInput>, UserUncheckedUpdateWithoutSessionLogsInput>
  }

  export type UserCreateNestedOneWithoutPresenceInput = {
    create?: XOR<UserCreateWithoutPresenceInput, UserUncheckedCreateWithoutPresenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutPresenceInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutUserPresencesInput = {
    create?: XOR<TenantCreateWithoutUserPresencesInput, TenantUncheckedCreateWithoutUserPresencesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserPresencesInput
    connect?: TenantWhereUniqueInput
  }

  export type TicketCreateNestedOneWithoutViewedByUsersInput = {
    create?: XOR<TicketCreateWithoutViewedByUsersInput, TicketUncheckedCreateWithoutViewedByUsersInput>
    connectOrCreate?: TicketCreateOrConnectWithoutViewedByUsersInput
    connect?: TicketWhereUniqueInput
  }

  export type EnumPresenceStatusFieldUpdateOperationsInput = {
    set?: $Enums.PresenceStatus
  }

  export type UserUpdateOneRequiredWithoutPresenceNestedInput = {
    create?: XOR<UserCreateWithoutPresenceInput, UserUncheckedCreateWithoutPresenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutPresenceInput
    upsert?: UserUpsertWithoutPresenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPresenceInput, UserUpdateWithoutPresenceInput>, UserUncheckedUpdateWithoutPresenceInput>
  }

  export type TenantUpdateOneRequiredWithoutUserPresencesNestedInput = {
    create?: XOR<TenantCreateWithoutUserPresencesInput, TenantUncheckedCreateWithoutUserPresencesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserPresencesInput
    upsert?: TenantUpsertWithoutUserPresencesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUserPresencesInput, TenantUpdateWithoutUserPresencesInput>, TenantUncheckedUpdateWithoutUserPresencesInput>
  }

  export type TicketUpdateOneWithoutViewedByUsersNestedInput = {
    create?: XOR<TicketCreateWithoutViewedByUsersInput, TicketUncheckedCreateWithoutViewedByUsersInput>
    connectOrCreate?: TicketCreateOrConnectWithoutViewedByUsersInput
    upsert?: TicketUpsertWithoutViewedByUsersInput
    disconnect?: TicketWhereInput | boolean
    delete?: TicketWhereInput | boolean
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutViewedByUsersInput, TicketUpdateWithoutViewedByUsersInput>, TicketUncheckedUpdateWithoutViewedByUsersInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTechnicianStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TechnicianStatus | EnumTechnicianStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TechnicianStatus[] | ListEnumTechnicianStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechnicianStatus[] | ListEnumTechnicianStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnicianStatusFilter<$PrismaModel> | $Enums.TechnicianStatus
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumTechnicianStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TechnicianStatus | EnumTechnicianStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TechnicianStatus[] | ListEnumTechnicianStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TechnicianStatus[] | ListEnumTechnicianStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTechnicianStatusWithAggregatesFilter<$PrismaModel> | $Enums.TechnicianStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTechnicianStatusFilter<$PrismaModel>
    _max?: NestedEnumTechnicianStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditModuleFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditModule | EnumAuditModuleFieldRefInput<$PrismaModel>
    in?: $Enums.AuditModule[] | ListEnumAuditModuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditModule[] | ListEnumAuditModuleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditModuleFilter<$PrismaModel> | $Enums.AuditModule
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumAuditModuleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditModule | EnumAuditModuleFieldRefInput<$PrismaModel>
    in?: $Enums.AuditModule[] | ListEnumAuditModuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditModule[] | ListEnumAuditModuleFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditModuleWithAggregatesFilter<$PrismaModel> | $Enums.AuditModule
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditModuleFilter<$PrismaModel>
    _max?: NestedEnumAuditModuleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumSpecializationFilter<$PrismaModel = never> = {
    equals?: $Enums.Specialization | EnumSpecializationFieldRefInput<$PrismaModel>
    in?: $Enums.Specialization[] | ListEnumSpecializationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Specialization[] | ListEnumSpecializationFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecializationFilter<$PrismaModel> | $Enums.Specialization
  }

  export type NestedEnumSpecializationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Specialization | EnumSpecializationFieldRefInput<$PrismaModel>
    in?: $Enums.Specialization[] | ListEnumSpecializationFieldRefInput<$PrismaModel>
    notIn?: $Enums.Specialization[] | ListEnumSpecializationFieldRefInput<$PrismaModel>
    not?: NestedEnumSpecializationWithAggregatesFilter<$PrismaModel> | $Enums.Specialization
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpecializationFilter<$PrismaModel>
    _max?: NestedEnumSpecializationFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPOSSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.POSSaleStatus | EnumPOSSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POSSaleStatus[] | ListEnumPOSSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POSSaleStatus[] | ListEnumPOSSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOSSaleStatusFilter<$PrismaModel> | $Enums.POSSaleStatus
  }

  export type NestedEnumPOSSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POSSaleStatus | EnumPOSSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POSSaleStatus[] | ListEnumPOSSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POSSaleStatus[] | ListEnumPOSSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOSSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.POSSaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOSSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumPOSSaleStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuotationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusFilter<$PrismaModel> | $Enums.QuotationStatus
  }

  export type NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationStatusFilter<$PrismaModel>
  }

  export type NestedEnumCreditNoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusFilter<$PrismaModel> | $Enums.CreditNoteStatus
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditNoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPresenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PresenceStatus | EnumPresenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPresenceStatusFilter<$PrismaModel> | $Enums.PresenceStatus
  }

  export type NestedEnumPresenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PresenceStatus | EnumPresenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPresenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.PresenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPresenceStatusFilter<$PrismaModel>
    _max?: NestedEnumPresenceStatusFilter<$PrismaModel>
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    details?: string | null
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    details?: string | null
    userId?: string | null
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SessionLogCreateWithoutTenantInput = {
    id?: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutSessionLogsInput
  }

  export type SessionLogUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionLogCreateOrConnectWithoutTenantInput = {
    where: SessionLogWhereUniqueInput
    create: XOR<SessionLogCreateWithoutTenantInput, SessionLogUncheckedCreateWithoutTenantInput>
  }

  export type SessionLogCreateManyTenantInputEnvelope = {
    data: SessionLogCreateManyTenantInput | SessionLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserPresenceCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPresenceInput
    currentTicket?: TicketCreateNestedOneWithoutViewedByUsersInput
  }

  export type UserPresenceUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    currentTicketId?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceCreateOrConnectWithoutTenantInput = {
    where: UserPresenceWhereUniqueInput
    create: XOR<UserPresenceCreateWithoutTenantInput, UserPresenceUncheckedCreateWithoutTenantInput>
  }

  export type UserPresenceCreateManyTenantInputEnvelope = {
    data: UserPresenceCreateManyTenantInput | UserPresenceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CashRegisterCreateWithoutTenantInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedBy?: UserCreateNestedOneWithoutClosedCashRegistersInput
    openedBy?: UserCreateNestedOneWithoutOpenedCashRegistersInput
    posSales?: POSSaleCreateNestedManyWithoutCashRegisterInput
    transactions?: CashTransactionCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    openedById?: string | null
    closedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCashRegisterInput
    transactions?: CashTransactionUncheckedCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutTenantInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput>
  }

  export type CashRegisterCreateManyTenantInputEnvelope = {
    data: CashRegisterCreateManyTenantInput | CashRegisterCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CashTransactionCreateWithoutTenantInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    createdAt?: Date | string
    cashRegister: CashRegisterCreateNestedOneWithoutTransactionsInput
    createdBy: UserCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateWithoutTenantInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    cashRegisterId: string
    createdById: string
    createdAt?: Date | string
  }

  export type CashTransactionCreateOrConnectWithoutTenantInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutTenantInput, CashTransactionUncheckedCreateWithoutTenantInput>
  }

  export type CashTransactionCreateManyTenantInputEnvelope = {
    data: CashTransactionCreateManyTenantInput | CashTransactionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CreditNoteCreateWithoutTenantInput = {
    id?: string
    creditNoteNumber: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreditNotesCreatedInput
    processedBy?: UserCreateNestedOneWithoutCreditNotesProcessedInput
    customer?: CustomerCreateNestedOneWithoutCreditNotesInput
    items?: CreditNoteItemCreateNestedManyWithoutCreditNoteInput
    posSale: POSSaleCreateNestedOneWithoutCreditNotesInput
  }

  export type CreditNoteUncheckedCreateWithoutTenantInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CreditNoteItemUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type CreditNoteCreateOrConnectWithoutTenantInput = {
    where: CreditNoteWhereUniqueInput
    create: XOR<CreditNoteCreateWithoutTenantInput, CreditNoteUncheckedCreateWithoutTenantInput>
  }

  export type CreditNoteCreateManyTenantInputEnvelope = {
    data: CreditNoteCreateManyTenantInput | CreditNoteCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedCustomersInput
    creditNotes?: CreditNoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCustomerInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedCustomersInput
  }

  export type CustomerUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCustomerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerCreateManyTenantInputEnvelope = {
    data: CustomerCreateManyTenantInput | CustomerCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    history?: InvoiceHistoryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    ticket: TicketCreateNestedOneWithoutInvoiceInput
    updatedBy: UserCreateNestedOneWithoutUpdatedInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: InvoiceHistoryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTenantInput = {
    id?: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationCreateManyTenantInputEnvelope = {
    data: NotificationCreateManyTenantInput | NotificationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PartCreateWithoutTenantInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutTenantInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutTenantInput, PartUncheckedCreateWithoutTenantInput>
  }

  export type PartCreateManyTenantInputEnvelope = {
    data: PartCreateManyTenantInput | PartCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutTenantInput = {
    id?: string
    paymentNumber: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    receivedBy: UserCreateNestedOneWithoutReceivedPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    receivedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentCreateManyTenantInputEnvelope = {
    data: PaymentCreateManyTenantInput | PaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type POSSaleCreateWithoutTenantInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashRegister?: CashRegisterCreateNestedOneWithoutPosSalesInput
    createdBy: UserCreateNestedOneWithoutPosSalesInput
    creditNotes?: CreditNoteCreateNestedManyWithoutPosSaleInput
    customer?: CustomerCreateNestedOneWithoutPosSalesInput
    items?: POSSaleItemCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentCreateNestedManyWithoutSaleInput
    quotation?: POSQuotationCreateNestedOneWithoutConvertedToSaleInput
  }

  export type POSSaleUncheckedCreateWithoutTenantInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput
    items?: POSSaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleCreateOrConnectWithoutTenantInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutTenantInput, POSSaleUncheckedCreateWithoutTenantInput>
  }

  export type POSSaleCreateManyTenantInputEnvelope = {
    data: POSSaleCreateManyTenantInput | POSSaleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type POSQuotationCreateWithoutTenantInput = {
    id?: string
    quotationNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPosQuotationsInput
    customer?: CustomerCreateNestedOneWithoutPosQuotationsInput
    items?: POSQuotationItemCreateNestedManyWithoutQuotationInput
    convertedToSale?: POSSaleCreateNestedOneWithoutQuotationInput
  }

  export type POSQuotationUncheckedCreateWithoutTenantInput = {
    id?: string
    quotationNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: POSQuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    convertedToSale?: POSSaleUncheckedCreateNestedOneWithoutQuotationInput
  }

  export type POSQuotationCreateOrConnectWithoutTenantInput = {
    where: POSQuotationWhereUniqueInput
    create: XOR<POSQuotationCreateWithoutTenantInput, POSQuotationUncheckedCreateWithoutTenantInput>
  }

  export type POSQuotationCreateManyTenantInputEnvelope = {
    data: POSQuotationCreateManyTenantInput | POSQuotationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutTenantInput = {
    id?: string
    supplier: string
    status?: $Enums.PurchaseStatus
    orderDate?: Date | string
    receivedDate?: Date | string | null
    totalCost?: Decimal | DecimalJsLike | number | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutTenantInput = {
    id?: string
    supplier: string
    status?: $Enums.PurchaseStatus
    orderDate?: Date | string
    receivedDate?: Date | string | null
    totalCost?: Decimal | DecimalJsLike | number | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput>
  }

  export type PurchaseOrderCreateManyTenantInputEnvelope = {
    data: PurchaseOrderCreateManyTenantInput | PurchaseOrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ServiceTemplateCreateWithoutTenantInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedTemplatesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTemplatesInput
    defaultParts?: TemplateDefaultPartCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceCreateNestedManyWithoutServiceInput
    tickets?: TicketCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceUncheckedCreateNestedManyWithoutServiceInput
    tickets?: TicketUncheckedCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateCreateOrConnectWithoutTenantInput = {
    where: ServiceTemplateWhereUniqueInput
    create: XOR<ServiceTemplateCreateWithoutTenantInput, ServiceTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ServiceTemplateCreateManyTenantInputEnvelope = {
    data: ServiceTemplateCreateManyTenantInput | ServiceTemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantSettingsCreateWithoutTenantInput = {
    id?: string
    businessName?: string | null
    businessNIT?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    businessEmail?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxName?: string
    currency?: string
    defaultPaymentTerms?: string | null
    invoiceFooter?: string | null
    slaWarningPercent?: number
    slaCriticalPercent?: number
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsUncheckedCreateWithoutTenantInput = {
    id?: string
    businessName?: string | null
    businessNIT?: string | null
    businessAddress?: string | null
    businessPhone?: string | null
    businessEmail?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxName?: string
    currency?: string
    defaultPaymentTerms?: string | null
    invoiceFooter?: string | null
    slaWarningPercent?: number
    slaCriticalPercent?: number
    slaEmailEnabled?: boolean
    slaInAppEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantSettingsCreateOrConnectWithoutTenantInput = {
    where: TenantSettingsWhereUniqueInput
    create: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
  }

  export type TicketCreateWithoutTenantInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutTenantInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutTenantInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput>
  }

  export type TicketCreateManyTenantInputEnvelope = {
    data: TicketCreateManyTenantInput | TicketCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    details?: StringNullableFilter<"AuditLog"> | string | null
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    tenantId?: UuidFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    module?: EnumAuditModuleFilter<"AuditLog"> | $Enums.AuditModule
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    success?: BoolFilter<"AuditLog"> | boolean
  }

  export type SessionLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: SessionLogWhereUniqueInput
    update: XOR<SessionLogUpdateWithoutTenantInput, SessionLogUncheckedUpdateWithoutTenantInput>
    create: XOR<SessionLogCreateWithoutTenantInput, SessionLogUncheckedCreateWithoutTenantInput>
  }

  export type SessionLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: SessionLogWhereUniqueInput
    data: XOR<SessionLogUpdateWithoutTenantInput, SessionLogUncheckedUpdateWithoutTenantInput>
  }

  export type SessionLogUpdateManyWithWhereWithoutTenantInput = {
    where: SessionLogScalarWhereInput
    data: XOR<SessionLogUpdateManyMutationInput, SessionLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type SessionLogScalarWhereInput = {
    AND?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
    OR?: SessionLogScalarWhereInput[]
    NOT?: SessionLogScalarWhereInput | SessionLogScalarWhereInput[]
    id?: UuidFilter<"SessionLog"> | string
    tenantId?: UuidFilter<"SessionLog"> | string
    userId?: UuidFilter<"SessionLog"> | string
    sessionToken?: StringFilter<"SessionLog"> | string
    ipAddress?: StringNullableFilter<"SessionLog"> | string | null
    userAgent?: StringNullableFilter<"SessionLog"> | string | null
    loginAt?: DateTimeFilter<"SessionLog"> | Date | string
    lastActivityAt?: DateTimeFilter<"SessionLog"> | Date | string
    logoutAt?: DateTimeNullableFilter<"SessionLog"> | Date | string | null
    status?: EnumSessionStatusFilter<"SessionLog"> | $Enums.SessionStatus
    metadata?: JsonNullableFilter<"SessionLog">
  }

  export type UserPresenceUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserPresenceWhereUniqueInput
    update: XOR<UserPresenceUpdateWithoutTenantInput, UserPresenceUncheckedUpdateWithoutTenantInput>
    create: XOR<UserPresenceCreateWithoutTenantInput, UserPresenceUncheckedCreateWithoutTenantInput>
  }

  export type UserPresenceUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserPresenceWhereUniqueInput
    data: XOR<UserPresenceUpdateWithoutTenantInput, UserPresenceUncheckedUpdateWithoutTenantInput>
  }

  export type UserPresenceUpdateManyWithWhereWithoutTenantInput = {
    where: UserPresenceScalarWhereInput
    data: XOR<UserPresenceUpdateManyMutationInput, UserPresenceUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserPresenceScalarWhereInput = {
    AND?: UserPresenceScalarWhereInput | UserPresenceScalarWhereInput[]
    OR?: UserPresenceScalarWhereInput[]
    NOT?: UserPresenceScalarWhereInput | UserPresenceScalarWhereInput[]
    id?: UuidFilter<"UserPresence"> | string
    userId?: UuidFilter<"UserPresence"> | string
    tenantId?: UuidFilter<"UserPresence"> | string
    status?: EnumPresenceStatusFilter<"UserPresence"> | $Enums.PresenceStatus
    currentRoute?: StringNullableFilter<"UserPresence"> | string | null
    currentPage?: StringNullableFilter<"UserPresence"> | string | null
    currentTicketId?: UuidNullableFilter<"UserPresence"> | string | null
    lastSeenAt?: DateTimeFilter<"UserPresence"> | Date | string
    metadata?: JsonNullableFilter<"UserPresence">
  }

  export type CashRegisterUpsertWithWhereUniqueWithoutTenantInput = {
    where: CashRegisterWhereUniqueInput
    update: XOR<CashRegisterUpdateWithoutTenantInput, CashRegisterUncheckedUpdateWithoutTenantInput>
    create: XOR<CashRegisterCreateWithoutTenantInput, CashRegisterUncheckedCreateWithoutTenantInput>
  }

  export type CashRegisterUpdateWithWhereUniqueWithoutTenantInput = {
    where: CashRegisterWhereUniqueInput
    data: XOR<CashRegisterUpdateWithoutTenantInput, CashRegisterUncheckedUpdateWithoutTenantInput>
  }

  export type CashRegisterUpdateManyWithWhereWithoutTenantInput = {
    where: CashRegisterScalarWhereInput
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyWithoutTenantInput>
  }

  export type CashRegisterScalarWhereInput = {
    AND?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
    OR?: CashRegisterScalarWhereInput[]
    NOT?: CashRegisterScalarWhereInput | CashRegisterScalarWhereInput[]
    id?: UuidFilter<"CashRegister"> | string
    name?: StringFilter<"CashRegister"> | string
    isOpen?: BoolFilter<"CashRegister"> | boolean
    openedAt?: DateTimeNullableFilter<"CashRegister"> | Date | string | null
    closedAt?: DateTimeNullableFilter<"CashRegister"> | Date | string | null
    openingBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    difference?: DecimalFilter<"CashRegister"> | Decimal | DecimalJsLike | number | string
    closingNotes?: StringNullableFilter<"CashRegister"> | string | null
    tenantId?: UuidFilter<"CashRegister"> | string
    openedById?: UuidNullableFilter<"CashRegister"> | string | null
    closedById?: UuidNullableFilter<"CashRegister"> | string | null
    createdAt?: DateTimeFilter<"CashRegister"> | Date | string
    updatedAt?: DateTimeFilter<"CashRegister"> | Date | string
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutTenantInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutTenantInput, CashTransactionUncheckedUpdateWithoutTenantInput>
    create: XOR<CashTransactionCreateWithoutTenantInput, CashTransactionUncheckedCreateWithoutTenantInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutTenantInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutTenantInput, CashTransactionUncheckedUpdateWithoutTenantInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutTenantInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutTenantInput>
  }

  export type CashTransactionScalarWhereInput = {
    AND?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
    OR?: CashTransactionScalarWhereInput[]
    NOT?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
    id?: UuidFilter<"CashTransaction"> | string
    type?: StringFilter<"CashTransaction"> | string
    amount?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"CashTransaction"> | string
    reference?: StringNullableFilter<"CashTransaction"> | string | null
    cashRegisterId?: UuidFilter<"CashTransaction"> | string
    tenantId?: UuidFilter<"CashTransaction"> | string
    createdById?: UuidFilter<"CashTransaction"> | string
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
  }

  export type CreditNoteUpsertWithWhereUniqueWithoutTenantInput = {
    where: CreditNoteWhereUniqueInput
    update: XOR<CreditNoteUpdateWithoutTenantInput, CreditNoteUncheckedUpdateWithoutTenantInput>
    create: XOR<CreditNoteCreateWithoutTenantInput, CreditNoteUncheckedCreateWithoutTenantInput>
  }

  export type CreditNoteUpdateWithWhereUniqueWithoutTenantInput = {
    where: CreditNoteWhereUniqueInput
    data: XOR<CreditNoteUpdateWithoutTenantInput, CreditNoteUncheckedUpdateWithoutTenantInput>
  }

  export type CreditNoteUpdateManyWithWhereWithoutTenantInput = {
    where: CreditNoteScalarWhereInput
    data: XOR<CreditNoteUpdateManyMutationInput, CreditNoteUncheckedUpdateManyWithoutTenantInput>
  }

  export type CreditNoteScalarWhereInput = {
    AND?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
    OR?: CreditNoteScalarWhereInput[]
    NOT?: CreditNoteScalarWhereInput | CreditNoteScalarWhereInput[]
    id?: UuidFilter<"CreditNote"> | string
    creditNoteNumber?: StringFilter<"CreditNote"> | string
    posSaleId?: UuidFilter<"CreditNote"> | string
    customerId?: UuidNullableFilter<"CreditNote"> | string | null
    reason?: StringFilter<"CreditNote"> | string
    subtotal?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"CreditNote"> | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFilter<"CreditNote"> | $Enums.CreditNoteStatus
    refundMethod?: EnumPaymentMethodNullableFilter<"CreditNote"> | $Enums.PaymentMethod | null
    refundReference?: StringNullableFilter<"CreditNote"> | string | null
    notes?: StringNullableFilter<"CreditNote"> | string | null
    processedAt?: DateTimeNullableFilter<"CreditNote"> | Date | string | null
    processedById?: UuidNullableFilter<"CreditNote"> | string | null
    tenantId?: UuidFilter<"CreditNote"> | string
    createdById?: UuidFilter<"CreditNote"> | string
    createdAt?: DateTimeFilter<"CreditNote"> | Date | string
    updatedAt?: DateTimeFilter<"CreditNote"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
  }

  export type CustomerUpdateManyWithWhereWithoutTenantInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutTenantInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: UuidFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    tenantId?: UuidFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    createdById?: UuidNullableFilter<"Customer"> | string | null
    updatedById?: UuidNullableFilter<"Customer"> | string | null
    dpi?: StringNullableFilter<"Customer"> | string | null
    nit?: StringNullableFilter<"Customer"> | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    ticketId?: UuidFilter<"Invoice"> | string
    customerId?: UuidFilter<"Invoice"> | string
    laborCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    customerName?: StringFilter<"Invoice"> | string
    customerNIT?: StringNullableFilter<"Invoice"> | string | null
    customerDPI?: StringNullableFilter<"Invoice"> | string | null
    customerAddress?: StringNullableFilter<"Invoice"> | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    dueAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    tenantId?: UuidFilter<"Invoice"> | string
    createdById?: UuidFilter<"Invoice"> | string
    updatedById?: UuidFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    tenantId?: UuidFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PartUpsertWithWhereUniqueWithoutTenantInput = {
    where: PartWhereUniqueInput
    update: XOR<PartUpdateWithoutTenantInput, PartUncheckedUpdateWithoutTenantInput>
    create: XOR<PartCreateWithoutTenantInput, PartUncheckedCreateWithoutTenantInput>
  }

  export type PartUpdateWithWhereUniqueWithoutTenantInput = {
    where: PartWhereUniqueInput
    data: XOR<PartUpdateWithoutTenantInput, PartUncheckedUpdateWithoutTenantInput>
  }

  export type PartUpdateManyWithWhereWithoutTenantInput = {
    where: PartScalarWhereInput
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyWithoutTenantInput>
  }

  export type PartScalarWhereInput = {
    AND?: PartScalarWhereInput | PartScalarWhereInput[]
    OR?: PartScalarWhereInput[]
    NOT?: PartScalarWhereInput | PartScalarWhereInput[]
    id?: UuidFilter<"Part"> | string
    name?: StringFilter<"Part"> | string
    sku?: StringNullableFilter<"Part"> | string | null
    quantity?: IntFilter<"Part"> | number
    cost?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Part"> | Decimal | DecimalJsLike | number | string
    tenantId?: UuidFilter<"Part"> | string
    createdAt?: DateTimeFilter<"Part"> | Date | string
    updatedAt?: DateTimeFilter<"Part"> | Date | string
    createdById?: UuidNullableFilter<"Part"> | string | null
    updatedById?: UuidNullableFilter<"Part"> | string | null
    category?: StringNullableFilter<"Part"> | string | null
    location?: StringNullableFilter<"Part"> | string | null
    minStock?: IntFilter<"Part"> | number
  }

  export type PaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    paymentNumber?: StringFilter<"Payment"> | string
    invoiceId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    tenantId?: UuidFilter<"Payment"> | string
    receivedById?: UuidFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type POSSaleUpsertWithWhereUniqueWithoutTenantInput = {
    where: POSSaleWhereUniqueInput
    update: XOR<POSSaleUpdateWithoutTenantInput, POSSaleUncheckedUpdateWithoutTenantInput>
    create: XOR<POSSaleCreateWithoutTenantInput, POSSaleUncheckedCreateWithoutTenantInput>
  }

  export type POSSaleUpdateWithWhereUniqueWithoutTenantInput = {
    where: POSSaleWhereUniqueInput
    data: XOR<POSSaleUpdateWithoutTenantInput, POSSaleUncheckedUpdateWithoutTenantInput>
  }

  export type POSSaleUpdateManyWithWhereWithoutTenantInput = {
    where: POSSaleScalarWhereInput
    data: XOR<POSSaleUpdateManyMutationInput, POSSaleUncheckedUpdateManyWithoutTenantInput>
  }

  export type POSSaleScalarWhereInput = {
    AND?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
    OR?: POSSaleScalarWhereInput[]
    NOT?: POSSaleScalarWhereInput | POSSaleScalarWhereInput[]
    id?: UuidFilter<"POSSale"> | string
    saleNumber?: StringFilter<"POSSale"> | string
    customerId?: UuidNullableFilter<"POSSale"> | string | null
    customerName?: StringFilter<"POSSale"> | string
    customerPhone?: StringNullableFilter<"POSSale"> | string | null
    customerEmail?: StringNullableFilter<"POSSale"> | string | null
    subtotal?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFilter<"POSSale"> | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFilter<"POSSale"> | $Enums.POSSaleStatus
    notes?: StringNullableFilter<"POSSale"> | string | null
    tenantId?: UuidFilter<"POSSale"> | string
    cashRegisterId?: UuidNullableFilter<"POSSale"> | string | null
    createdById?: UuidFilter<"POSSale"> | string
    quotationId?: UuidNullableFilter<"POSSale"> | string | null
    createdAt?: DateTimeFilter<"POSSale"> | Date | string
    updatedAt?: DateTimeFilter<"POSSale"> | Date | string
  }

  export type POSQuotationUpsertWithWhereUniqueWithoutTenantInput = {
    where: POSQuotationWhereUniqueInput
    update: XOR<POSQuotationUpdateWithoutTenantInput, POSQuotationUncheckedUpdateWithoutTenantInput>
    create: XOR<POSQuotationCreateWithoutTenantInput, POSQuotationUncheckedCreateWithoutTenantInput>
  }

  export type POSQuotationUpdateWithWhereUniqueWithoutTenantInput = {
    where: POSQuotationWhereUniqueInput
    data: XOR<POSQuotationUpdateWithoutTenantInput, POSQuotationUncheckedUpdateWithoutTenantInput>
  }

  export type POSQuotationUpdateManyWithWhereWithoutTenantInput = {
    where: POSQuotationScalarWhereInput
    data: XOR<POSQuotationUpdateManyMutationInput, POSQuotationUncheckedUpdateManyWithoutTenantInput>
  }

  export type POSQuotationScalarWhereInput = {
    AND?: POSQuotationScalarWhereInput | POSQuotationScalarWhereInput[]
    OR?: POSQuotationScalarWhereInput[]
    NOT?: POSQuotationScalarWhereInput | POSQuotationScalarWhereInput[]
    id?: UuidFilter<"POSQuotation"> | string
    quotationNumber?: StringFilter<"POSQuotation"> | string
    customerId?: UuidNullableFilter<"POSQuotation"> | string | null
    customerName?: StringFilter<"POSQuotation"> | string
    customerPhone?: StringNullableFilter<"POSQuotation"> | string | null
    customerEmail?: StringNullableFilter<"POSQuotation"> | string | null
    subtotal?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"POSQuotation"> | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFilter<"POSQuotation"> | $Enums.QuotationStatus
    validUntil?: DateTimeNullableFilter<"POSQuotation"> | Date | string | null
    notes?: StringNullableFilter<"POSQuotation"> | string | null
    tenantId?: UuidFilter<"POSQuotation"> | string
    createdById?: UuidFilter<"POSQuotation"> | string
    createdAt?: DateTimeFilter<"POSQuotation"> | Date | string
    updatedAt?: DateTimeFilter<"POSQuotation"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutTenantInput, PurchaseOrderUncheckedUpdateWithoutTenantInput>
    create: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutTenantInput, PurchaseOrderUncheckedUpdateWithoutTenantInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutTenantInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: UuidFilter<"PurchaseOrder"> | string
    supplier?: StringFilter<"PurchaseOrder"> | string
    status?: EnumPurchaseStatusFilter<"PurchaseOrder"> | $Enums.PurchaseStatus
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    receivedDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    totalCost?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    tenantId?: UuidFilter<"PurchaseOrder"> | string
    createdById?: UuidNullableFilter<"PurchaseOrder"> | string | null
    updatedById?: UuidNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type ServiceTemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: ServiceTemplateWhereUniqueInput
    update: XOR<ServiceTemplateUpdateWithoutTenantInput, ServiceTemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<ServiceTemplateCreateWithoutTenantInput, ServiceTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ServiceTemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: ServiceTemplateWhereUniqueInput
    data: XOR<ServiceTemplateUpdateWithoutTenantInput, ServiceTemplateUncheckedUpdateWithoutTenantInput>
  }

  export type ServiceTemplateUpdateManyWithWhereWithoutTenantInput = {
    where: ServiceTemplateScalarWhereInput
    data: XOR<ServiceTemplateUpdateManyMutationInput, ServiceTemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type ServiceTemplateScalarWhereInput = {
    AND?: ServiceTemplateScalarWhereInput | ServiceTemplateScalarWhereInput[]
    OR?: ServiceTemplateScalarWhereInput[]
    NOT?: ServiceTemplateScalarWhereInput | ServiceTemplateScalarWhereInput[]
    id?: UuidFilter<"ServiceTemplate"> | string
    name?: StringFilter<"ServiceTemplate"> | string
    category?: EnumServiceCategoryFilter<"ServiceTemplate"> | $Enums.ServiceCategory
    defaultTitle?: StringFilter<"ServiceTemplate"> | string
    defaultDescription?: StringFilter<"ServiceTemplate"> | string
    defaultPriority?: StringFilter<"ServiceTemplate"> | string
    estimatedDuration?: IntNullableFilter<"ServiceTemplate"> | number | null
    laborCost?: DecimalNullableFilter<"ServiceTemplate"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ServiceTemplate"> | boolean
    color?: StringNullableFilter<"ServiceTemplate"> | string | null
    icon?: StringNullableFilter<"ServiceTemplate"> | string | null
    tenantId?: UuidFilter<"ServiceTemplate"> | string
    createdById?: UuidNullableFilter<"ServiceTemplate"> | string | null
    updatedById?: UuidNullableFilter<"ServiceTemplate"> | string | null
    createdAt?: DateTimeFilter<"ServiceTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTemplate"> | Date | string
  }

  export type TenantSettingsUpsertWithoutTenantInput = {
    update: XOR<TenantSettingsUpdateWithoutTenantInput, TenantSettingsUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantSettingsCreateWithoutTenantInput, TenantSettingsUncheckedCreateWithoutTenantInput>
    where?: TenantSettingsWhereInput
  }

  export type TenantSettingsUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantSettingsWhereInput
    data: XOR<TenantSettingsUpdateWithoutTenantInput, TenantSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type TenantSettingsUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessNIT?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    defaultPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    slaWarningPercent?: IntFieldUpdateOperationsInput | number
    slaCriticalPercent?: IntFieldUpdateOperationsInput | number
    slaEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    slaInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantSettingsUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessNIT?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    defaultPaymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceFooter?: NullableStringFieldUpdateOperationsInput | string | null
    slaWarningPercent?: IntFieldUpdateOperationsInput | number
    slaCriticalPercent?: IntFieldUpdateOperationsInput | number
    slaEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    slaInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutTenantInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutTenantInput, TicketUncheckedUpdateWithoutTenantInput>
    create: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutTenantInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutTenantInput, TicketUncheckedUpdateWithoutTenantInput>
  }

  export type TicketUpdateManyWithWhereWithoutTenantInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutTenantInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: UuidFilter<"Ticket"> | string
    ticketNumber?: StringNullableFilter<"Ticket"> | string | null
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    tenantId?: UuidFilter<"Ticket"> | string
    customerId?: UuidFilter<"Ticket"> | string
    assignedToId?: UuidNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    accessories?: StringNullableFilter<"Ticket"> | string | null
    cancellationReason?: StringNullableFilter<"Ticket"> | string | null
    checkInNotes?: StringNullableFilter<"Ticket"> | string | null
    deviceModel?: StringNullableFilter<"Ticket"> | string | null
    deviceType?: StringNullableFilter<"Ticket"> | string | null
    serialNumber?: StringNullableFilter<"Ticket"> | string | null
    createdById?: UuidNullableFilter<"Ticket"> | string | null
    serviceTemplateId?: UuidNullableFilter<"Ticket"> | string | null
    updatedById?: UuidNullableFilter<"Ticket"> | string | null
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    dueDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    estimatedCompletionDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    tenantId?: UuidFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    passwordMustChange?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    failedLoginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdById?: UuidNullableFilter<"User"> | string | null
    updatedById?: UuidNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    status?: EnumTechnicianStatusFilter<"User"> | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFilter<"User"> | number
    statusReason?: StringNullableFilter<"User"> | string | null
    availableFrom?: DateTimeNullableFilter<"User"> | Date | string | null
    availableUntil?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type UserCreateWithoutUsersCreatedInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUsersCreatedInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUsersCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsersCreatedInput, UserUncheckedCreateWithoutUsersCreatedInput>
  }

  export type UserCreateWithoutUsersUpdatedInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUsersUpdatedInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUsersUpdatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsersUpdatedInput, UserUncheckedCreateWithoutUsersUpdatedInput>
  }

  export type UserCreateWithoutCreatedByInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreatedByInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserCreateManyCreatedByInputEnvelope = {
    data: UserCreateManyCreatedByInput | UserCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutUpdatedByInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput>
  }

  export type UserCreateManyUpdatedByInputEnvelope = {
    data: UserCreateManyUpdatedByInput | UserCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    details?: string | null
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    details?: string | null
    tenantId: string
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionLogCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tenant: TenantCreateNestedOneWithoutSessionLogsInput
  }

  export type SessionLogUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionLogCreateOrConnectWithoutUserInput = {
    where: SessionLogWhereUniqueInput
    create: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput>
  }

  export type SessionLogCreateManyUserInputEnvelope = {
    data: SessionLogCreateManyUserInput | SessionLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPresenceCreateWithoutUserInput = {
    id?: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tenant: TenantCreateNestedOneWithoutUserPresencesInput
    currentTicket?: TicketCreateNestedOneWithoutViewedByUsersInput
  }

  export type UserPresenceUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    currentTicketId?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceCreateOrConnectWithoutUserInput = {
    where: UserPresenceWhereUniqueInput
    create: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
  }

  export type CashRegisterCreateWithoutClosedByInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    openedBy?: UserCreateNestedOneWithoutOpenedCashRegistersInput
    posSales?: POSSaleCreateNestedManyWithoutCashRegisterInput
    tenant: TenantCreateNestedOneWithoutCashRegistersInput
    transactions?: CashTransactionCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutClosedByInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    tenantId: string
    openedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCashRegisterInput
    transactions?: CashTransactionUncheckedCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutClosedByInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutClosedByInput, CashRegisterUncheckedCreateWithoutClosedByInput>
  }

  export type CashRegisterCreateManyClosedByInputEnvelope = {
    data: CashRegisterCreateManyClosedByInput | CashRegisterCreateManyClosedByInput[]
    skipDuplicates?: boolean
  }

  export type CashRegisterCreateWithoutOpenedByInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedBy?: UserCreateNestedOneWithoutClosedCashRegistersInput
    posSales?: POSSaleCreateNestedManyWithoutCashRegisterInput
    tenant: TenantCreateNestedOneWithoutCashRegistersInput
    transactions?: CashTransactionCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutOpenedByInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    tenantId: string
    closedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCashRegisterInput
    transactions?: CashTransactionUncheckedCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutOpenedByInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutOpenedByInput, CashRegisterUncheckedCreateWithoutOpenedByInput>
  }

  export type CashRegisterCreateManyOpenedByInputEnvelope = {
    data: CashRegisterCreateManyOpenedByInput | CashRegisterCreateManyOpenedByInput[]
    skipDuplicates?: boolean
  }

  export type CashTransactionCreateWithoutCreatedByInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    createdAt?: Date | string
    cashRegister: CashRegisterCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    cashRegisterId: string
    tenantId: string
    createdAt?: Date | string
  }

  export type CashTransactionCreateOrConnectWithoutCreatedByInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutCreatedByInput, CashTransactionUncheckedCreateWithoutCreatedByInput>
  }

  export type CashTransactionCreateManyCreatedByInputEnvelope = {
    data: CashTransactionCreateManyCreatedByInput | CashTransactionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CreditNoteCreateWithoutCreatedByInput = {
    id?: string
    creditNoteNumber: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processedBy?: UserCreateNestedOneWithoutCreditNotesProcessedInput
    customer?: CustomerCreateNestedOneWithoutCreditNotesInput
    items?: CreditNoteItemCreateNestedManyWithoutCreditNoteInput
    posSale: POSSaleCreateNestedOneWithoutCreditNotesInput
    tenant: TenantCreateNestedOneWithoutCreditNotesInput
  }

  export type CreditNoteUncheckedCreateWithoutCreatedByInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CreditNoteItemUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type CreditNoteCreateOrConnectWithoutCreatedByInput = {
    where: CreditNoteWhereUniqueInput
    create: XOR<CreditNoteCreateWithoutCreatedByInput, CreditNoteUncheckedCreateWithoutCreatedByInput>
  }

  export type CreditNoteCreateManyCreatedByInputEnvelope = {
    data: CreditNoteCreateManyCreatedByInput | CreditNoteCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CreditNoteCreateWithoutProcessedByInput = {
    id?: string
    creditNoteNumber: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreditNotesCreatedInput
    customer?: CustomerCreateNestedOneWithoutCreditNotesInput
    items?: CreditNoteItemCreateNestedManyWithoutCreditNoteInput
    posSale: POSSaleCreateNestedOneWithoutCreditNotesInput
    tenant: TenantCreateNestedOneWithoutCreditNotesInput
  }

  export type CreditNoteUncheckedCreateWithoutProcessedByInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CreditNoteItemUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type CreditNoteCreateOrConnectWithoutProcessedByInput = {
    where: CreditNoteWhereUniqueInput
    create: XOR<CreditNoteCreateWithoutProcessedByInput, CreditNoteUncheckedCreateWithoutProcessedByInput>
  }

  export type CreditNoteCreateManyProcessedByInputEnvelope = {
    data: CreditNoteCreateManyProcessedByInput | CreditNoteCreateManyProcessedByInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCustomerInput
    tenant: TenantCreateNestedOneWithoutCustomersInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedCustomersInput
  }

  export type CustomerUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCustomerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCreatedByInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput>
  }

  export type CustomerCreateManyCreatedByInputEnvelope = {
    data: CustomerCreateManyCreatedByInput | CustomerCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedCustomersInput
    creditNotes?: CreditNoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCustomerInput
    tenant: TenantCreateNestedOneWithoutCustomersInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCustomerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutUpdatedByInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUpdatedByInput, CustomerUncheckedCreateWithoutUpdatedByInput>
  }

  export type CustomerCreateManyUpdatedByInputEnvelope = {
    data: CustomerCreateManyUpdatedByInput | CustomerCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCreatedByInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    history?: InvoiceHistoryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    ticket: TicketCreateNestedOneWithoutInvoiceInput
    updatedBy: UserCreateNestedOneWithoutUpdatedInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: InvoiceHistoryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceCreateManyCreatedByInputEnvelope = {
    data: InvoiceCreateManyCreatedByInput | InvoiceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUpdatedByInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    history?: InvoiceHistoryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    ticket: TicketCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: InvoiceHistoryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutUpdatedByInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUpdatedByInput, InvoiceUncheckedCreateWithoutUpdatedByInput>
  }

  export type InvoiceCreateManyUpdatedByInputEnvelope = {
    data: InvoiceCreateManyUpdatedByInput | InvoiceCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceHistoryCreateWithoutUserInput = {
    id?: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutHistoryInput
  }

  export type InvoiceHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    invoiceId: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InvoiceHistoryCreateOrConnectWithoutUserInput = {
    where: InvoiceHistoryWhereUniqueInput
    create: XOR<InvoiceHistoryCreateWithoutUserInput, InvoiceHistoryUncheckedCreateWithoutUserInput>
  }

  export type InvoiceHistoryCreateManyUserInputEnvelope = {
    data: InvoiceHistoryCreateManyUserInput | InvoiceHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    tenantId: string
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PartCreateWithoutCreatedByInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutCreatedByInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutCreatedByInput, PartUncheckedCreateWithoutCreatedByInput>
  }

  export type PartCreateManyCreatedByInputEnvelope = {
    data: PartCreateManyCreatedByInput | PartCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PartCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutUpdatedByInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutUpdatedByInput, PartUncheckedCreateWithoutUpdatedByInput>
  }

  export type PartCreateManyUpdatedByInputEnvelope = {
    data: PartCreateManyUpdatedByInput | PartCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type POSSaleCreateWithoutCreatedByInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashRegister?: CashRegisterCreateNestedOneWithoutPosSalesInput
    creditNotes?: CreditNoteCreateNestedManyWithoutPosSaleInput
    customer?: CustomerCreateNestedOneWithoutPosSalesInput
    items?: POSSaleItemCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentCreateNestedManyWithoutSaleInput
    quotation?: POSQuotationCreateNestedOneWithoutConvertedToSaleInput
    tenant: TenantCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateWithoutCreatedByInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput
    items?: POSSaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleCreateOrConnectWithoutCreatedByInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutCreatedByInput, POSSaleUncheckedCreateWithoutCreatedByInput>
  }

  export type POSSaleCreateManyCreatedByInputEnvelope = {
    data: POSSaleCreateManyCreatedByInput | POSSaleCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type POSQuotationCreateWithoutCreatedByInput = {
    id?: string
    quotationNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutPosQuotationsInput
    items?: POSQuotationItemCreateNestedManyWithoutQuotationInput
    convertedToSale?: POSSaleCreateNestedOneWithoutQuotationInput
    tenant: TenantCreateNestedOneWithoutPosQuotationsInput
  }

  export type POSQuotationUncheckedCreateWithoutCreatedByInput = {
    id?: string
    quotationNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: POSQuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    convertedToSale?: POSSaleUncheckedCreateNestedOneWithoutQuotationInput
  }

  export type POSQuotationCreateOrConnectWithoutCreatedByInput = {
    where: POSQuotationWhereUniqueInput
    create: XOR<POSQuotationCreateWithoutCreatedByInput, POSQuotationUncheckedCreateWithoutCreatedByInput>
  }

  export type POSQuotationCreateManyCreatedByInputEnvelope = {
    data: POSQuotationCreateManyCreatedByInput | POSQuotationCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutReceivedByInput = {
    id?: string
    paymentNumber: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutReceivedByInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput>
  }

  export type PaymentCreateManyReceivedByInputEnvelope = {
    data: PaymentCreateManyReceivedByInput | PaymentCreateManyReceivedByInput[]
    skipDuplicates?: boolean
  }

  export type ServiceTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutServiceTemplatesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTemplatesInput
    defaultParts?: TemplateDefaultPartCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceCreateNestedManyWithoutServiceInput
    tickets?: TicketCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceUncheckedCreateNestedManyWithoutServiceInput
    tickets?: TicketUncheckedCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateCreateOrConnectWithoutCreatedByInput = {
    where: ServiceTemplateWhereUniqueInput
    create: XOR<ServiceTemplateCreateWithoutCreatedByInput, ServiceTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type ServiceTemplateCreateManyCreatedByInputEnvelope = {
    data: ServiceTemplateCreateManyCreatedByInput | ServiceTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ServiceTemplateCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedTemplatesInput
    tenant: TenantCreateNestedOneWithoutServiceTemplatesInput
    defaultParts?: TemplateDefaultPartCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceCreateNestedManyWithoutServiceInput
    tickets?: TicketCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceUncheckedCreateNestedManyWithoutServiceInput
    tickets?: TicketUncheckedCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateCreateOrConnectWithoutUpdatedByInput = {
    where: ServiceTemplateWhereUniqueInput
    create: XOR<ServiceTemplateCreateWithoutUpdatedByInput, ServiceTemplateUncheckedCreateWithoutUpdatedByInput>
  }

  export type ServiceTemplateCreateManyUpdatedByInputEnvelope = {
    data: ServiceTemplateCreateManyUpdatedByInput | ServiceTemplateCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type TechnicianSpecializationCreateWithoutUserInput = {
    id?: string
    specialization: $Enums.Specialization
    createdAt?: Date | string
  }

  export type TechnicianSpecializationUncheckedCreateWithoutUserInput = {
    id?: string
    specialization: $Enums.Specialization
    createdAt?: Date | string
  }

  export type TechnicianSpecializationCreateOrConnectWithoutUserInput = {
    where: TechnicianSpecializationWhereUniqueInput
    create: XOR<TechnicianSpecializationCreateWithoutUserInput, TechnicianSpecializationUncheckedCreateWithoutUserInput>
  }

  export type TechnicianSpecializationCreateManyUserInputEnvelope = {
    data: TechnicianSpecializationCreateManyUserInput | TechnicianSpecializationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TechnicianUnavailabilityCreateWithoutUserInput = {
    id?: string
    reason?: $Enums.TechnicianStatus
    notes?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicianUnavailabilityUncheckedCreateWithoutUserInput = {
    id?: string
    reason?: $Enums.TechnicianStatus
    notes?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicianUnavailabilityCreateOrConnectWithoutUserInput = {
    where: TechnicianUnavailabilityWhereUniqueInput
    create: XOR<TechnicianUnavailabilityCreateWithoutUserInput, TechnicianUnavailabilityUncheckedCreateWithoutUserInput>
  }

  export type TechnicianUnavailabilityCreateManyUserInputEnvelope = {
    data: TechnicianUnavailabilityCreateManyUserInput | TechnicianUnavailabilityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketNoteCreateWithoutAuthorInput = {
    id?: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutNotesInput
  }

  export type TicketNoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    isInternal?: boolean
    ticketId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketNoteCreateOrConnectWithoutAuthorInput = {
    where: TicketNoteWhereUniqueInput
    create: XOR<TicketNoteCreateWithoutAuthorInput, TicketNoteUncheckedCreateWithoutAuthorInput>
  }

  export type TicketNoteCreateManyAuthorInputEnvelope = {
    data: TicketNoteCreateManyAuthorInput | TicketNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAssignedToInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutAssignedToInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput>
  }

  export type TicketCreateManyAssignedToInputEnvelope = {
    data: TicketCreateManyAssignedToInput | TicketCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutCreatedByInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutCreatedByInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutCreatedByInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCreatedByInput, TicketUncheckedCreateWithoutCreatedByInput>
  }

  export type TicketCreateManyCreatedByInputEnvelope = {
    data: TicketCreateManyCreatedByInput | TicketCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutUpdatedByInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutUpdatedByInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutUpdatedByInput, TicketUncheckedCreateWithoutUpdatedByInput>
  }

  export type TicketCreateManyUpdatedByInputEnvelope = {
    data: TicketCreateManyUpdatedByInput | TicketCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type TicketAttachmentCreateWithoutUploadedByInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutAttachmentsInput
  }

  export type TicketAttachmentUncheckedCreateWithoutUploadedByInput = {
    id?: string
    ticketId: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
  }

  export type TicketAttachmentCreateOrConnectWithoutUploadedByInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutUploadedByInput, TicketAttachmentUncheckedCreateWithoutUploadedByInput>
  }

  export type TicketAttachmentCreateManyUploadedByInputEnvelope = {
    data: TicketAttachmentCreateManyUploadedByInput | TicketAttachmentCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutUsersCreatedInput = {
    update: XOR<UserUpdateWithoutUsersCreatedInput, UserUncheckedUpdateWithoutUsersCreatedInput>
    create: XOR<UserCreateWithoutUsersCreatedInput, UserUncheckedCreateWithoutUsersCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsersCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsersCreatedInput, UserUncheckedUpdateWithoutUsersCreatedInput>
  }

  export type UserUpdateWithoutUsersCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUsersCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutUsersUpdatedInput = {
    update: XOR<UserUpdateWithoutUsersUpdatedInput, UserUncheckedUpdateWithoutUsersUpdatedInput>
    create: XOR<UserCreateWithoutUsersUpdatedInput, UserUncheckedCreateWithoutUsersUpdatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsersUpdatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsersUpdatedInput, UserUncheckedUpdateWithoutUsersUpdatedInput>
  }

  export type UserUpdateWithoutUsersUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUsersUpdatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
    create: XOR<UserCreateWithoutCreatedByInput, UserUncheckedCreateWithoutCreatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCreatedByInput, UserUncheckedUpdateWithoutCreatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutCreatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type UserUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUpdatedByInput, UserUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<UserCreateWithoutUpdatedByInput, UserUncheckedCreateWithoutUpdatedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUpdatedByInput, UserUncheckedUpdateWithoutUpdatedByInput>
  }

  export type UserUpdateManyWithWhereWithoutUpdatedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionLogWhereUniqueInput
    update: XOR<SessionLogUpdateWithoutUserInput, SessionLogUncheckedUpdateWithoutUserInput>
    create: XOR<SessionLogCreateWithoutUserInput, SessionLogUncheckedCreateWithoutUserInput>
  }

  export type SessionLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionLogWhereUniqueInput
    data: XOR<SessionLogUpdateWithoutUserInput, SessionLogUncheckedUpdateWithoutUserInput>
  }

  export type SessionLogUpdateManyWithWhereWithoutUserInput = {
    where: SessionLogScalarWhereInput
    data: XOR<SessionLogUpdateManyMutationInput, SessionLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPresenceUpsertWithoutUserInput = {
    update: XOR<UserPresenceUpdateWithoutUserInput, UserPresenceUncheckedUpdateWithoutUserInput>
    create: XOR<UserPresenceCreateWithoutUserInput, UserPresenceUncheckedCreateWithoutUserInput>
    where?: UserPresenceWhereInput
  }

  export type UserPresenceUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPresenceWhereInput
    data: XOR<UserPresenceUpdateWithoutUserInput, UserPresenceUncheckedUpdateWithoutUserInput>
  }

  export type UserPresenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tenant?: TenantUpdateOneRequiredWithoutUserPresencesNestedInput
    currentTicket?: TicketUpdateOneWithoutViewedByUsersNestedInput
  }

  export type UserPresenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    currentTicketId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CashRegisterUpsertWithWhereUniqueWithoutClosedByInput = {
    where: CashRegisterWhereUniqueInput
    update: XOR<CashRegisterUpdateWithoutClosedByInput, CashRegisterUncheckedUpdateWithoutClosedByInput>
    create: XOR<CashRegisterCreateWithoutClosedByInput, CashRegisterUncheckedCreateWithoutClosedByInput>
  }

  export type CashRegisterUpdateWithWhereUniqueWithoutClosedByInput = {
    where: CashRegisterWhereUniqueInput
    data: XOR<CashRegisterUpdateWithoutClosedByInput, CashRegisterUncheckedUpdateWithoutClosedByInput>
  }

  export type CashRegisterUpdateManyWithWhereWithoutClosedByInput = {
    where: CashRegisterScalarWhereInput
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyWithoutClosedByInput>
  }

  export type CashRegisterUpsertWithWhereUniqueWithoutOpenedByInput = {
    where: CashRegisterWhereUniqueInput
    update: XOR<CashRegisterUpdateWithoutOpenedByInput, CashRegisterUncheckedUpdateWithoutOpenedByInput>
    create: XOR<CashRegisterCreateWithoutOpenedByInput, CashRegisterUncheckedCreateWithoutOpenedByInput>
  }

  export type CashRegisterUpdateWithWhereUniqueWithoutOpenedByInput = {
    where: CashRegisterWhereUniqueInput
    data: XOR<CashRegisterUpdateWithoutOpenedByInput, CashRegisterUncheckedUpdateWithoutOpenedByInput>
  }

  export type CashRegisterUpdateManyWithWhereWithoutOpenedByInput = {
    where: CashRegisterScalarWhereInput
    data: XOR<CashRegisterUpdateManyMutationInput, CashRegisterUncheckedUpdateManyWithoutOpenedByInput>
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutCreatedByInput, CashTransactionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CashTransactionCreateWithoutCreatedByInput, CashTransactionUncheckedCreateWithoutCreatedByInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutCreatedByInput, CashTransactionUncheckedUpdateWithoutCreatedByInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutCreatedByInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CreditNoteUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CreditNoteWhereUniqueInput
    update: XOR<CreditNoteUpdateWithoutCreatedByInput, CreditNoteUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CreditNoteCreateWithoutCreatedByInput, CreditNoteUncheckedCreateWithoutCreatedByInput>
  }

  export type CreditNoteUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CreditNoteWhereUniqueInput
    data: XOR<CreditNoteUpdateWithoutCreatedByInput, CreditNoteUncheckedUpdateWithoutCreatedByInput>
  }

  export type CreditNoteUpdateManyWithWhereWithoutCreatedByInput = {
    where: CreditNoteScalarWhereInput
    data: XOR<CreditNoteUpdateManyMutationInput, CreditNoteUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CreditNoteUpsertWithWhereUniqueWithoutProcessedByInput = {
    where: CreditNoteWhereUniqueInput
    update: XOR<CreditNoteUpdateWithoutProcessedByInput, CreditNoteUncheckedUpdateWithoutProcessedByInput>
    create: XOR<CreditNoteCreateWithoutProcessedByInput, CreditNoteUncheckedCreateWithoutProcessedByInput>
  }

  export type CreditNoteUpdateWithWhereUniqueWithoutProcessedByInput = {
    where: CreditNoteWhereUniqueInput
    data: XOR<CreditNoteUpdateWithoutProcessedByInput, CreditNoteUncheckedUpdateWithoutProcessedByInput>
  }

  export type CreditNoteUpdateManyWithWhereWithoutProcessedByInput = {
    where: CreditNoteScalarWhereInput
    data: XOR<CreditNoteUpdateManyMutationInput, CreditNoteUncheckedUpdateManyWithoutProcessedByInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutCreatedByInput, CustomerUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutCreatedByInput, CustomerUncheckedUpdateWithoutCreatedByInput>
  }

  export type CustomerUpdateManyWithWhereWithoutCreatedByInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutUpdatedByInput, CustomerUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<CustomerCreateWithoutUpdatedByInput, CustomerUncheckedCreateWithoutUpdatedByInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutUpdatedByInput, CustomerUncheckedUpdateWithoutUpdatedByInput>
  }

  export type CustomerUpdateManyWithWhereWithoutUpdatedByInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCreatedByInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUpdatedByInput, InvoiceUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<InvoiceCreateWithoutUpdatedByInput, InvoiceUncheckedCreateWithoutUpdatedByInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUpdatedByInput, InvoiceUncheckedUpdateWithoutUpdatedByInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUpdatedByInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type InvoiceHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceHistoryWhereUniqueInput
    update: XOR<InvoiceHistoryUpdateWithoutUserInput, InvoiceHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceHistoryCreateWithoutUserInput, InvoiceHistoryUncheckedCreateWithoutUserInput>
  }

  export type InvoiceHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceHistoryWhereUniqueInput
    data: XOR<InvoiceHistoryUpdateWithoutUserInput, InvoiceHistoryUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceHistoryUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceHistoryScalarWhereInput
    data: XOR<InvoiceHistoryUpdateManyMutationInput, InvoiceHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceHistoryScalarWhereInput = {
    AND?: InvoiceHistoryScalarWhereInput | InvoiceHistoryScalarWhereInput[]
    OR?: InvoiceHistoryScalarWhereInput[]
    NOT?: InvoiceHistoryScalarWhereInput | InvoiceHistoryScalarWhereInput[]
    id?: UuidFilter<"InvoiceHistory"> | string
    invoiceId?: UuidFilter<"InvoiceHistory"> | string
    action?: StringFilter<"InvoiceHistory"> | string
    oldValue?: StringNullableFilter<"InvoiceHistory"> | string | null
    newValue?: StringNullableFilter<"InvoiceHistory"> | string | null
    notes?: StringNullableFilter<"InvoiceHistory"> | string | null
    userId?: UuidFilter<"InvoiceHistory"> | string
    createdAt?: DateTimeFilter<"InvoiceHistory"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type PartUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PartWhereUniqueInput
    update: XOR<PartUpdateWithoutCreatedByInput, PartUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PartCreateWithoutCreatedByInput, PartUncheckedCreateWithoutCreatedByInput>
  }

  export type PartUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PartWhereUniqueInput
    data: XOR<PartUpdateWithoutCreatedByInput, PartUncheckedUpdateWithoutCreatedByInput>
  }

  export type PartUpdateManyWithWhereWithoutCreatedByInput = {
    where: PartScalarWhereInput
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PartUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: PartWhereUniqueInput
    update: XOR<PartUpdateWithoutUpdatedByInput, PartUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<PartCreateWithoutUpdatedByInput, PartUncheckedCreateWithoutUpdatedByInput>
  }

  export type PartUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: PartWhereUniqueInput
    data: XOR<PartUpdateWithoutUpdatedByInput, PartUncheckedUpdateWithoutUpdatedByInput>
  }

  export type PartUpdateManyWithWhereWithoutUpdatedByInput = {
    where: PartScalarWhereInput
    data: XOR<PartUpdateManyMutationInput, PartUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type POSSaleUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: POSSaleWhereUniqueInput
    update: XOR<POSSaleUpdateWithoutCreatedByInput, POSSaleUncheckedUpdateWithoutCreatedByInput>
    create: XOR<POSSaleCreateWithoutCreatedByInput, POSSaleUncheckedCreateWithoutCreatedByInput>
  }

  export type POSSaleUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: POSSaleWhereUniqueInput
    data: XOR<POSSaleUpdateWithoutCreatedByInput, POSSaleUncheckedUpdateWithoutCreatedByInput>
  }

  export type POSSaleUpdateManyWithWhereWithoutCreatedByInput = {
    where: POSSaleScalarWhereInput
    data: XOR<POSSaleUpdateManyMutationInput, POSSaleUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type POSQuotationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: POSQuotationWhereUniqueInput
    update: XOR<POSQuotationUpdateWithoutCreatedByInput, POSQuotationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<POSQuotationCreateWithoutCreatedByInput, POSQuotationUncheckedCreateWithoutCreatedByInput>
  }

  export type POSQuotationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: POSQuotationWhereUniqueInput
    data: XOR<POSQuotationUpdateWithoutCreatedByInput, POSQuotationUncheckedUpdateWithoutCreatedByInput>
  }

  export type POSQuotationUpdateManyWithWhereWithoutCreatedByInput = {
    where: POSQuotationScalarWhereInput
    data: XOR<POSQuotationUpdateManyMutationInput, POSQuotationUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutReceivedByInput, PaymentUncheckedUpdateWithoutReceivedByInput>
    create: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutReceivedByInput, PaymentUncheckedUpdateWithoutReceivedByInput>
  }

  export type PaymentUpdateManyWithWhereWithoutReceivedByInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutReceivedByInput>
  }

  export type ServiceTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ServiceTemplateWhereUniqueInput
    update: XOR<ServiceTemplateUpdateWithoutCreatedByInput, ServiceTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ServiceTemplateCreateWithoutCreatedByInput, ServiceTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type ServiceTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ServiceTemplateWhereUniqueInput
    data: XOR<ServiceTemplateUpdateWithoutCreatedByInput, ServiceTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type ServiceTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: ServiceTemplateScalarWhereInput
    data: XOR<ServiceTemplateUpdateManyMutationInput, ServiceTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ServiceTemplateUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: ServiceTemplateWhereUniqueInput
    update: XOR<ServiceTemplateUpdateWithoutUpdatedByInput, ServiceTemplateUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<ServiceTemplateCreateWithoutUpdatedByInput, ServiceTemplateUncheckedCreateWithoutUpdatedByInput>
  }

  export type ServiceTemplateUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: ServiceTemplateWhereUniqueInput
    data: XOR<ServiceTemplateUpdateWithoutUpdatedByInput, ServiceTemplateUncheckedUpdateWithoutUpdatedByInput>
  }

  export type ServiceTemplateUpdateManyWithWhereWithoutUpdatedByInput = {
    where: ServiceTemplateScalarWhereInput
    data: XOR<ServiceTemplateUpdateManyMutationInput, ServiceTemplateUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type TechnicianSpecializationUpsertWithWhereUniqueWithoutUserInput = {
    where: TechnicianSpecializationWhereUniqueInput
    update: XOR<TechnicianSpecializationUpdateWithoutUserInput, TechnicianSpecializationUncheckedUpdateWithoutUserInput>
    create: XOR<TechnicianSpecializationCreateWithoutUserInput, TechnicianSpecializationUncheckedCreateWithoutUserInput>
  }

  export type TechnicianSpecializationUpdateWithWhereUniqueWithoutUserInput = {
    where: TechnicianSpecializationWhereUniqueInput
    data: XOR<TechnicianSpecializationUpdateWithoutUserInput, TechnicianSpecializationUncheckedUpdateWithoutUserInput>
  }

  export type TechnicianSpecializationUpdateManyWithWhereWithoutUserInput = {
    where: TechnicianSpecializationScalarWhereInput
    data: XOR<TechnicianSpecializationUpdateManyMutationInput, TechnicianSpecializationUncheckedUpdateManyWithoutUserInput>
  }

  export type TechnicianSpecializationScalarWhereInput = {
    AND?: TechnicianSpecializationScalarWhereInput | TechnicianSpecializationScalarWhereInput[]
    OR?: TechnicianSpecializationScalarWhereInput[]
    NOT?: TechnicianSpecializationScalarWhereInput | TechnicianSpecializationScalarWhereInput[]
    id?: UuidFilter<"TechnicianSpecialization"> | string
    userId?: UuidFilter<"TechnicianSpecialization"> | string
    specialization?: EnumSpecializationFilter<"TechnicianSpecialization"> | $Enums.Specialization
    createdAt?: DateTimeFilter<"TechnicianSpecialization"> | Date | string
  }

  export type TechnicianUnavailabilityUpsertWithWhereUniqueWithoutUserInput = {
    where: TechnicianUnavailabilityWhereUniqueInput
    update: XOR<TechnicianUnavailabilityUpdateWithoutUserInput, TechnicianUnavailabilityUncheckedUpdateWithoutUserInput>
    create: XOR<TechnicianUnavailabilityCreateWithoutUserInput, TechnicianUnavailabilityUncheckedCreateWithoutUserInput>
  }

  export type TechnicianUnavailabilityUpdateWithWhereUniqueWithoutUserInput = {
    where: TechnicianUnavailabilityWhereUniqueInput
    data: XOR<TechnicianUnavailabilityUpdateWithoutUserInput, TechnicianUnavailabilityUncheckedUpdateWithoutUserInput>
  }

  export type TechnicianUnavailabilityUpdateManyWithWhereWithoutUserInput = {
    where: TechnicianUnavailabilityScalarWhereInput
    data: XOR<TechnicianUnavailabilityUpdateManyMutationInput, TechnicianUnavailabilityUncheckedUpdateManyWithoutUserInput>
  }

  export type TechnicianUnavailabilityScalarWhereInput = {
    AND?: TechnicianUnavailabilityScalarWhereInput | TechnicianUnavailabilityScalarWhereInput[]
    OR?: TechnicianUnavailabilityScalarWhereInput[]
    NOT?: TechnicianUnavailabilityScalarWhereInput | TechnicianUnavailabilityScalarWhereInput[]
    id?: UuidFilter<"TechnicianUnavailability"> | string
    reason?: EnumTechnicianStatusFilter<"TechnicianUnavailability"> | $Enums.TechnicianStatus
    notes?: StringNullableFilter<"TechnicianUnavailability"> | string | null
    userId?: UuidFilter<"TechnicianUnavailability"> | string
    startDate?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    endDate?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    isActive?: BoolFilter<"TechnicianUnavailability"> | boolean
    createdAt?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
    updatedAt?: DateTimeFilter<"TechnicianUnavailability"> | Date | string
  }

  export type TicketNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TicketNoteWhereUniqueInput
    update: XOR<TicketNoteUpdateWithoutAuthorInput, TicketNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<TicketNoteCreateWithoutAuthorInput, TicketNoteUncheckedCreateWithoutAuthorInput>
  }

  export type TicketNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TicketNoteWhereUniqueInput
    data: XOR<TicketNoteUpdateWithoutAuthorInput, TicketNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type TicketNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: TicketNoteScalarWhereInput
    data: XOR<TicketNoteUpdateManyMutationInput, TicketNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TicketNoteScalarWhereInput = {
    AND?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
    OR?: TicketNoteScalarWhereInput[]
    NOT?: TicketNoteScalarWhereInput | TicketNoteScalarWhereInput[]
    id?: UuidFilter<"TicketNote"> | string
    content?: StringFilter<"TicketNote"> | string
    isInternal?: BoolFilter<"TicketNote"> | boolean
    ticketId?: UuidFilter<"TicketNote"> | string
    authorId?: UuidFilter<"TicketNote"> | string
    createdAt?: DateTimeFilter<"TicketNote"> | Date | string
    updatedAt?: DateTimeFilter<"TicketNote"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssignedToInput, TicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<TicketCreateWithoutAssignedToInput, TicketUncheckedCreateWithoutAssignedToInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssignedToInput, TicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutCreatedByInput, TicketUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TicketCreateWithoutCreatedByInput, TicketUncheckedCreateWithoutCreatedByInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutCreatedByInput, TicketUncheckedUpdateWithoutCreatedByInput>
  }

  export type TicketUpdateManyWithWhereWithoutCreatedByInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutUpdatedByInput, TicketUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<TicketCreateWithoutUpdatedByInput, TicketUncheckedCreateWithoutUpdatedByInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutUpdatedByInput, TicketUncheckedUpdateWithoutUpdatedByInput>
  }

  export type TicketUpdateManyWithWhereWithoutUpdatedByInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutUploadedByInput, TicketAttachmentUncheckedUpdateWithoutUploadedByInput>
    create: XOR<TicketAttachmentCreateWithoutUploadedByInput, TicketAttachmentUncheckedCreateWithoutUploadedByInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutUploadedByInput, TicketAttachmentUncheckedUpdateWithoutUploadedByInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutUploadedByInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type TicketAttachmentScalarWhereInput = {
    AND?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    OR?: TicketAttachmentScalarWhereInput[]
    NOT?: TicketAttachmentScalarWhereInput | TicketAttachmentScalarWhereInput[]
    id?: UuidFilter<"TicketAttachment"> | string
    ticketId?: UuidFilter<"TicketAttachment"> | string
    filename?: StringFilter<"TicketAttachment"> | string
    originalName?: StringFilter<"TicketAttachment"> | string
    mimeType?: StringFilter<"TicketAttachment"> | string
    size?: IntFilter<"TicketAttachment"> | number
    url?: StringFilter<"TicketAttachment"> | string
    uploadedById?: UuidFilter<"TicketAttachment"> | string
    createdAt?: DateTimeFilter<"TicketAttachment"> | Date | string
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateWithoutCreatedCustomersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreatedCustomersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCustomersInput, UserUncheckedCreateWithoutCreatedCustomersInput>
  }

  export type CreditNoteCreateWithoutCustomerInput = {
    id?: string
    creditNoteNumber: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreditNotesCreatedInput
    processedBy?: UserCreateNestedOneWithoutCreditNotesProcessedInput
    items?: CreditNoteItemCreateNestedManyWithoutCreditNoteInput
    posSale: POSSaleCreateNestedOneWithoutCreditNotesInput
    tenant: TenantCreateNestedOneWithoutCreditNotesInput
  }

  export type CreditNoteUncheckedCreateWithoutCustomerInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CreditNoteItemUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type CreditNoteCreateOrConnectWithoutCustomerInput = {
    where: CreditNoteWhereUniqueInput
    create: XOR<CreditNoteCreateWithoutCustomerInput, CreditNoteUncheckedCreateWithoutCustomerInput>
  }

  export type CreditNoteCreateManyCustomerInputEnvelope = {
    data: CreditNoteCreateManyCustomerInput | CreditNoteCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCustomerInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    history?: InvoiceHistoryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    ticket: TicketCreateNestedOneWithoutInvoiceInput
    updatedBy: UserCreateNestedOneWithoutUpdatedInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: InvoiceHistoryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type POSSaleCreateWithoutCustomerInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashRegister?: CashRegisterCreateNestedOneWithoutPosSalesInput
    createdBy: UserCreateNestedOneWithoutPosSalesInput
    creditNotes?: CreditNoteCreateNestedManyWithoutPosSaleInput
    items?: POSSaleItemCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentCreateNestedManyWithoutSaleInput
    quotation?: POSQuotationCreateNestedOneWithoutConvertedToSaleInput
    tenant: TenantCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput
    items?: POSSaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleCreateOrConnectWithoutCustomerInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutCustomerInput, POSSaleUncheckedCreateWithoutCustomerInput>
  }

  export type POSSaleCreateManyCustomerInputEnvelope = {
    data: POSSaleCreateManyCustomerInput | POSSaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type POSQuotationCreateWithoutCustomerInput = {
    id?: string
    quotationNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPosQuotationsInput
    items?: POSQuotationItemCreateNestedManyWithoutQuotationInput
    convertedToSale?: POSSaleCreateNestedOneWithoutQuotationInput
    tenant: TenantCreateNestedOneWithoutPosQuotationsInput
  }

  export type POSQuotationUncheckedCreateWithoutCustomerInput = {
    id?: string
    quotationNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: POSQuotationItemUncheckedCreateNestedManyWithoutQuotationInput
    convertedToSale?: POSSaleUncheckedCreateNestedOneWithoutQuotationInput
  }

  export type POSQuotationCreateOrConnectWithoutCustomerInput = {
    where: POSQuotationWhereUniqueInput
    create: XOR<POSQuotationCreateWithoutCustomerInput, POSQuotationUncheckedCreateWithoutCustomerInput>
  }

  export type POSQuotationCreateManyCustomerInputEnvelope = {
    data: POSQuotationCreateManyCustomerInput | POSQuotationCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutCustomersInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCustomersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
  }

  export type TicketCreateWithoutCustomerInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutCustomerInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutCustomerInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput>
  }

  export type TicketCreateManyCustomerInputEnvelope = {
    data: TicketCreateManyCustomerInput | TicketCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutUpdatedCustomersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUpdatedCustomersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedCustomersInput, UserUncheckedCreateWithoutUpdatedCustomersInput>
  }

  export type UserUpsertWithoutCreatedCustomersInput = {
    update: XOR<UserUpdateWithoutCreatedCustomersInput, UserUncheckedUpdateWithoutCreatedCustomersInput>
    create: XOR<UserCreateWithoutCreatedCustomersInput, UserUncheckedCreateWithoutCreatedCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCustomersInput, UserUncheckedUpdateWithoutCreatedCustomersInput>
  }

  export type UserUpdateWithoutCreatedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type CreditNoteUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CreditNoteWhereUniqueInput
    update: XOR<CreditNoteUpdateWithoutCustomerInput, CreditNoteUncheckedUpdateWithoutCustomerInput>
    create: XOR<CreditNoteCreateWithoutCustomerInput, CreditNoteUncheckedCreateWithoutCustomerInput>
  }

  export type CreditNoteUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CreditNoteWhereUniqueInput
    data: XOR<CreditNoteUpdateWithoutCustomerInput, CreditNoteUncheckedUpdateWithoutCustomerInput>
  }

  export type CreditNoteUpdateManyWithWhereWithoutCustomerInput = {
    where: CreditNoteScalarWhereInput
    data: XOR<CreditNoteUpdateManyMutationInput, CreditNoteUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type POSSaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: POSSaleWhereUniqueInput
    update: XOR<POSSaleUpdateWithoutCustomerInput, POSSaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<POSSaleCreateWithoutCustomerInput, POSSaleUncheckedCreateWithoutCustomerInput>
  }

  export type POSSaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: POSSaleWhereUniqueInput
    data: XOR<POSSaleUpdateWithoutCustomerInput, POSSaleUncheckedUpdateWithoutCustomerInput>
  }

  export type POSSaleUpdateManyWithWhereWithoutCustomerInput = {
    where: POSSaleScalarWhereInput
    data: XOR<POSSaleUpdateManyMutationInput, POSSaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type POSQuotationUpsertWithWhereUniqueWithoutCustomerInput = {
    where: POSQuotationWhereUniqueInput
    update: XOR<POSQuotationUpdateWithoutCustomerInput, POSQuotationUncheckedUpdateWithoutCustomerInput>
    create: XOR<POSQuotationCreateWithoutCustomerInput, POSQuotationUncheckedCreateWithoutCustomerInput>
  }

  export type POSQuotationUpdateWithWhereUniqueWithoutCustomerInput = {
    where: POSQuotationWhereUniqueInput
    data: XOR<POSQuotationUpdateWithoutCustomerInput, POSQuotationUncheckedUpdateWithoutCustomerInput>
  }

  export type POSQuotationUpdateManyWithWhereWithoutCustomerInput = {
    where: POSQuotationScalarWhereInput
    data: XOR<POSQuotationUpdateManyMutationInput, POSQuotationUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TenantUpsertWithoutCustomersInput = {
    update: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCustomersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type TenantUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutCustomerInput, TicketUncheckedUpdateWithoutCustomerInput>
    create: XOR<TicketCreateWithoutCustomerInput, TicketUncheckedCreateWithoutCustomerInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutCustomerInput, TicketUncheckedUpdateWithoutCustomerInput>
  }

  export type TicketUpdateManyWithWhereWithoutCustomerInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserUpsertWithoutUpdatedCustomersInput = {
    update: XOR<UserUpdateWithoutUpdatedCustomersInput, UserUncheckedUpdateWithoutUpdatedCustomersInput>
    create: XOR<UserCreateWithoutUpdatedCustomersInput, UserUncheckedCreateWithoutUpdatedCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedCustomersInput, UserUncheckedUpdateWithoutUpdatedCustomersInput>
  }

  export type UserUpdateWithoutUpdatedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TicketAttachmentCreateWithoutTicketInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedAttachmentsInput
  }

  export type TicketAttachmentUncheckedCreateWithoutTicketInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    uploadedById: string
    createdAt?: Date | string
  }

  export type TicketAttachmentCreateOrConnectWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentCreateManyTicketInputEnvelope = {
    data: TicketAttachmentCreateManyTicketInput | TicketAttachmentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTicketInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    history?: InvoiceHistoryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    updatedBy: UserCreateNestedOneWithoutUpdatedInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutTicketInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: InvoiceHistoryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTicketInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTicketInput, InvoiceUncheckedCreateWithoutTicketInput>
  }

  export type PartUsageCreateWithoutTicketInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    part: PartCreateNestedOneWithoutUsagesInput
  }

  export type PartUsageUncheckedCreateWithoutTicketInput = {
    id?: string
    quantity: number
    partId: string
    createdAt?: Date | string
  }

  export type PartUsageCreateOrConnectWithoutTicketInput = {
    where: PartUsageWhereUniqueInput
    create: XOR<PartUsageCreateWithoutTicketInput, PartUsageUncheckedCreateWithoutTicketInput>
  }

  export type PartUsageCreateManyTicketInputEnvelope = {
    data: PartUsageCreateManyTicketInput | PartUsageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketNoteCreateWithoutTicketInput = {
    id?: string
    content: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutTicketNotesInput
  }

  export type TicketNoteUncheckedCreateWithoutTicketInput = {
    id?: string
    content: string
    isInternal?: boolean
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketNoteCreateOrConnectWithoutTicketInput = {
    where: TicketNoteWhereUniqueInput
    create: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput>
  }

  export type TicketNoteCreateManyTicketInputEnvelope = {
    data: TicketNoteCreateManyTicketInput | TicketNoteCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketServiceCreateWithoutTicketInput = {
    id?: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    service: ServiceTemplateCreateNestedOneWithoutUsagesInput
  }

  export type TicketServiceUncheckedCreateWithoutTicketInput = {
    id?: string
    serviceId: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TicketServiceCreateOrConnectWithoutTicketInput = {
    where: TicketServiceWhereUniqueInput
    create: XOR<TicketServiceCreateWithoutTicketInput, TicketServiceUncheckedCreateWithoutTicketInput>
  }

  export type TicketServiceCreateManyTicketInputEnvelope = {
    data: TicketServiceCreateManyTicketInput | TicketServiceCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type UserCreateWithoutCreatedTicketsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreatedTicketsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTicketsInput, UserUncheckedCreateWithoutCreatedTicketsInput>
  }

  export type CustomerCreateWithoutTicketsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedCustomersInput
    creditNotes?: CreditNoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCustomerInput
    tenant: TenantCreateNestedOneWithoutCustomersInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedCustomersInput
  }

  export type CustomerUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTicketsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTicketsInput, CustomerUncheckedCreateWithoutTicketsInput>
  }

  export type ServiceTemplateCreateWithoutTicketsInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedTemplatesInput
    tenant: TenantCreateNestedOneWithoutServiceTemplatesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTemplatesInput
    defaultParts?: TemplateDefaultPartCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceTemplateUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutTemplateInput
    usages?: TicketServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceTemplateCreateOrConnectWithoutTicketsInput = {
    where: ServiceTemplateWhereUniqueInput
    create: XOR<ServiceTemplateCreateWithoutTicketsInput, ServiceTemplateUncheckedCreateWithoutTicketsInput>
  }

  export type TenantCreateWithoutTicketsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTicketsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTicketsInput, TenantUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutUpdatedTicketsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUpdatedTicketsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedTicketsInput, UserUncheckedCreateWithoutUpdatedTicketsInput>
  }

  export type UserPresenceCreateWithoutCurrentTicketInput = {
    id?: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPresenceInput
    tenant: TenantCreateNestedOneWithoutUserPresencesInput
  }

  export type UserPresenceUncheckedCreateWithoutCurrentTicketInput = {
    id?: string
    userId: string
    tenantId: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceCreateOrConnectWithoutCurrentTicketInput = {
    where: UserPresenceWhereUniqueInput
    create: XOR<UserPresenceCreateWithoutCurrentTicketInput, UserPresenceUncheckedCreateWithoutCurrentTicketInput>
  }

  export type UserPresenceCreateManyCurrentTicketInputEnvelope = {
    data: UserPresenceCreateManyCurrentTicketInput | UserPresenceCreateManyCurrentTicketInput[]
    skipDuplicates?: boolean
  }

  export type TicketAttachmentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    update: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketAttachmentCreateWithoutTicketInput, TicketAttachmentUncheckedCreateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketAttachmentWhereUniqueInput
    data: XOR<TicketAttachmentUpdateWithoutTicketInput, TicketAttachmentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketAttachmentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketAttachmentScalarWhereInput
    data: XOR<TicketAttachmentUpdateManyMutationInput, TicketAttachmentUncheckedUpdateManyWithoutTicketInput>
  }

  export type InvoiceUpsertWithoutTicketInput = {
    update: XOR<InvoiceUpdateWithoutTicketInput, InvoiceUncheckedUpdateWithoutTicketInput>
    create: XOR<InvoiceCreateWithoutTicketInput, InvoiceUncheckedCreateWithoutTicketInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTicketInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTicketInput, InvoiceUncheckedUpdateWithoutTicketInput>
  }

  export type InvoiceUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    history?: InvoiceHistoryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: InvoiceHistoryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PartUsageUpsertWithWhereUniqueWithoutTicketInput = {
    where: PartUsageWhereUniqueInput
    update: XOR<PartUsageUpdateWithoutTicketInput, PartUsageUncheckedUpdateWithoutTicketInput>
    create: XOR<PartUsageCreateWithoutTicketInput, PartUsageUncheckedCreateWithoutTicketInput>
  }

  export type PartUsageUpdateWithWhereUniqueWithoutTicketInput = {
    where: PartUsageWhereUniqueInput
    data: XOR<PartUsageUpdateWithoutTicketInput, PartUsageUncheckedUpdateWithoutTicketInput>
  }

  export type PartUsageUpdateManyWithWhereWithoutTicketInput = {
    where: PartUsageScalarWhereInput
    data: XOR<PartUsageUpdateManyMutationInput, PartUsageUncheckedUpdateManyWithoutTicketInput>
  }

  export type PartUsageScalarWhereInput = {
    AND?: PartUsageScalarWhereInput | PartUsageScalarWhereInput[]
    OR?: PartUsageScalarWhereInput[]
    NOT?: PartUsageScalarWhereInput | PartUsageScalarWhereInput[]
    id?: UuidFilter<"PartUsage"> | string
    quantity?: IntFilter<"PartUsage"> | number
    ticketId?: UuidFilter<"PartUsage"> | string
    partId?: UuidFilter<"PartUsage"> | string
    createdAt?: DateTimeFilter<"PartUsage"> | Date | string
  }

  export type TicketNoteUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketNoteWhereUniqueInput
    update: XOR<TicketNoteUpdateWithoutTicketInput, TicketNoteUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketNoteCreateWithoutTicketInput, TicketNoteUncheckedCreateWithoutTicketInput>
  }

  export type TicketNoteUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketNoteWhereUniqueInput
    data: XOR<TicketNoteUpdateWithoutTicketInput, TicketNoteUncheckedUpdateWithoutTicketInput>
  }

  export type TicketNoteUpdateManyWithWhereWithoutTicketInput = {
    where: TicketNoteScalarWhereInput
    data: XOR<TicketNoteUpdateManyMutationInput, TicketNoteUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketServiceUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketServiceWhereUniqueInput
    update: XOR<TicketServiceUpdateWithoutTicketInput, TicketServiceUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketServiceCreateWithoutTicketInput, TicketServiceUncheckedCreateWithoutTicketInput>
  }

  export type TicketServiceUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketServiceWhereUniqueInput
    data: XOR<TicketServiceUpdateWithoutTicketInput, TicketServiceUncheckedUpdateWithoutTicketInput>
  }

  export type TicketServiceUpdateManyWithWhereWithoutTicketInput = {
    where: TicketServiceScalarWhereInput
    data: XOR<TicketServiceUpdateManyMutationInput, TicketServiceUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketServiceScalarWhereInput = {
    AND?: TicketServiceScalarWhereInput | TicketServiceScalarWhereInput[]
    OR?: TicketServiceScalarWhereInput[]
    NOT?: TicketServiceScalarWhereInput | TicketServiceScalarWhereInput[]
    id?: UuidFilter<"TicketService"> | string
    ticketId?: UuidFilter<"TicketService"> | string
    serviceId?: UuidFilter<"TicketService"> | string
    name?: StringFilter<"TicketService"> | string
    laborCost?: DecimalFilter<"TicketService"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TicketService"> | Date | string
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutCreatedTicketsInput = {
    update: XOR<UserUpdateWithoutCreatedTicketsInput, UserUncheckedUpdateWithoutCreatedTicketsInput>
    create: XOR<UserCreateWithoutCreatedTicketsInput, UserUncheckedCreateWithoutCreatedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTicketsInput, UserUncheckedUpdateWithoutCreatedTicketsInput>
  }

  export type UserUpdateWithoutCreatedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type CustomerUpsertWithoutTicketsInput = {
    update: XOR<CustomerUpdateWithoutTicketsInput, CustomerUncheckedUpdateWithoutTicketsInput>
    create: XOR<CustomerCreateWithoutTicketsInput, CustomerUncheckedCreateWithoutTicketsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTicketsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTicketsInput, CustomerUncheckedUpdateWithoutTicketsInput>
  }

  export type CustomerUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedCustomersNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCustomerNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ServiceTemplateUpsertWithoutTicketsInput = {
    update: XOR<ServiceTemplateUpdateWithoutTicketsInput, ServiceTemplateUncheckedUpdateWithoutTicketsInput>
    create: XOR<ServiceTemplateCreateWithoutTicketsInput, ServiceTemplateUncheckedCreateWithoutTicketsInput>
    where?: ServiceTemplateWhereInput
  }

  export type ServiceTemplateUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ServiceTemplateWhereInput
    data: XOR<ServiceTemplateUpdateWithoutTicketsInput, ServiceTemplateUncheckedUpdateWithoutTicketsInput>
  }

  export type ServiceTemplateUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedTemplatesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutServiceTemplatesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTemplatesNestedInput
    defaultParts?: TemplateDefaultPartUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceTemplateUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type TenantUpsertWithoutTicketsInput = {
    update: XOR<TenantUpdateWithoutTicketsInput, TenantUncheckedUpdateWithoutTicketsInput>
    create: XOR<TenantCreateWithoutTicketsInput, TenantUncheckedCreateWithoutTicketsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTicketsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTicketsInput, TenantUncheckedUpdateWithoutTicketsInput>
  }

  export type TenantUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutUpdatedTicketsInput = {
    update: XOR<UserUpdateWithoutUpdatedTicketsInput, UserUncheckedUpdateWithoutUpdatedTicketsInput>
    create: XOR<UserCreateWithoutUpdatedTicketsInput, UserUncheckedCreateWithoutUpdatedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedTicketsInput, UserUncheckedUpdateWithoutUpdatedTicketsInput>
  }

  export type UserUpdateWithoutUpdatedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserPresenceUpsertWithWhereUniqueWithoutCurrentTicketInput = {
    where: UserPresenceWhereUniqueInput
    update: XOR<UserPresenceUpdateWithoutCurrentTicketInput, UserPresenceUncheckedUpdateWithoutCurrentTicketInput>
    create: XOR<UserPresenceCreateWithoutCurrentTicketInput, UserPresenceUncheckedCreateWithoutCurrentTicketInput>
  }

  export type UserPresenceUpdateWithWhereUniqueWithoutCurrentTicketInput = {
    where: UserPresenceWhereUniqueInput
    data: XOR<UserPresenceUpdateWithoutCurrentTicketInput, UserPresenceUncheckedUpdateWithoutCurrentTicketInput>
  }

  export type UserPresenceUpdateManyWithWhereWithoutCurrentTicketInput = {
    where: UserPresenceScalarWhereInput
    data: XOR<UserPresenceUpdateManyMutationInput, UserPresenceUncheckedUpdateManyWithoutCurrentTicketInput>
  }

  export type TicketCreateWithoutAttachmentsInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutAttachmentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutUploadedAttachmentsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUploadedAttachmentsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUploadedAttachmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedAttachmentsInput, UserUncheckedCreateWithoutUploadedAttachmentsInput>
  }

  export type TicketUpsertWithoutAttachmentsInput = {
    update: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TicketCreateWithoutAttachmentsInput, TicketUncheckedCreateWithoutAttachmentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutAttachmentsInput, TicketUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TicketUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type UserUpsertWithoutUploadedAttachmentsInput = {
    update: XOR<UserUpdateWithoutUploadedAttachmentsInput, UserUncheckedUpdateWithoutUploadedAttachmentsInput>
    create: XOR<UserCreateWithoutUploadedAttachmentsInput, UserUncheckedCreateWithoutUploadedAttachmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedAttachmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedAttachmentsInput, UserUncheckedUpdateWithoutUploadedAttachmentsInput>
  }

  export type UserUpdateWithoutUploadedAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type CreditNoteItemCreateWithoutPartInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
    creditNote: CreditNoteCreateNestedOneWithoutItemsInput
  }

  export type CreditNoteItemUncheckedCreateWithoutPartInput = {
    id?: string
    creditNoteId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
  }

  export type CreditNoteItemCreateOrConnectWithoutPartInput = {
    where: CreditNoteItemWhereUniqueInput
    create: XOR<CreditNoteItemCreateWithoutPartInput, CreditNoteItemUncheckedCreateWithoutPartInput>
  }

  export type CreditNoteItemCreateManyPartInputEnvelope = {
    data: CreditNoteItemCreateManyPartInput | CreditNoteItemCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedPartsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreatedPartsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedPartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPartsInput, UserUncheckedCreateWithoutCreatedPartsInput>
  }

  export type POSQuotationItemCreateWithoutPartInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    quotation: POSQuotationCreateNestedOneWithoutItemsInput
  }

  export type POSQuotationItemUncheckedCreateWithoutPartInput = {
    id?: string
    quotationId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemCreateOrConnectWithoutPartInput = {
    where: POSQuotationItemWhereUniqueInput
    create: XOR<POSQuotationItemCreateWithoutPartInput, POSQuotationItemUncheckedCreateWithoutPartInput>
  }

  export type POSQuotationItemCreateManyPartInputEnvelope = {
    data: POSQuotationItemCreateManyPartInput | POSQuotationItemCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type POSSaleItemCreateWithoutPartInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    sale: POSSaleCreateNestedOneWithoutItemsInput
  }

  export type POSSaleItemUncheckedCreateWithoutPartInput = {
    id?: string
    saleId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemCreateOrConnectWithoutPartInput = {
    where: POSSaleItemWhereUniqueInput
    create: XOR<POSSaleItemCreateWithoutPartInput, POSSaleItemUncheckedCreateWithoutPartInput>
  }

  export type POSSaleItemCreateManyPartInputEnvelope = {
    data: POSSaleItemCreateManyPartInput | POSSaleItemCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseItemCreateWithoutPartInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseItemUncheckedCreateWithoutPartInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    purchaseOrderId: string
  }

  export type PurchaseItemCreateOrConnectWithoutPartInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutPartInput, PurchaseItemUncheckedCreateWithoutPartInput>
  }

  export type PurchaseItemCreateManyPartInputEnvelope = {
    data: PurchaseItemCreateManyPartInput | PurchaseItemCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type TemplateDefaultPartCreateWithoutPartInput = {
    id?: string
    quantity?: number
    required?: boolean
    createdAt?: Date | string
    template: ServiceTemplateCreateNestedOneWithoutDefaultPartsInput
  }

  export type TemplateDefaultPartUncheckedCreateWithoutPartInput = {
    id?: string
    quantity?: number
    required?: boolean
    templateId: string
    createdAt?: Date | string
  }

  export type TemplateDefaultPartCreateOrConnectWithoutPartInput = {
    where: TemplateDefaultPartWhereUniqueInput
    create: XOR<TemplateDefaultPartCreateWithoutPartInput, TemplateDefaultPartUncheckedCreateWithoutPartInput>
  }

  export type TemplateDefaultPartCreateManyPartInputEnvelope = {
    data: TemplateDefaultPartCreateManyPartInput | TemplateDefaultPartCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutPartsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPartsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPartsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPartsInput, TenantUncheckedCreateWithoutPartsInput>
  }

  export type UserCreateWithoutUpdatedPartsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUpdatedPartsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedPartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedPartsInput, UserUncheckedCreateWithoutUpdatedPartsInput>
  }

  export type PartUsageCreateWithoutPartInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutPartsUsedInput
  }

  export type PartUsageUncheckedCreateWithoutPartInput = {
    id?: string
    quantity: number
    ticketId: string
    createdAt?: Date | string
  }

  export type PartUsageCreateOrConnectWithoutPartInput = {
    where: PartUsageWhereUniqueInput
    create: XOR<PartUsageCreateWithoutPartInput, PartUsageUncheckedCreateWithoutPartInput>
  }

  export type PartUsageCreateManyPartInputEnvelope = {
    data: PartUsageCreateManyPartInput | PartUsageCreateManyPartInput[]
    skipDuplicates?: boolean
  }

  export type CreditNoteItemUpsertWithWhereUniqueWithoutPartInput = {
    where: CreditNoteItemWhereUniqueInput
    update: XOR<CreditNoteItemUpdateWithoutPartInput, CreditNoteItemUncheckedUpdateWithoutPartInput>
    create: XOR<CreditNoteItemCreateWithoutPartInput, CreditNoteItemUncheckedCreateWithoutPartInput>
  }

  export type CreditNoteItemUpdateWithWhereUniqueWithoutPartInput = {
    where: CreditNoteItemWhereUniqueInput
    data: XOR<CreditNoteItemUpdateWithoutPartInput, CreditNoteItemUncheckedUpdateWithoutPartInput>
  }

  export type CreditNoteItemUpdateManyWithWhereWithoutPartInput = {
    where: CreditNoteItemScalarWhereInput
    data: XOR<CreditNoteItemUpdateManyMutationInput, CreditNoteItemUncheckedUpdateManyWithoutPartInput>
  }

  export type CreditNoteItemScalarWhereInput = {
    AND?: CreditNoteItemScalarWhereInput | CreditNoteItemScalarWhereInput[]
    OR?: CreditNoteItemScalarWhereInput[]
    NOT?: CreditNoteItemScalarWhereInput | CreditNoteItemScalarWhereInput[]
    id?: UuidFilter<"CreditNoteItem"> | string
    creditNoteId?: UuidFilter<"CreditNoteItem"> | string
    partId?: UuidFilter<"CreditNoteItem"> | string
    quantity?: IntFilter<"CreditNoteItem"> | number
    unitPrice?: DecimalFilter<"CreditNoteItem"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"CreditNoteItem"> | string | null
  }

  export type UserUpsertWithoutCreatedPartsInput = {
    update: XOR<UserUpdateWithoutCreatedPartsInput, UserUncheckedUpdateWithoutCreatedPartsInput>
    create: XOR<UserCreateWithoutCreatedPartsInput, UserUncheckedCreateWithoutCreatedPartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPartsInput, UserUncheckedUpdateWithoutCreatedPartsInput>
  }

  export type UserUpdateWithoutCreatedPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type POSQuotationItemUpsertWithWhereUniqueWithoutPartInput = {
    where: POSQuotationItemWhereUniqueInput
    update: XOR<POSQuotationItemUpdateWithoutPartInput, POSQuotationItemUncheckedUpdateWithoutPartInput>
    create: XOR<POSQuotationItemCreateWithoutPartInput, POSQuotationItemUncheckedCreateWithoutPartInput>
  }

  export type POSQuotationItemUpdateWithWhereUniqueWithoutPartInput = {
    where: POSQuotationItemWhereUniqueInput
    data: XOR<POSQuotationItemUpdateWithoutPartInput, POSQuotationItemUncheckedUpdateWithoutPartInput>
  }

  export type POSQuotationItemUpdateManyWithWhereWithoutPartInput = {
    where: POSQuotationItemScalarWhereInput
    data: XOR<POSQuotationItemUpdateManyMutationInput, POSQuotationItemUncheckedUpdateManyWithoutPartInput>
  }

  export type POSQuotationItemScalarWhereInput = {
    AND?: POSQuotationItemScalarWhereInput | POSQuotationItemScalarWhereInput[]
    OR?: POSQuotationItemScalarWhereInput[]
    NOT?: POSQuotationItemScalarWhereInput | POSQuotationItemScalarWhereInput[]
    id?: UuidFilter<"POSQuotationItem"> | string
    quotationId?: UuidFilter<"POSQuotationItem"> | string
    partId?: UuidFilter<"POSQuotationItem"> | string
    quantity?: IntFilter<"POSQuotationItem"> | number
    unitPrice?: DecimalFilter<"POSQuotationItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"POSQuotationItem"> | Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemUpsertWithWhereUniqueWithoutPartInput = {
    where: POSSaleItemWhereUniqueInput
    update: XOR<POSSaleItemUpdateWithoutPartInput, POSSaleItemUncheckedUpdateWithoutPartInput>
    create: XOR<POSSaleItemCreateWithoutPartInput, POSSaleItemUncheckedCreateWithoutPartInput>
  }

  export type POSSaleItemUpdateWithWhereUniqueWithoutPartInput = {
    where: POSSaleItemWhereUniqueInput
    data: XOR<POSSaleItemUpdateWithoutPartInput, POSSaleItemUncheckedUpdateWithoutPartInput>
  }

  export type POSSaleItemUpdateManyWithWhereWithoutPartInput = {
    where: POSSaleItemScalarWhereInput
    data: XOR<POSSaleItemUpdateManyMutationInput, POSSaleItemUncheckedUpdateManyWithoutPartInput>
  }

  export type POSSaleItemScalarWhereInput = {
    AND?: POSSaleItemScalarWhereInput | POSSaleItemScalarWhereInput[]
    OR?: POSSaleItemScalarWhereInput[]
    NOT?: POSSaleItemScalarWhereInput | POSSaleItemScalarWhereInput[]
    id?: UuidFilter<"POSSaleItem"> | string
    saleId?: UuidFilter<"POSSaleItem"> | string
    partId?: UuidFilter<"POSSaleItem"> | string
    quantity?: IntFilter<"POSSaleItem"> | number
    unitPrice?: DecimalFilter<"POSSaleItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"POSSaleItem"> | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutPartInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutPartInput, PurchaseItemUncheckedUpdateWithoutPartInput>
    create: XOR<PurchaseItemCreateWithoutPartInput, PurchaseItemUncheckedCreateWithoutPartInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutPartInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutPartInput, PurchaseItemUncheckedUpdateWithoutPartInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutPartInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutPartInput>
  }

  export type PurchaseItemScalarWhereInput = {
    AND?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    OR?: PurchaseItemScalarWhereInput[]
    NOT?: PurchaseItemScalarWhereInput | PurchaseItemScalarWhereInput[]
    id?: UuidFilter<"PurchaseItem"> | string
    quantity?: IntFilter<"PurchaseItem"> | number
    unitCost?: DecimalFilter<"PurchaseItem"> | Decimal | DecimalJsLike | number | string
    partId?: UuidFilter<"PurchaseItem"> | string
    purchaseOrderId?: UuidFilter<"PurchaseItem"> | string
  }

  export type TemplateDefaultPartUpsertWithWhereUniqueWithoutPartInput = {
    where: TemplateDefaultPartWhereUniqueInput
    update: XOR<TemplateDefaultPartUpdateWithoutPartInput, TemplateDefaultPartUncheckedUpdateWithoutPartInput>
    create: XOR<TemplateDefaultPartCreateWithoutPartInput, TemplateDefaultPartUncheckedCreateWithoutPartInput>
  }

  export type TemplateDefaultPartUpdateWithWhereUniqueWithoutPartInput = {
    where: TemplateDefaultPartWhereUniqueInput
    data: XOR<TemplateDefaultPartUpdateWithoutPartInput, TemplateDefaultPartUncheckedUpdateWithoutPartInput>
  }

  export type TemplateDefaultPartUpdateManyWithWhereWithoutPartInput = {
    where: TemplateDefaultPartScalarWhereInput
    data: XOR<TemplateDefaultPartUpdateManyMutationInput, TemplateDefaultPartUncheckedUpdateManyWithoutPartInput>
  }

  export type TemplateDefaultPartScalarWhereInput = {
    AND?: TemplateDefaultPartScalarWhereInput | TemplateDefaultPartScalarWhereInput[]
    OR?: TemplateDefaultPartScalarWhereInput[]
    NOT?: TemplateDefaultPartScalarWhereInput | TemplateDefaultPartScalarWhereInput[]
    id?: UuidFilter<"TemplateDefaultPart"> | string
    quantity?: IntFilter<"TemplateDefaultPart"> | number
    required?: BoolFilter<"TemplateDefaultPart"> | boolean
    templateId?: UuidFilter<"TemplateDefaultPart"> | string
    partId?: UuidFilter<"TemplateDefaultPart"> | string
    createdAt?: DateTimeFilter<"TemplateDefaultPart"> | Date | string
  }

  export type TenantUpsertWithoutPartsInput = {
    update: XOR<TenantUpdateWithoutPartsInput, TenantUncheckedUpdateWithoutPartsInput>
    create: XOR<TenantCreateWithoutPartsInput, TenantUncheckedCreateWithoutPartsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPartsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPartsInput, TenantUncheckedUpdateWithoutPartsInput>
  }

  export type TenantUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutUpdatedPartsInput = {
    update: XOR<UserUpdateWithoutUpdatedPartsInput, UserUncheckedUpdateWithoutUpdatedPartsInput>
    create: XOR<UserCreateWithoutUpdatedPartsInput, UserUncheckedCreateWithoutUpdatedPartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedPartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedPartsInput, UserUncheckedUpdateWithoutUpdatedPartsInput>
  }

  export type UserUpdateWithoutUpdatedPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type PartUsageUpsertWithWhereUniqueWithoutPartInput = {
    where: PartUsageWhereUniqueInput
    update: XOR<PartUsageUpdateWithoutPartInput, PartUsageUncheckedUpdateWithoutPartInput>
    create: XOR<PartUsageCreateWithoutPartInput, PartUsageUncheckedCreateWithoutPartInput>
  }

  export type PartUsageUpdateWithWhereUniqueWithoutPartInput = {
    where: PartUsageWhereUniqueInput
    data: XOR<PartUsageUpdateWithoutPartInput, PartUsageUncheckedUpdateWithoutPartInput>
  }

  export type PartUsageUpdateManyWithWhereWithoutPartInput = {
    where: PartUsageScalarWhereInput
    data: XOR<PartUsageUpdateManyMutationInput, PartUsageUncheckedUpdateManyWithoutPartInput>
  }

  export type PurchaseItemCreateWithoutPurchaseOrderInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    part: PartCreateNestedOneWithoutPurchaseItemsInput
  }

  export type PurchaseItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    partId: string
  }

  export type PurchaseItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseItemWhereUniqueInput
    create: XOR<PurchaseItemCreateWithoutPurchaseOrderInput, PurchaseItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseItemCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseItemCreateManyPurchaseOrderInput | PurchaseItemCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPurchaseOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type PurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseItemWhereUniqueInput
    update: XOR<PurchaseItemUpdateWithoutPurchaseOrderInput, PurchaseItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseItemCreateWithoutPurchaseOrderInput, PurchaseItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseItemWhereUniqueInput
    data: XOR<PurchaseItemUpdateWithoutPurchaseOrderInput, PurchaseItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseItemScalarWhereInput
    data: XOR<PurchaseItemUpdateManyMutationInput, PurchaseItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type TenantUpsertWithoutPurchaseOrdersInput = {
    update: XOR<TenantUpdateWithoutPurchaseOrdersInput, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPurchaseOrdersInput, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type TenantUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PartCreateWithoutPurchaseItemsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutPurchaseItemsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutPurchaseItemsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutPurchaseItemsInput, PartUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    id?: string
    supplier: string
    status?: $Enums.PurchaseStatus
    orderDate?: Date | string
    receivedDate?: Date | string | null
    totalCost?: Decimal | DecimalJsLike | number | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    supplier: string
    status?: $Enums.PurchaseStatus
    orderDate?: Date | string
    receivedDate?: Date | string | null
    totalCost?: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type PartUpsertWithoutPurchaseItemsInput = {
    update: XOR<PartUpdateWithoutPurchaseItemsInput, PartUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<PartCreateWithoutPurchaseItemsInput, PartUncheckedCreateWithoutPurchaseItemsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutPurchaseItemsInput, PartUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type PartUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartCreateWithoutUsagesInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
  }

  export type PartUncheckedCreateWithoutUsagesInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutUsagesInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutUsagesInput, PartUncheckedCreateWithoutUsagesInput>
  }

  export type TicketCreateWithoutPartsUsedInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutPartsUsedInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutPartsUsedInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutPartsUsedInput, TicketUncheckedCreateWithoutPartsUsedInput>
  }

  export type PartUpsertWithoutUsagesInput = {
    update: XOR<PartUpdateWithoutUsagesInput, PartUncheckedUpdateWithoutUsagesInput>
    create: XOR<PartCreateWithoutUsagesInput, PartUncheckedCreateWithoutUsagesInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutUsagesInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutUsagesInput, PartUncheckedUpdateWithoutUsagesInput>
  }

  export type PartUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
  }

  export type PartUncheckedUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
  }

  export type TicketUpsertWithoutPartsUsedInput = {
    update: XOR<TicketUpdateWithoutPartsUsedInput, TicketUncheckedUpdateWithoutPartsUsedInput>
    create: XOR<TicketCreateWithoutPartsUsedInput, TicketUncheckedCreateWithoutPartsUsedInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutPartsUsedInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutPartsUsedInput, TicketUncheckedUpdateWithoutPartsUsedInput>
  }

  export type TicketUpdateWithoutPartsUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutPartsUsedInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutTicketNotesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTicketNotesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutTicketNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketNotesInput, UserUncheckedCreateWithoutTicketNotesInput>
  }

  export type TicketCreateWithoutNotesInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutNotesInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutNotesInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutNotesInput, TicketUncheckedCreateWithoutNotesInput>
  }

  export type UserUpsertWithoutTicketNotesInput = {
    update: XOR<UserUpdateWithoutTicketNotesInput, UserUncheckedUpdateWithoutTicketNotesInput>
    create: XOR<UserCreateWithoutTicketNotesInput, UserUncheckedCreateWithoutTicketNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketNotesInput, UserUncheckedUpdateWithoutTicketNotesInput>
  }

  export type UserUpdateWithoutTicketNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TicketUpsertWithoutNotesInput = {
    update: XOR<TicketUpdateWithoutNotesInput, TicketUncheckedUpdateWithoutNotesInput>
    create: XOR<TicketCreateWithoutNotesInput, TicketUncheckedCreateWithoutNotesInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutNotesInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutNotesInput, TicketUncheckedUpdateWithoutNotesInput>
  }

  export type TicketUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type UserCreateWithoutCreatedTemplatesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreatedTemplatesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
  }

  export type TenantCreateWithoutServiceTemplatesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutServiceTemplatesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutServiceTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutServiceTemplatesInput, TenantUncheckedCreateWithoutServiceTemplatesInput>
  }

  export type UserCreateWithoutUpdatedTemplatesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUpdatedTemplatesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedTemplatesInput, UserUncheckedCreateWithoutUpdatedTemplatesInput>
  }

  export type TemplateDefaultPartCreateWithoutTemplateInput = {
    id?: string
    quantity?: number
    required?: boolean
    createdAt?: Date | string
    part: PartCreateNestedOneWithoutTemplateDefaultPartsInput
  }

  export type TemplateDefaultPartUncheckedCreateWithoutTemplateInput = {
    id?: string
    quantity?: number
    required?: boolean
    partId: string
    createdAt?: Date | string
  }

  export type TemplateDefaultPartCreateOrConnectWithoutTemplateInput = {
    where: TemplateDefaultPartWhereUniqueInput
    create: XOR<TemplateDefaultPartCreateWithoutTemplateInput, TemplateDefaultPartUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateDefaultPartCreateManyTemplateInputEnvelope = {
    data: TemplateDefaultPartCreateManyTemplateInput | TemplateDefaultPartCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TicketServiceCreateWithoutServiceInput = {
    id?: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutServicesInput
  }

  export type TicketServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    ticketId: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TicketServiceCreateOrConnectWithoutServiceInput = {
    where: TicketServiceWhereUniqueInput
    create: XOR<TicketServiceCreateWithoutServiceInput, TicketServiceUncheckedCreateWithoutServiceInput>
  }

  export type TicketServiceCreateManyServiceInputEnvelope = {
    data: TicketServiceCreateManyServiceInput | TicketServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutServiceTemplateInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutServiceTemplateInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutServiceTemplateInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutServiceTemplateInput, TicketUncheckedCreateWithoutServiceTemplateInput>
  }

  export type TicketCreateManyServiceTemplateInputEnvelope = {
    data: TicketCreateManyServiceTemplateInput | TicketCreateManyServiceTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedTemplatesInput = {
    update: XOR<UserUpdateWithoutCreatedTemplatesInput, UserUncheckedUpdateWithoutCreatedTemplatesInput>
    create: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTemplatesInput, UserUncheckedUpdateWithoutCreatedTemplatesInput>
  }

  export type UserUpdateWithoutCreatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TenantUpsertWithoutServiceTemplatesInput = {
    update: XOR<TenantUpdateWithoutServiceTemplatesInput, TenantUncheckedUpdateWithoutServiceTemplatesInput>
    create: XOR<TenantCreateWithoutServiceTemplatesInput, TenantUncheckedCreateWithoutServiceTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutServiceTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutServiceTemplatesInput, TenantUncheckedUpdateWithoutServiceTemplatesInput>
  }

  export type TenantUpdateWithoutServiceTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutServiceTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutUpdatedTemplatesInput = {
    update: XOR<UserUpdateWithoutUpdatedTemplatesInput, UserUncheckedUpdateWithoutUpdatedTemplatesInput>
    create: XOR<UserCreateWithoutUpdatedTemplatesInput, UserUncheckedCreateWithoutUpdatedTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedTemplatesInput, UserUncheckedUpdateWithoutUpdatedTemplatesInput>
  }

  export type UserUpdateWithoutUpdatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TemplateDefaultPartUpsertWithWhereUniqueWithoutTemplateInput = {
    where: TemplateDefaultPartWhereUniqueInput
    update: XOR<TemplateDefaultPartUpdateWithoutTemplateInput, TemplateDefaultPartUncheckedUpdateWithoutTemplateInput>
    create: XOR<TemplateDefaultPartCreateWithoutTemplateInput, TemplateDefaultPartUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateDefaultPartUpdateWithWhereUniqueWithoutTemplateInput = {
    where: TemplateDefaultPartWhereUniqueInput
    data: XOR<TemplateDefaultPartUpdateWithoutTemplateInput, TemplateDefaultPartUncheckedUpdateWithoutTemplateInput>
  }

  export type TemplateDefaultPartUpdateManyWithWhereWithoutTemplateInput = {
    where: TemplateDefaultPartScalarWhereInput
    data: XOR<TemplateDefaultPartUpdateManyMutationInput, TemplateDefaultPartUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TicketServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: TicketServiceWhereUniqueInput
    update: XOR<TicketServiceUpdateWithoutServiceInput, TicketServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<TicketServiceCreateWithoutServiceInput, TicketServiceUncheckedCreateWithoutServiceInput>
  }

  export type TicketServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: TicketServiceWhereUniqueInput
    data: XOR<TicketServiceUpdateWithoutServiceInput, TicketServiceUncheckedUpdateWithoutServiceInput>
  }

  export type TicketServiceUpdateManyWithWhereWithoutServiceInput = {
    where: TicketServiceScalarWhereInput
    data: XOR<TicketServiceUpdateManyMutationInput, TicketServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutServiceTemplateInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutServiceTemplateInput, TicketUncheckedUpdateWithoutServiceTemplateInput>
    create: XOR<TicketCreateWithoutServiceTemplateInput, TicketUncheckedCreateWithoutServiceTemplateInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutServiceTemplateInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutServiceTemplateInput, TicketUncheckedUpdateWithoutServiceTemplateInput>
  }

  export type TicketUpdateManyWithWhereWithoutServiceTemplateInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutServiceTemplateInput>
  }

  export type PartCreateWithoutTemplateDefaultPartsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutTemplateDefaultPartsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutTemplateDefaultPartsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutTemplateDefaultPartsInput, PartUncheckedCreateWithoutTemplateDefaultPartsInput>
  }

  export type ServiceTemplateCreateWithoutDefaultPartsInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedTemplatesInput
    tenant: TenantCreateNestedOneWithoutServiceTemplatesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTemplatesInput
    usages?: TicketServiceCreateNestedManyWithoutServiceInput
    tickets?: TicketCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateUncheckedCreateWithoutDefaultPartsInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: TicketServiceUncheckedCreateNestedManyWithoutServiceInput
    tickets?: TicketUncheckedCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateCreateOrConnectWithoutDefaultPartsInput = {
    where: ServiceTemplateWhereUniqueInput
    create: XOR<ServiceTemplateCreateWithoutDefaultPartsInput, ServiceTemplateUncheckedCreateWithoutDefaultPartsInput>
  }

  export type PartUpsertWithoutTemplateDefaultPartsInput = {
    update: XOR<PartUpdateWithoutTemplateDefaultPartsInput, PartUncheckedUpdateWithoutTemplateDefaultPartsInput>
    create: XOR<PartCreateWithoutTemplateDefaultPartsInput, PartUncheckedCreateWithoutTemplateDefaultPartsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutTemplateDefaultPartsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutTemplateDefaultPartsInput, PartUncheckedUpdateWithoutTemplateDefaultPartsInput>
  }

  export type PartUpdateWithoutTemplateDefaultPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutTemplateDefaultPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type ServiceTemplateUpsertWithoutDefaultPartsInput = {
    update: XOR<ServiceTemplateUpdateWithoutDefaultPartsInput, ServiceTemplateUncheckedUpdateWithoutDefaultPartsInput>
    create: XOR<ServiceTemplateCreateWithoutDefaultPartsInput, ServiceTemplateUncheckedCreateWithoutDefaultPartsInput>
    where?: ServiceTemplateWhereInput
  }

  export type ServiceTemplateUpdateToOneWithWhereWithoutDefaultPartsInput = {
    where?: ServiceTemplateWhereInput
    data: XOR<ServiceTemplateUpdateWithoutDefaultPartsInput, ServiceTemplateUncheckedUpdateWithoutDefaultPartsInput>
  }

  export type ServiceTemplateUpdateWithoutDefaultPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedTemplatesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutServiceTemplatesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTemplatesNestedInput
    usages?: TicketServiceUpdateManyWithoutServiceNestedInput
    tickets?: TicketUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateWithoutDefaultPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: TicketServiceUncheckedUpdateManyWithoutServiceNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateCreateWithoutUsagesInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedTemplatesInput
    tenant: TenantCreateNestedOneWithoutServiceTemplatesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTemplatesInput
    defaultParts?: TemplateDefaultPartCreateNestedManyWithoutTemplateInput
    tickets?: TicketCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateUncheckedCreateWithoutUsagesInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutTemplateInput
    tickets?: TicketUncheckedCreateNestedManyWithoutServiceTemplateInput
  }

  export type ServiceTemplateCreateOrConnectWithoutUsagesInput = {
    where: ServiceTemplateWhereUniqueInput
    create: XOR<ServiceTemplateCreateWithoutUsagesInput, ServiceTemplateUncheckedCreateWithoutUsagesInput>
  }

  export type TicketCreateWithoutServicesInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutServicesInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutServicesInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutServicesInput, TicketUncheckedCreateWithoutServicesInput>
  }

  export type ServiceTemplateUpsertWithoutUsagesInput = {
    update: XOR<ServiceTemplateUpdateWithoutUsagesInput, ServiceTemplateUncheckedUpdateWithoutUsagesInput>
    create: XOR<ServiceTemplateCreateWithoutUsagesInput, ServiceTemplateUncheckedCreateWithoutUsagesInput>
    where?: ServiceTemplateWhereInput
  }

  export type ServiceTemplateUpdateToOneWithWhereWithoutUsagesInput = {
    where?: ServiceTemplateWhereInput
    data: XOR<ServiceTemplateUpdateWithoutUsagesInput, ServiceTemplateUncheckedUpdateWithoutUsagesInput>
  }

  export type ServiceTemplateUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedTemplatesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutServiceTemplatesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTemplatesNestedInput
    defaultParts?: TemplateDefaultPartUpdateManyWithoutTemplateNestedInput
    tickets?: TicketUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutTemplateNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutServiceTemplateNestedInput
  }

  export type TicketUpsertWithoutServicesInput = {
    update: XOR<TicketUpdateWithoutServicesInput, TicketUncheckedUpdateWithoutServicesInput>
    create: XOR<TicketCreateWithoutServicesInput, TicketUncheckedCreateWithoutServicesInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutServicesInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutServicesInput, TicketUncheckedUpdateWithoutServicesInput>
  }

  export type TicketUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type UserCreateWithoutSpecializationsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSpecializationsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutSpecializationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpecializationsInput, UserUncheckedCreateWithoutSpecializationsInput>
  }

  export type UserUpsertWithoutSpecializationsInput = {
    update: XOR<UserUpdateWithoutSpecializationsInput, UserUncheckedUpdateWithoutSpecializationsInput>
    create: XOR<UserCreateWithoutSpecializationsInput, UserUncheckedCreateWithoutSpecializationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpecializationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpecializationsInput, UserUncheckedUpdateWithoutSpecializationsInput>
  }

  export type UserUpdateWithoutSpecializationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSpecializationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutUnavailabilitiesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUnavailabilitiesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUnavailabilitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUnavailabilitiesInput, UserUncheckedCreateWithoutUnavailabilitiesInput>
  }

  export type UserUpsertWithoutUnavailabilitiesInput = {
    update: XOR<UserUpdateWithoutUnavailabilitiesInput, UserUncheckedUpdateWithoutUnavailabilitiesInput>
    create: XOR<UserCreateWithoutUnavailabilitiesInput, UserUncheckedCreateWithoutUnavailabilitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUnavailabilitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUnavailabilitiesInput, UserUncheckedUpdateWithoutUnavailabilitiesInput>
  }

  export type UserUpdateWithoutUnavailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUnavailabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TenantCreateWithoutNotificationsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type TenantUpsertWithoutNotificationsInput = {
    update: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutCreatedInvoicesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreatedInvoicesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreatedInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
  }

  export type CustomerCreateWithoutInvoicesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedCustomersInput
    creditNotes?: CreditNoteCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCustomerInput
    tenant: TenantCreateNestedOneWithoutCustomersInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedCustomersInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCustomerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceHistoryCreateWithoutInvoiceInput = {
    id?: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInvoiceHistoryInput
  }

  export type InvoiceHistoryUncheckedCreateWithoutInvoiceInput = {
    id?: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type InvoiceHistoryCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceHistoryWhereUniqueInput
    create: XOR<InvoiceHistoryCreateWithoutInvoiceInput, InvoiceHistoryUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceHistoryCreateManyInvoiceInputEnvelope = {
    data: InvoiceHistoryCreateManyInvoiceInput | InvoiceHistoryCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    paymentNumber: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    receivedBy: UserCreateNestedOneWithoutReceivedPaymentsInput
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    paymentNumber: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    tenantId: string
    receivedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutInvoicesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
  }

  export type TicketCreateWithoutInvoiceInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
    viewedByUsers?: UserPresenceCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketUncheckedCreateWithoutInvoiceInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
    viewedByUsers?: UserPresenceUncheckedCreateNestedManyWithoutCurrentTicketInput
  }

  export type TicketCreateOrConnectWithoutInvoiceInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutInvoiceInput, TicketUncheckedCreateWithoutInvoiceInput>
  }

  export type UserCreateWithoutUpdatedInvoicesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUpdatedInvoicesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedInvoicesInput, UserUncheckedCreateWithoutUpdatedInvoicesInput>
  }

  export type UserUpsertWithoutCreatedInvoicesInput = {
    update: XOR<UserUpdateWithoutCreatedInvoicesInput, UserUncheckedUpdateWithoutCreatedInvoicesInput>
    create: XOR<UserCreateWithoutCreatedInvoicesInput, UserUncheckedCreateWithoutCreatedInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedInvoicesInput, UserUncheckedUpdateWithoutCreatedInvoicesInput>
  }

  export type UserUpdateWithoutCreatedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedCustomersNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCustomerNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type InvoiceHistoryUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceHistoryWhereUniqueInput
    update: XOR<InvoiceHistoryUpdateWithoutInvoiceInput, InvoiceHistoryUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceHistoryCreateWithoutInvoiceInput, InvoiceHistoryUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceHistoryUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceHistoryWhereUniqueInput
    data: XOR<InvoiceHistoryUpdateWithoutInvoiceInput, InvoiceHistoryUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceHistoryUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceHistoryScalarWhereInput
    data: XOR<InvoiceHistoryUpdateManyMutationInput, InvoiceHistoryUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type TenantUpsertWithoutInvoicesInput = {
    update: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TicketUpsertWithoutInvoiceInput = {
    update: XOR<TicketUpdateWithoutInvoiceInput, TicketUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TicketCreateWithoutInvoiceInput, TicketUncheckedCreateWithoutInvoiceInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutInvoiceInput, TicketUncheckedUpdateWithoutInvoiceInput>
  }

  export type TicketUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type UserUpsertWithoutUpdatedInvoicesInput = {
    update: XOR<UserUpdateWithoutUpdatedInvoicesInput, UserUncheckedUpdateWithoutUpdatedInvoicesInput>
    create: XOR<UserCreateWithoutUpdatedInvoicesInput, UserUncheckedCreateWithoutUpdatedInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedInvoicesInput, UserUncheckedUpdateWithoutUpdatedInvoicesInput>
  }

  export type UserUpdateWithoutUpdatedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    history?: InvoiceHistoryCreateNestedManyWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    ticket: TicketCreateNestedOneWithoutInvoiceInput
    updatedBy: UserCreateNestedOneWithoutUpdatedInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: InvoiceHistoryUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutReceivedPaymentsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutReceivedPaymentsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutReceivedPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedPaymentsInput, UserUncheckedCreateWithoutReceivedPaymentsInput>
  }

  export type TenantCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    history?: InvoiceHistoryUpdateManyWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutInvoiceNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: InvoiceHistoryUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutReceivedPaymentsInput = {
    update: XOR<UserUpdateWithoutReceivedPaymentsInput, UserUncheckedUpdateWithoutReceivedPaymentsInput>
    create: XOR<UserCreateWithoutReceivedPaymentsInput, UserUncheckedCreateWithoutReceivedPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedPaymentsInput, UserUncheckedUpdateWithoutReceivedPaymentsInput>
  }

  export type UserUpdateWithoutReceivedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TenantUpsertWithoutPaymentsInput = {
    update: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateWithoutClosedCashRegistersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutClosedCashRegistersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutClosedCashRegistersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClosedCashRegistersInput, UserUncheckedCreateWithoutClosedCashRegistersInput>
  }

  export type UserCreateWithoutOpenedCashRegistersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutOpenedCashRegistersInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutOpenedCashRegistersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOpenedCashRegistersInput, UserUncheckedCreateWithoutOpenedCashRegistersInput>
  }

  export type POSSaleCreateWithoutCashRegisterInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPosSalesInput
    creditNotes?: CreditNoteCreateNestedManyWithoutPosSaleInput
    customer?: CustomerCreateNestedOneWithoutPosSalesInput
    items?: POSSaleItemCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentCreateNestedManyWithoutSaleInput
    quotation?: POSQuotationCreateNestedOneWithoutConvertedToSaleInput
    tenant: TenantCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateWithoutCashRegisterInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput
    items?: POSSaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleCreateOrConnectWithoutCashRegisterInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutCashRegisterInput, POSSaleUncheckedCreateWithoutCashRegisterInput>
  }

  export type POSSaleCreateManyCashRegisterInputEnvelope = {
    data: POSSaleCreateManyCashRegisterInput | POSSaleCreateManyCashRegisterInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutCashRegistersInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCashRegistersInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCashRegistersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCashRegistersInput, TenantUncheckedCreateWithoutCashRegistersInput>
  }

  export type CashTransactionCreateWithoutCashRegisterInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCashTransactionsInput
    tenant: TenantCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateWithoutCashRegisterInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
  }

  export type CashTransactionCreateOrConnectWithoutCashRegisterInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutCashRegisterInput, CashTransactionUncheckedCreateWithoutCashRegisterInput>
  }

  export type CashTransactionCreateManyCashRegisterInputEnvelope = {
    data: CashTransactionCreateManyCashRegisterInput | CashTransactionCreateManyCashRegisterInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClosedCashRegistersInput = {
    update: XOR<UserUpdateWithoutClosedCashRegistersInput, UserUncheckedUpdateWithoutClosedCashRegistersInput>
    create: XOR<UserCreateWithoutClosedCashRegistersInput, UserUncheckedCreateWithoutClosedCashRegistersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClosedCashRegistersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClosedCashRegistersInput, UserUncheckedUpdateWithoutClosedCashRegistersInput>
  }

  export type UserUpdateWithoutClosedCashRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutClosedCashRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutOpenedCashRegistersInput = {
    update: XOR<UserUpdateWithoutOpenedCashRegistersInput, UserUncheckedUpdateWithoutOpenedCashRegistersInput>
    create: XOR<UserCreateWithoutOpenedCashRegistersInput, UserUncheckedCreateWithoutOpenedCashRegistersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOpenedCashRegistersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOpenedCashRegistersInput, UserUncheckedUpdateWithoutOpenedCashRegistersInput>
  }

  export type UserUpdateWithoutOpenedCashRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutOpenedCashRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type POSSaleUpsertWithWhereUniqueWithoutCashRegisterInput = {
    where: POSSaleWhereUniqueInput
    update: XOR<POSSaleUpdateWithoutCashRegisterInput, POSSaleUncheckedUpdateWithoutCashRegisterInput>
    create: XOR<POSSaleCreateWithoutCashRegisterInput, POSSaleUncheckedCreateWithoutCashRegisterInput>
  }

  export type POSSaleUpdateWithWhereUniqueWithoutCashRegisterInput = {
    where: POSSaleWhereUniqueInput
    data: XOR<POSSaleUpdateWithoutCashRegisterInput, POSSaleUncheckedUpdateWithoutCashRegisterInput>
  }

  export type POSSaleUpdateManyWithWhereWithoutCashRegisterInput = {
    where: POSSaleScalarWhereInput
    data: XOR<POSSaleUpdateManyMutationInput, POSSaleUncheckedUpdateManyWithoutCashRegisterInput>
  }

  export type TenantUpsertWithoutCashRegistersInput = {
    update: XOR<TenantUpdateWithoutCashRegistersInput, TenantUncheckedUpdateWithoutCashRegistersInput>
    create: XOR<TenantCreateWithoutCashRegistersInput, TenantUncheckedCreateWithoutCashRegistersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCashRegistersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCashRegistersInput, TenantUncheckedUpdateWithoutCashRegistersInput>
  }

  export type TenantUpdateWithoutCashRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCashRegistersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutCashRegisterInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutCashRegisterInput, CashTransactionUncheckedUpdateWithoutCashRegisterInput>
    create: XOR<CashTransactionCreateWithoutCashRegisterInput, CashTransactionUncheckedCreateWithoutCashRegisterInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutCashRegisterInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutCashRegisterInput, CashTransactionUncheckedUpdateWithoutCashRegisterInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutCashRegisterInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutCashRegisterInput>
  }

  export type CashRegisterCreateWithoutTransactionsInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedBy?: UserCreateNestedOneWithoutClosedCashRegistersInput
    openedBy?: UserCreateNestedOneWithoutOpenedCashRegistersInput
    posSales?: POSSaleCreateNestedManyWithoutCashRegisterInput
    tenant: TenantCreateNestedOneWithoutCashRegistersInput
  }

  export type CashRegisterUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    tenantId: string
    openedById?: string | null
    closedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutTransactionsInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutTransactionsInput, CashRegisterUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutCashTransactionsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCashTransactionsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCashTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
  }

  export type TenantCreateWithoutCashTransactionsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCashTransactionsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCashTransactionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCashTransactionsInput, TenantUncheckedCreateWithoutCashTransactionsInput>
  }

  export type CashRegisterUpsertWithoutTransactionsInput = {
    update: XOR<CashRegisterUpdateWithoutTransactionsInput, CashRegisterUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CashRegisterCreateWithoutTransactionsInput, CashRegisterUncheckedCreateWithoutTransactionsInput>
    where?: CashRegisterWhereInput
  }

  export type CashRegisterUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CashRegisterWhereInput
    data: XOR<CashRegisterUpdateWithoutTransactionsInput, CashRegisterUncheckedUpdateWithoutTransactionsInput>
  }

  export type CashRegisterUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedBy?: UserUpdateOneWithoutClosedCashRegistersNestedInput
    openedBy?: UserUpdateOneWithoutOpenedCashRegistersNestedInput
    posSales?: POSSaleUpdateManyWithoutCashRegisterNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashRegistersNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    openedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posSales?: POSSaleUncheckedUpdateManyWithoutCashRegisterNestedInput
  }

  export type UserUpsertWithoutCashTransactionsInput = {
    update: XOR<UserUpdateWithoutCashTransactionsInput, UserUncheckedUpdateWithoutCashTransactionsInput>
    create: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashTransactionsInput, UserUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type UserUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TenantUpsertWithoutCashTransactionsInput = {
    update: XOR<TenantUpdateWithoutCashTransactionsInput, TenantUncheckedUpdateWithoutCashTransactionsInput>
    create: XOR<TenantCreateWithoutCashTransactionsInput, TenantUncheckedCreateWithoutCashTransactionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCashTransactionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCashTransactionsInput, TenantUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type TenantUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutSettingsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSettingsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSettingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSettingsInput, TenantUncheckedCreateWithoutSettingsInput>
  }

  export type TenantUpsertWithoutSettingsInput = {
    update: XOR<TenantUpdateWithoutSettingsInput, TenantUncheckedUpdateWithoutSettingsInput>
    create: XOR<TenantCreateWithoutSettingsInput, TenantUncheckedCreateWithoutSettingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSettingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSettingsInput, TenantUncheckedUpdateWithoutSettingsInput>
  }

  export type TenantUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceCreateWithoutHistoryInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    ticket: TicketCreateNestedOneWithoutInvoiceInput
    updatedBy: UserCreateNestedOneWithoutUpdatedInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutHistoryInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutHistoryInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutHistoryInput, InvoiceUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutInvoiceHistoryInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutInvoiceHistoryInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutInvoiceHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoiceHistoryInput, UserUncheckedCreateWithoutInvoiceHistoryInput>
  }

  export type InvoiceUpsertWithoutHistoryInput = {
    update: XOR<InvoiceUpdateWithoutHistoryInput, InvoiceUncheckedUpdateWithoutHistoryInput>
    create: XOR<InvoiceCreateWithoutHistoryInput, InvoiceUncheckedCreateWithoutHistoryInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutHistoryInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutHistoryInput, InvoiceUncheckedUpdateWithoutHistoryInput>
  }

  export type InvoiceUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutInvoiceNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutInvoiceHistoryInput = {
    update: XOR<UserUpdateWithoutInvoiceHistoryInput, UserUncheckedUpdateWithoutInvoiceHistoryInput>
    create: XOR<UserCreateWithoutInvoiceHistoryInput, UserUncheckedCreateWithoutInvoiceHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoiceHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoiceHistoryInput, UserUncheckedUpdateWithoutInvoiceHistoryInput>
  }

  export type UserUpdateWithoutInvoiceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoiceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type CashRegisterCreateWithoutPosSalesInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedBy?: UserCreateNestedOneWithoutClosedCashRegistersInput
    openedBy?: UserCreateNestedOneWithoutOpenedCashRegistersInput
    tenant: TenantCreateNestedOneWithoutCashRegistersInput
    transactions?: CashTransactionCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterUncheckedCreateWithoutPosSalesInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    tenantId: string
    openedById?: string | null
    closedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: CashTransactionUncheckedCreateNestedManyWithoutCashRegisterInput
  }

  export type CashRegisterCreateOrConnectWithoutPosSalesInput = {
    where: CashRegisterWhereUniqueInput
    create: XOR<CashRegisterCreateWithoutPosSalesInput, CashRegisterUncheckedCreateWithoutPosSalesInput>
  }

  export type UserCreateWithoutPosSalesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPosSalesInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutPosSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPosSalesInput, UserUncheckedCreateWithoutPosSalesInput>
  }

  export type CreditNoteCreateWithoutPosSaleInput = {
    id?: string
    creditNoteNumber: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreditNotesCreatedInput
    processedBy?: UserCreateNestedOneWithoutCreditNotesProcessedInput
    customer?: CustomerCreateNestedOneWithoutCreditNotesInput
    items?: CreditNoteItemCreateNestedManyWithoutCreditNoteInput
    tenant: TenantCreateNestedOneWithoutCreditNotesInput
  }

  export type CreditNoteUncheckedCreateWithoutPosSaleInput = {
    id?: string
    creditNoteNumber: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CreditNoteItemUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type CreditNoteCreateOrConnectWithoutPosSaleInput = {
    where: CreditNoteWhereUniqueInput
    create: XOR<CreditNoteCreateWithoutPosSaleInput, CreditNoteUncheckedCreateWithoutPosSaleInput>
  }

  export type CreditNoteCreateManyPosSaleInputEnvelope = {
    data: CreditNoteCreateManyPosSaleInput | CreditNoteCreateManyPosSaleInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutPosSalesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedCustomersInput
    creditNotes?: CreditNoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCustomerInput
    tenant: TenantCreateNestedOneWithoutCustomersInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedCustomersInput
  }

  export type CustomerUncheckedCreateWithoutPosSalesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCustomerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPosSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPosSalesInput, CustomerUncheckedCreateWithoutPosSalesInput>
  }

  export type POSSaleItemCreateWithoutSaleInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    part: PartCreateNestedOneWithoutPosSaleItemsInput
  }

  export type POSSaleItemUncheckedCreateWithoutSaleInput = {
    id?: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemCreateOrConnectWithoutSaleInput = {
    where: POSSaleItemWhereUniqueInput
    create: XOR<POSSaleItemCreateWithoutSaleInput, POSSaleItemUncheckedCreateWithoutSaleInput>
  }

  export type POSSaleItemCreateManySaleInputEnvelope = {
    data: POSSaleItemCreateManySaleInput | POSSaleItemCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type POSSalePaymentCreateWithoutSaleInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    reference?: string | null
    createdAt?: Date | string
  }

  export type POSSalePaymentUncheckedCreateWithoutSaleInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    reference?: string | null
    createdAt?: Date | string
  }

  export type POSSalePaymentCreateOrConnectWithoutSaleInput = {
    where: POSSalePaymentWhereUniqueInput
    create: XOR<POSSalePaymentCreateWithoutSaleInput, POSSalePaymentUncheckedCreateWithoutSaleInput>
  }

  export type POSSalePaymentCreateManySaleInputEnvelope = {
    data: POSSalePaymentCreateManySaleInput | POSSalePaymentCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type POSQuotationCreateWithoutConvertedToSaleInput = {
    id?: string
    quotationNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPosQuotationsInput
    customer?: CustomerCreateNestedOneWithoutPosQuotationsInput
    items?: POSQuotationItemCreateNestedManyWithoutQuotationInput
    tenant: TenantCreateNestedOneWithoutPosQuotationsInput
  }

  export type POSQuotationUncheckedCreateWithoutConvertedToSaleInput = {
    id?: string
    quotationNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: POSQuotationItemUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type POSQuotationCreateOrConnectWithoutConvertedToSaleInput = {
    where: POSQuotationWhereUniqueInput
    create: XOR<POSQuotationCreateWithoutConvertedToSaleInput, POSQuotationUncheckedCreateWithoutConvertedToSaleInput>
  }

  export type TenantCreateWithoutPosSalesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPosSalesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPosSalesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPosSalesInput, TenantUncheckedCreateWithoutPosSalesInput>
  }

  export type CashRegisterUpsertWithoutPosSalesInput = {
    update: XOR<CashRegisterUpdateWithoutPosSalesInput, CashRegisterUncheckedUpdateWithoutPosSalesInput>
    create: XOR<CashRegisterCreateWithoutPosSalesInput, CashRegisterUncheckedCreateWithoutPosSalesInput>
    where?: CashRegisterWhereInput
  }

  export type CashRegisterUpdateToOneWithWhereWithoutPosSalesInput = {
    where?: CashRegisterWhereInput
    data: XOR<CashRegisterUpdateWithoutPosSalesInput, CashRegisterUncheckedUpdateWithoutPosSalesInput>
  }

  export type CashRegisterUpdateWithoutPosSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedBy?: UserUpdateOneWithoutClosedCashRegistersNestedInput
    openedBy?: UserUpdateOneWithoutOpenedCashRegistersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashRegistersNestedInput
    transactions?: CashTransactionUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutPosSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    openedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CashTransactionUncheckedUpdateManyWithoutCashRegisterNestedInput
  }

  export type UserUpsertWithoutPosSalesInput = {
    update: XOR<UserUpdateWithoutPosSalesInput, UserUncheckedUpdateWithoutPosSalesInput>
    create: XOR<UserCreateWithoutPosSalesInput, UserUncheckedCreateWithoutPosSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPosSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPosSalesInput, UserUncheckedUpdateWithoutPosSalesInput>
  }

  export type UserUpdateWithoutPosSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPosSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type CreditNoteUpsertWithWhereUniqueWithoutPosSaleInput = {
    where: CreditNoteWhereUniqueInput
    update: XOR<CreditNoteUpdateWithoutPosSaleInput, CreditNoteUncheckedUpdateWithoutPosSaleInput>
    create: XOR<CreditNoteCreateWithoutPosSaleInput, CreditNoteUncheckedCreateWithoutPosSaleInput>
  }

  export type CreditNoteUpdateWithWhereUniqueWithoutPosSaleInput = {
    where: CreditNoteWhereUniqueInput
    data: XOR<CreditNoteUpdateWithoutPosSaleInput, CreditNoteUncheckedUpdateWithoutPosSaleInput>
  }

  export type CreditNoteUpdateManyWithWhereWithoutPosSaleInput = {
    where: CreditNoteScalarWhereInput
    data: XOR<CreditNoteUpdateManyMutationInput, CreditNoteUncheckedUpdateManyWithoutPosSaleInput>
  }

  export type CustomerUpsertWithoutPosSalesInput = {
    update: XOR<CustomerUpdateWithoutPosSalesInput, CustomerUncheckedUpdateWithoutPosSalesInput>
    create: XOR<CustomerCreateWithoutPosSalesInput, CustomerUncheckedCreateWithoutPosSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPosSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPosSalesInput, CustomerUncheckedUpdateWithoutPosSalesInput>
  }

  export type CustomerUpdateWithoutPosSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedCustomersNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCustomerNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPosSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type POSSaleItemUpsertWithWhereUniqueWithoutSaleInput = {
    where: POSSaleItemWhereUniqueInput
    update: XOR<POSSaleItemUpdateWithoutSaleInput, POSSaleItemUncheckedUpdateWithoutSaleInput>
    create: XOR<POSSaleItemCreateWithoutSaleInput, POSSaleItemUncheckedCreateWithoutSaleInput>
  }

  export type POSSaleItemUpdateWithWhereUniqueWithoutSaleInput = {
    where: POSSaleItemWhereUniqueInput
    data: XOR<POSSaleItemUpdateWithoutSaleInput, POSSaleItemUncheckedUpdateWithoutSaleInput>
  }

  export type POSSaleItemUpdateManyWithWhereWithoutSaleInput = {
    where: POSSaleItemScalarWhereInput
    data: XOR<POSSaleItemUpdateManyMutationInput, POSSaleItemUncheckedUpdateManyWithoutSaleInput>
  }

  export type POSSalePaymentUpsertWithWhereUniqueWithoutSaleInput = {
    where: POSSalePaymentWhereUniqueInput
    update: XOR<POSSalePaymentUpdateWithoutSaleInput, POSSalePaymentUncheckedUpdateWithoutSaleInput>
    create: XOR<POSSalePaymentCreateWithoutSaleInput, POSSalePaymentUncheckedCreateWithoutSaleInput>
  }

  export type POSSalePaymentUpdateWithWhereUniqueWithoutSaleInput = {
    where: POSSalePaymentWhereUniqueInput
    data: XOR<POSSalePaymentUpdateWithoutSaleInput, POSSalePaymentUncheckedUpdateWithoutSaleInput>
  }

  export type POSSalePaymentUpdateManyWithWhereWithoutSaleInput = {
    where: POSSalePaymentScalarWhereInput
    data: XOR<POSSalePaymentUpdateManyMutationInput, POSSalePaymentUncheckedUpdateManyWithoutSaleInput>
  }

  export type POSSalePaymentScalarWhereInput = {
    AND?: POSSalePaymentScalarWhereInput | POSSalePaymentScalarWhereInput[]
    OR?: POSSalePaymentScalarWhereInput[]
    NOT?: POSSalePaymentScalarWhereInput | POSSalePaymentScalarWhereInput[]
    id?: UuidFilter<"POSSalePayment"> | string
    saleId?: UuidFilter<"POSSalePayment"> | string
    amount?: DecimalFilter<"POSSalePayment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"POSSalePayment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"POSSalePayment"> | string | null
    createdAt?: DateTimeFilter<"POSSalePayment"> | Date | string
  }

  export type POSQuotationUpsertWithoutConvertedToSaleInput = {
    update: XOR<POSQuotationUpdateWithoutConvertedToSaleInput, POSQuotationUncheckedUpdateWithoutConvertedToSaleInput>
    create: XOR<POSQuotationCreateWithoutConvertedToSaleInput, POSQuotationUncheckedCreateWithoutConvertedToSaleInput>
    where?: POSQuotationWhereInput
  }

  export type POSQuotationUpdateToOneWithWhereWithoutConvertedToSaleInput = {
    where?: POSQuotationWhereInput
    data: XOR<POSQuotationUpdateWithoutConvertedToSaleInput, POSQuotationUncheckedUpdateWithoutConvertedToSaleInput>
  }

  export type POSQuotationUpdateWithoutConvertedToSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPosQuotationsNestedInput
    customer?: CustomerUpdateOneWithoutPosQuotationsNestedInput
    items?: POSQuotationItemUpdateManyWithoutQuotationNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosQuotationsNestedInput
  }

  export type POSQuotationUncheckedUpdateWithoutConvertedToSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: POSQuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type TenantUpsertWithoutPosSalesInput = {
    update: XOR<TenantUpdateWithoutPosSalesInput, TenantUncheckedUpdateWithoutPosSalesInput>
    create: XOR<TenantCreateWithoutPosSalesInput, TenantUncheckedCreateWithoutPosSalesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPosSalesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPosSalesInput, TenantUncheckedUpdateWithoutPosSalesInput>
  }

  export type TenantUpdateWithoutPosSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPosSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PartCreateWithoutPosSaleItemsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutPosSaleItemsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutPosSaleItemsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutPosSaleItemsInput, PartUncheckedCreateWithoutPosSaleItemsInput>
  }

  export type POSSaleCreateWithoutItemsInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashRegister?: CashRegisterCreateNestedOneWithoutPosSalesInput
    createdBy: UserCreateNestedOneWithoutPosSalesInput
    creditNotes?: CreditNoteCreateNestedManyWithoutPosSaleInput
    customer?: CustomerCreateNestedOneWithoutPosSalesInput
    payments?: POSSalePaymentCreateNestedManyWithoutSaleInput
    quotation?: POSQuotationCreateNestedOneWithoutConvertedToSaleInput
    tenant: TenantCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateWithoutItemsInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput
    payments?: POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleCreateOrConnectWithoutItemsInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutItemsInput, POSSaleUncheckedCreateWithoutItemsInput>
  }

  export type PartUpsertWithoutPosSaleItemsInput = {
    update: XOR<PartUpdateWithoutPosSaleItemsInput, PartUncheckedUpdateWithoutPosSaleItemsInput>
    create: XOR<PartCreateWithoutPosSaleItemsInput, PartUncheckedCreateWithoutPosSaleItemsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutPosSaleItemsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutPosSaleItemsInput, PartUncheckedUpdateWithoutPosSaleItemsInput>
  }

  export type PartUpdateWithoutPosSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutPosSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type POSSaleUpsertWithoutItemsInput = {
    update: XOR<POSSaleUpdateWithoutItemsInput, POSSaleUncheckedUpdateWithoutItemsInput>
    create: XOR<POSSaleCreateWithoutItemsInput, POSSaleUncheckedCreateWithoutItemsInput>
    where?: POSSaleWhereInput
  }

  export type POSSaleUpdateToOneWithWhereWithoutItemsInput = {
    where?: POSSaleWhereInput
    data: XOR<POSSaleUpdateWithoutItemsInput, POSSaleUncheckedUpdateWithoutItemsInput>
  }

  export type POSSaleUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneWithoutPosSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPosSalesNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutPosSaleNestedInput
    customer?: CustomerUpdateOneWithoutPosSalesNestedInput
    payments?: POSSalePaymentUpdateManyWithoutSaleNestedInput
    quotation?: POSQuotationUpdateOneWithoutConvertedToSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput
    payments?: POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type POSSaleCreateWithoutPaymentsInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashRegister?: CashRegisterCreateNestedOneWithoutPosSalesInput
    createdBy: UserCreateNestedOneWithoutPosSalesInput
    creditNotes?: CreditNoteCreateNestedManyWithoutPosSaleInput
    customer?: CustomerCreateNestedOneWithoutPosSalesInput
    items?: POSSaleItemCreateNestedManyWithoutSaleInput
    quotation?: POSQuotationCreateNestedOneWithoutConvertedToSaleInput
    tenant: TenantCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateWithoutPaymentsInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput
    items?: POSSaleItemUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleCreateOrConnectWithoutPaymentsInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutPaymentsInput, POSSaleUncheckedCreateWithoutPaymentsInput>
  }

  export type POSSaleUpsertWithoutPaymentsInput = {
    update: XOR<POSSaleUpdateWithoutPaymentsInput, POSSaleUncheckedUpdateWithoutPaymentsInput>
    create: XOR<POSSaleCreateWithoutPaymentsInput, POSSaleUncheckedCreateWithoutPaymentsInput>
    where?: POSSaleWhereInput
  }

  export type POSSaleUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: POSSaleWhereInput
    data: XOR<POSSaleUpdateWithoutPaymentsInput, POSSaleUncheckedUpdateWithoutPaymentsInput>
  }

  export type POSSaleUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneWithoutPosSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPosSalesNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutPosSaleNestedInput
    customer?: CustomerUpdateOneWithoutPosSalesNestedInput
    items?: POSSaleItemUpdateManyWithoutSaleNestedInput
    quotation?: POSQuotationUpdateOneWithoutConvertedToSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput
    items?: POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type UserCreateWithoutPosQuotationsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPosQuotationsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutPosQuotationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPosQuotationsInput, UserUncheckedCreateWithoutPosQuotationsInput>
  }

  export type CustomerCreateWithoutPosQuotationsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedCustomersInput
    creditNotes?: CreditNoteCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleCreateNestedManyWithoutCustomerInput
    tenant: TenantCreateNestedOneWithoutCustomersInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedCustomersInput
  }

  export type CustomerUncheckedCreateWithoutPosQuotationsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCustomerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPosQuotationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPosQuotationsInput, CustomerUncheckedCreateWithoutPosQuotationsInput>
  }

  export type POSQuotationItemCreateWithoutQuotationInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    part: PartCreateNestedOneWithoutPosQuotationItemsInput
  }

  export type POSQuotationItemUncheckedCreateWithoutQuotationInput = {
    id?: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemCreateOrConnectWithoutQuotationInput = {
    where: POSQuotationItemWhereUniqueInput
    create: XOR<POSQuotationItemCreateWithoutQuotationInput, POSQuotationItemUncheckedCreateWithoutQuotationInput>
  }

  export type POSQuotationItemCreateManyQuotationInputEnvelope = {
    data: POSQuotationItemCreateManyQuotationInput | POSQuotationItemCreateManyQuotationInput[]
    skipDuplicates?: boolean
  }

  export type POSSaleCreateWithoutQuotationInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashRegister?: CashRegisterCreateNestedOneWithoutPosSalesInput
    createdBy: UserCreateNestedOneWithoutPosSalesInput
    creditNotes?: CreditNoteCreateNestedManyWithoutPosSaleInput
    customer?: CustomerCreateNestedOneWithoutPosSalesInput
    items?: POSSaleItemCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentCreateNestedManyWithoutSaleInput
    tenant: TenantCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateWithoutQuotationInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutPosSaleInput
    items?: POSSaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleCreateOrConnectWithoutQuotationInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutQuotationInput, POSSaleUncheckedCreateWithoutQuotationInput>
  }

  export type TenantCreateWithoutPosQuotationsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPosQuotationsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPosQuotationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPosQuotationsInput, TenantUncheckedCreateWithoutPosQuotationsInput>
  }

  export type UserUpsertWithoutPosQuotationsInput = {
    update: XOR<UserUpdateWithoutPosQuotationsInput, UserUncheckedUpdateWithoutPosQuotationsInput>
    create: XOR<UserCreateWithoutPosQuotationsInput, UserUncheckedCreateWithoutPosQuotationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPosQuotationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPosQuotationsInput, UserUncheckedUpdateWithoutPosQuotationsInput>
  }

  export type UserUpdateWithoutPosQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPosQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type CustomerUpsertWithoutPosQuotationsInput = {
    update: XOR<CustomerUpdateWithoutPosQuotationsInput, CustomerUncheckedUpdateWithoutPosQuotationsInput>
    create: XOR<CustomerCreateWithoutPosQuotationsInput, CustomerUncheckedCreateWithoutPosQuotationsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPosQuotationsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPosQuotationsInput, CustomerUncheckedUpdateWithoutPosQuotationsInput>
  }

  export type CustomerUpdateWithoutPosQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedCustomersNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUpdateManyWithoutCustomerNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPosQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type POSQuotationItemUpsertWithWhereUniqueWithoutQuotationInput = {
    where: POSQuotationItemWhereUniqueInput
    update: XOR<POSQuotationItemUpdateWithoutQuotationInput, POSQuotationItemUncheckedUpdateWithoutQuotationInput>
    create: XOR<POSQuotationItemCreateWithoutQuotationInput, POSQuotationItemUncheckedCreateWithoutQuotationInput>
  }

  export type POSQuotationItemUpdateWithWhereUniqueWithoutQuotationInput = {
    where: POSQuotationItemWhereUniqueInput
    data: XOR<POSQuotationItemUpdateWithoutQuotationInput, POSQuotationItemUncheckedUpdateWithoutQuotationInput>
  }

  export type POSQuotationItemUpdateManyWithWhereWithoutQuotationInput = {
    where: POSQuotationItemScalarWhereInput
    data: XOR<POSQuotationItemUpdateManyMutationInput, POSQuotationItemUncheckedUpdateManyWithoutQuotationInput>
  }

  export type POSSaleUpsertWithoutQuotationInput = {
    update: XOR<POSSaleUpdateWithoutQuotationInput, POSSaleUncheckedUpdateWithoutQuotationInput>
    create: XOR<POSSaleCreateWithoutQuotationInput, POSSaleUncheckedCreateWithoutQuotationInput>
    where?: POSSaleWhereInput
  }

  export type POSSaleUpdateToOneWithWhereWithoutQuotationInput = {
    where?: POSSaleWhereInput
    data: XOR<POSSaleUpdateWithoutQuotationInput, POSSaleUncheckedUpdateWithoutQuotationInput>
  }

  export type POSSaleUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneWithoutPosSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPosSalesNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutPosSaleNestedInput
    customer?: CustomerUpdateOneWithoutPosSalesNestedInput
    items?: POSSaleItemUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUpdateManyWithoutSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput
    items?: POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type TenantUpsertWithoutPosQuotationsInput = {
    update: XOR<TenantUpdateWithoutPosQuotationsInput, TenantUncheckedUpdateWithoutPosQuotationsInput>
    create: XOR<TenantCreateWithoutPosQuotationsInput, TenantUncheckedCreateWithoutPosQuotationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPosQuotationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPosQuotationsInput, TenantUncheckedUpdateWithoutPosQuotationsInput>
  }

  export type TenantUpdateWithoutPosQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPosQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PartCreateWithoutPosQuotationItemsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemCreateNestedManyWithoutPartInput
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutPosQuotationItemsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    creditNoteItems?: CreditNoteItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutPosQuotationItemsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutPosQuotationItemsInput, PartUncheckedCreateWithoutPosQuotationItemsInput>
  }

  export type POSQuotationCreateWithoutItemsInput = {
    id?: string
    quotationNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPosQuotationsInput
    customer?: CustomerCreateNestedOneWithoutPosQuotationsInput
    convertedToSale?: POSSaleCreateNestedOneWithoutQuotationInput
    tenant: TenantCreateNestedOneWithoutPosQuotationsInput
  }

  export type POSQuotationUncheckedCreateWithoutItemsInput = {
    id?: string
    quotationNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    convertedToSale?: POSSaleUncheckedCreateNestedOneWithoutQuotationInput
  }

  export type POSQuotationCreateOrConnectWithoutItemsInput = {
    where: POSQuotationWhereUniqueInput
    create: XOR<POSQuotationCreateWithoutItemsInput, POSQuotationUncheckedCreateWithoutItemsInput>
  }

  export type PartUpsertWithoutPosQuotationItemsInput = {
    update: XOR<PartUpdateWithoutPosQuotationItemsInput, PartUncheckedUpdateWithoutPosQuotationItemsInput>
    create: XOR<PartCreateWithoutPosQuotationItemsInput, PartUncheckedCreateWithoutPosQuotationItemsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutPosQuotationItemsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutPosQuotationItemsInput, PartUncheckedUpdateWithoutPosQuotationItemsInput>
  }

  export type PartUpdateWithoutPosQuotationItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutPosQuotationItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type POSQuotationUpsertWithoutItemsInput = {
    update: XOR<POSQuotationUpdateWithoutItemsInput, POSQuotationUncheckedUpdateWithoutItemsInput>
    create: XOR<POSQuotationCreateWithoutItemsInput, POSQuotationUncheckedCreateWithoutItemsInput>
    where?: POSQuotationWhereInput
  }

  export type POSQuotationUpdateToOneWithWhereWithoutItemsInput = {
    where?: POSQuotationWhereInput
    data: XOR<POSQuotationUpdateWithoutItemsInput, POSQuotationUncheckedUpdateWithoutItemsInput>
  }

  export type POSQuotationUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPosQuotationsNestedInput
    customer?: CustomerUpdateOneWithoutPosQuotationsNestedInput
    convertedToSale?: POSSaleUpdateOneWithoutQuotationNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosQuotationsNestedInput
  }

  export type POSQuotationUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToSale?: POSSaleUncheckedUpdateOneWithoutQuotationNestedInput
  }

  export type UserCreateWithoutCreditNotesCreatedInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreditNotesCreatedInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreditNotesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditNotesCreatedInput, UserUncheckedCreateWithoutCreditNotesCreatedInput>
  }

  export type UserCreateWithoutCreditNotesProcessedInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreditNotesProcessedInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutCreditNotesProcessedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditNotesProcessedInput, UserUncheckedCreateWithoutCreditNotesProcessedInput>
  }

  export type CustomerCreateWithoutCreditNotesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dpi?: string | null
    nit?: string | null
    createdBy?: UserCreateNestedOneWithoutCreatedCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCustomerInput
    tenant: TenantCreateNestedOneWithoutCustomersInput
    tickets?: TicketCreateNestedManyWithoutCustomerInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedCustomersInput
  }

  export type CustomerUncheckedCreateWithoutCreditNotesInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCustomerInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCustomerInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCreditNotesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCreditNotesInput, CustomerUncheckedCreateWithoutCreditNotesInput>
  }

  export type CreditNoteItemCreateWithoutCreditNoteInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
    part: PartCreateNestedOneWithoutCreditNoteItemsInput
  }

  export type CreditNoteItemUncheckedCreateWithoutCreditNoteInput = {
    id?: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
  }

  export type CreditNoteItemCreateOrConnectWithoutCreditNoteInput = {
    where: CreditNoteItemWhereUniqueInput
    create: XOR<CreditNoteItemCreateWithoutCreditNoteInput, CreditNoteItemUncheckedCreateWithoutCreditNoteInput>
  }

  export type CreditNoteItemCreateManyCreditNoteInputEnvelope = {
    data: CreditNoteItemCreateManyCreditNoteInput | CreditNoteItemCreateManyCreditNoteInput[]
    skipDuplicates?: boolean
  }

  export type POSSaleCreateWithoutCreditNotesInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashRegister?: CashRegisterCreateNestedOneWithoutPosSalesInput
    createdBy: UserCreateNestedOneWithoutPosSalesInput
    customer?: CustomerCreateNestedOneWithoutPosSalesInput
    items?: POSSaleItemCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentCreateNestedManyWithoutSaleInput
    quotation?: POSQuotationCreateNestedOneWithoutConvertedToSaleInput
    tenant: TenantCreateNestedOneWithoutPosSalesInput
  }

  export type POSSaleUncheckedCreateWithoutCreditNotesInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: POSSaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: POSSalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type POSSaleCreateOrConnectWithoutCreditNotesInput = {
    where: POSSaleWhereUniqueInput
    create: XOR<POSSaleCreateWithoutCreditNotesInput, POSSaleUncheckedCreateWithoutCreditNotesInput>
  }

  export type TenantCreateWithoutCreditNotesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCreditNotesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCreditNotesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCreditNotesInput, TenantUncheckedCreateWithoutCreditNotesInput>
  }

  export type UserUpsertWithoutCreditNotesCreatedInput = {
    update: XOR<UserUpdateWithoutCreditNotesCreatedInput, UserUncheckedUpdateWithoutCreditNotesCreatedInput>
    create: XOR<UserCreateWithoutCreditNotesCreatedInput, UserUncheckedCreateWithoutCreditNotesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreditNotesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreditNotesCreatedInput, UserUncheckedUpdateWithoutCreditNotesCreatedInput>
  }

  export type UserUpdateWithoutCreditNotesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreditNotesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUpsertWithoutCreditNotesProcessedInput = {
    update: XOR<UserUpdateWithoutCreditNotesProcessedInput, UserUncheckedUpdateWithoutCreditNotesProcessedInput>
    create: XOR<UserCreateWithoutCreditNotesProcessedInput, UserUncheckedCreateWithoutCreditNotesProcessedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreditNotesProcessedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreditNotesProcessedInput, UserUncheckedUpdateWithoutCreditNotesProcessedInput>
  }

  export type UserUpdateWithoutCreditNotesProcessedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreditNotesProcessedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type CustomerUpsertWithoutCreditNotesInput = {
    update: XOR<CustomerUpdateWithoutCreditNotesInput, CustomerUncheckedUpdateWithoutCreditNotesInput>
    create: XOR<CustomerCreateWithoutCreditNotesInput, CustomerUncheckedCreateWithoutCreditNotesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCreditNotesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCreditNotesInput, CustomerUncheckedUpdateWithoutCreditNotesInput>
  }

  export type CustomerUpdateWithoutCreditNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCustomerNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCreditNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CreditNoteItemUpsertWithWhereUniqueWithoutCreditNoteInput = {
    where: CreditNoteItemWhereUniqueInput
    update: XOR<CreditNoteItemUpdateWithoutCreditNoteInput, CreditNoteItemUncheckedUpdateWithoutCreditNoteInput>
    create: XOR<CreditNoteItemCreateWithoutCreditNoteInput, CreditNoteItemUncheckedCreateWithoutCreditNoteInput>
  }

  export type CreditNoteItemUpdateWithWhereUniqueWithoutCreditNoteInput = {
    where: CreditNoteItemWhereUniqueInput
    data: XOR<CreditNoteItemUpdateWithoutCreditNoteInput, CreditNoteItemUncheckedUpdateWithoutCreditNoteInput>
  }

  export type CreditNoteItemUpdateManyWithWhereWithoutCreditNoteInput = {
    where: CreditNoteItemScalarWhereInput
    data: XOR<CreditNoteItemUpdateManyMutationInput, CreditNoteItemUncheckedUpdateManyWithoutCreditNoteInput>
  }

  export type POSSaleUpsertWithoutCreditNotesInput = {
    update: XOR<POSSaleUpdateWithoutCreditNotesInput, POSSaleUncheckedUpdateWithoutCreditNotesInput>
    create: XOR<POSSaleCreateWithoutCreditNotesInput, POSSaleUncheckedCreateWithoutCreditNotesInput>
    where?: POSSaleWhereInput
  }

  export type POSSaleUpdateToOneWithWhereWithoutCreditNotesInput = {
    where?: POSSaleWhereInput
    data: XOR<POSSaleUpdateWithoutCreditNotesInput, POSSaleUncheckedUpdateWithoutCreditNotesInput>
  }

  export type POSSaleUpdateWithoutCreditNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneWithoutPosSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPosSalesNestedInput
    customer?: CustomerUpdateOneWithoutPosSalesNestedInput
    items?: POSSaleItemUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUpdateManyWithoutSaleNestedInput
    quotation?: POSQuotationUpdateOneWithoutConvertedToSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutCreditNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type TenantUpsertWithoutCreditNotesInput = {
    update: XOR<TenantUpdateWithoutCreditNotesInput, TenantUncheckedUpdateWithoutCreditNotesInput>
    create: XOR<TenantCreateWithoutCreditNotesInput, TenantUncheckedCreateWithoutCreditNotesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCreditNotesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCreditNotesInput, TenantUncheckedUpdateWithoutCreditNotesInput>
  }

  export type TenantUpdateWithoutCreditNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCreditNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CreditNoteCreateWithoutItemsInput = {
    id?: string
    creditNoteNumber: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreditNotesCreatedInput
    processedBy?: UserCreateNestedOneWithoutCreditNotesProcessedInput
    customer?: CustomerCreateNestedOneWithoutCreditNotesInput
    posSale: POSSaleCreateNestedOneWithoutCreditNotesInput
    tenant: TenantCreateNestedOneWithoutCreditNotesInput
  }

  export type CreditNoteUncheckedCreateWithoutItemsInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditNoteCreateOrConnectWithoutItemsInput = {
    where: CreditNoteWhereUniqueInput
    create: XOR<CreditNoteCreateWithoutItemsInput, CreditNoteUncheckedCreateWithoutItemsInput>
  }

  export type PartCreateWithoutCreditNoteItemsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: string | null
    location?: string | null
    minStock?: number
    createdBy?: UserCreateNestedOneWithoutCreatedPartsInput
    posQuotationItems?: POSQuotationItemCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartCreateNestedManyWithoutPartInput
    tenant: TenantCreateNestedOneWithoutPartsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedPartsInput
    usages?: PartUsageCreateNestedManyWithoutPartInput
  }

  export type PartUncheckedCreateWithoutCreditNoteItemsInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
    posQuotationItems?: POSQuotationItemUncheckedCreateNestedManyWithoutPartInput
    posSaleItems?: POSSaleItemUncheckedCreateNestedManyWithoutPartInput
    purchaseItems?: PurchaseItemUncheckedCreateNestedManyWithoutPartInput
    templateDefaultParts?: TemplateDefaultPartUncheckedCreateNestedManyWithoutPartInput
    usages?: PartUsageUncheckedCreateNestedManyWithoutPartInput
  }

  export type PartCreateOrConnectWithoutCreditNoteItemsInput = {
    where: PartWhereUniqueInput
    create: XOR<PartCreateWithoutCreditNoteItemsInput, PartUncheckedCreateWithoutCreditNoteItemsInput>
  }

  export type CreditNoteUpsertWithoutItemsInput = {
    update: XOR<CreditNoteUpdateWithoutItemsInput, CreditNoteUncheckedUpdateWithoutItemsInput>
    create: XOR<CreditNoteCreateWithoutItemsInput, CreditNoteUncheckedCreateWithoutItemsInput>
    where?: CreditNoteWhereInput
  }

  export type CreditNoteUpdateToOneWithWhereWithoutItemsInput = {
    where?: CreditNoteWhereInput
    data: XOR<CreditNoteUpdateWithoutItemsInput, CreditNoteUncheckedUpdateWithoutItemsInput>
  }

  export type CreditNoteUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreditNotesCreatedNestedInput
    processedBy?: UserUpdateOneWithoutCreditNotesProcessedNestedInput
    customer?: CustomerUpdateOneWithoutCreditNotesNestedInput
    posSale?: POSSaleUpdateOneRequiredWithoutCreditNotesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCreditNotesNestedInput
  }

  export type CreditNoteUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUpsertWithoutCreditNoteItemsInput = {
    update: XOR<PartUpdateWithoutCreditNoteItemsInput, PartUncheckedUpdateWithoutCreditNoteItemsInput>
    create: XOR<PartCreateWithoutCreditNoteItemsInput, PartUncheckedCreateWithoutCreditNoteItemsInput>
    where?: PartWhereInput
  }

  export type PartUpdateToOneWithWhereWithoutCreditNoteItemsInput = {
    where?: PartWhereInput
    data: XOR<PartUpdateWithoutCreditNoteItemsInput, PartUncheckedUpdateWithoutCreditNoteItemsInput>
  }

  export type PartUpdateWithoutCreditNoteItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutCreditNoteItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type TenantCreateWithoutSessionLogsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSessionLogsInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    userPresences?: UserPresenceUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSessionLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSessionLogsInput, TenantUncheckedCreateWithoutSessionLogsInput>
  }

  export type UserCreateWithoutSessionLogsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    presence?: UserPresenceCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSessionLogsInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    presence?: UserPresenceUncheckedCreateNestedOneWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutSessionLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionLogsInput, UserUncheckedCreateWithoutSessionLogsInput>
  }

  export type TenantUpsertWithoutSessionLogsInput = {
    update: XOR<TenantUpdateWithoutSessionLogsInput, TenantUncheckedUpdateWithoutSessionLogsInput>
    create: XOR<TenantCreateWithoutSessionLogsInput, TenantUncheckedCreateWithoutSessionLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSessionLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSessionLogsInput, TenantUncheckedUpdateWithoutSessionLogsInput>
  }

  export type TenantUpdateWithoutSessionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSessionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    userPresences?: UserPresenceUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutSessionLogsInput = {
    update: XOR<UserUpdateWithoutSessionLogsInput, UserUncheckedUpdateWithoutSessionLogsInput>
    create: XOR<UserCreateWithoutSessionLogsInput, UserUncheckedCreateWithoutSessionLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionLogsInput, UserUncheckedUpdateWithoutSessionLogsInput>
  }

  export type UserUpdateWithoutSessionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserCreateWithoutPresenceInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    createdBy?: UserCreateNestedOneWithoutUsersCreatedInput
    updatedBy?: UserCreateNestedOneWithoutUsersUpdatedInput
    usersCreated?: UserCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogCreateNestedManyWithoutUserInput
    closedCashRegisters?: CashRegisterCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdParts?: PartCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentCreateNestedManyWithoutUploadedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPresenceInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
    usersCreated?: UserUncheckedCreateNestedManyWithoutCreatedByInput
    usersUpdated?: UserUncheckedCreateNestedManyWithoutUpdatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutUserInput
    closedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutClosedByInput
    openedCashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutOpenedByInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesCreated?: CreditNoteUncheckedCreateNestedManyWithoutCreatedByInput
    creditNotesProcessed?: CreditNoteUncheckedCreateNestedManyWithoutProcessedByInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    updatedCustomers?: CustomerUncheckedCreateNestedManyWithoutUpdatedByInput
    createdInvoices?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    updatedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUpdatedByInput
    invoiceHistory?: InvoiceHistoryUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdParts?: PartUncheckedCreateNestedManyWithoutCreatedByInput
    updatedParts?: PartUncheckedCreateNestedManyWithoutUpdatedByInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutCreatedByInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutCreatedByInput
    receivedPayments?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    createdTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutUpdatedByInput
    specializations?: TechnicianSpecializationUncheckedCreateNestedManyWithoutUserInput
    unavailabilities?: TechnicianUnavailabilityUncheckedCreateNestedManyWithoutUserInput
    ticketNotes?: TicketNoteUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: TicketUncheckedCreateNestedManyWithoutAssignedToInput
    createdTickets?: TicketUncheckedCreateNestedManyWithoutCreatedByInput
    updatedTickets?: TicketUncheckedCreateNestedManyWithoutUpdatedByInput
    uploadedAttachments?: TicketAttachmentUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutPresenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPresenceInput, UserUncheckedCreateWithoutPresenceInput>
  }

  export type TenantCreateWithoutUserPresencesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    parts?: PartCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    posSales?: POSSaleCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsCreateNestedOneWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUserPresencesInput = {
    id?: string
    name: string
    slug: string
    adminUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    sessionLogs?: SessionLogUncheckedCreateNestedManyWithoutTenantInput
    cashRegisters?: CashRegisterUncheckedCreateNestedManyWithoutTenantInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutTenantInput
    creditNotes?: CreditNoteUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    parts?: PartUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    posSales?: POSSaleUncheckedCreateNestedManyWithoutTenantInput
    posQuotations?: POSQuotationUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    serviceTemplates?: ServiceTemplateUncheckedCreateNestedManyWithoutTenantInput
    settings?: TenantSettingsUncheckedCreateNestedOneWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUserPresencesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUserPresencesInput, TenantUncheckedCreateWithoutUserPresencesInput>
  }

  export type TicketCreateWithoutViewedByUsersInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentCreateNestedManyWithoutTicketInput
    invoice?: InvoiceCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageCreateNestedManyWithoutTicketInput
    notes?: TicketNoteCreateNestedManyWithoutTicketInput
    services?: TicketServiceCreateNestedManyWithoutTicketInput
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    createdBy?: UserCreateNestedOneWithoutCreatedTicketsInput
    customer: CustomerCreateNestedOneWithoutTicketsInput
    serviceTemplate?: ServiceTemplateCreateNestedOneWithoutTicketsInput
    tenant: TenantCreateNestedOneWithoutTicketsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedTicketsInput
  }

  export type TicketUncheckedCreateWithoutViewedByUsersInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
    attachments?: TicketAttachmentUncheckedCreateNestedManyWithoutTicketInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTicketInput
    partsUsed?: PartUsageUncheckedCreateNestedManyWithoutTicketInput
    notes?: TicketNoteUncheckedCreateNestedManyWithoutTicketInput
    services?: TicketServiceUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutViewedByUsersInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutViewedByUsersInput, TicketUncheckedCreateWithoutViewedByUsersInput>
  }

  export type UserUpsertWithoutPresenceInput = {
    update: XOR<UserUpdateWithoutPresenceInput, UserUncheckedUpdateWithoutPresenceInput>
    create: XOR<UserCreateWithoutPresenceInput, UserUncheckedCreateWithoutPresenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPresenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPresenceInput, UserUncheckedUpdateWithoutPresenceInput>
  }

  export type UserUpdateWithoutPresenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPresenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type TenantUpsertWithoutUserPresencesInput = {
    update: XOR<TenantUpdateWithoutUserPresencesInput, TenantUncheckedUpdateWithoutUserPresencesInput>
    create: XOR<TenantCreateWithoutUserPresencesInput, TenantUncheckedCreateWithoutUserPresencesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUserPresencesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUserPresencesInput, TenantUncheckedUpdateWithoutUserPresencesInput>
  }

  export type TenantUpdateWithoutUserPresencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    parts?: PartUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUpdateOneWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUserPresencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutTenantNestedInput
    cashRegisters?: CashRegisterUncheckedUpdateManyWithoutTenantNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutTenantNestedInput
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    parts?: PartUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutTenantNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    serviceTemplates?: ServiceTemplateUncheckedUpdateManyWithoutTenantNestedInput
    settings?: TenantSettingsUncheckedUpdateOneWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TicketUpsertWithoutViewedByUsersInput = {
    update: XOR<TicketUpdateWithoutViewedByUsersInput, TicketUncheckedUpdateWithoutViewedByUsersInput>
    create: XOR<TicketCreateWithoutViewedByUsersInput, TicketUncheckedCreateWithoutViewedByUsersInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutViewedByUsersInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutViewedByUsersInput, TicketUncheckedUpdateWithoutViewedByUsersInput>
  }

  export type TicketUpdateWithoutViewedByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutViewedByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    details?: string | null
    userId?: string | null
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
  }

  export type SessionLogCreateManyTenantInput = {
    id?: string
    userId: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceCreateManyTenantInput = {
    id?: string
    userId: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    currentTicketId?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CashRegisterCreateManyTenantInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    openedById?: string | null
    closedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashTransactionCreateManyTenantInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    cashRegisterId: string
    createdById: string
    createdAt?: Date | string
  }

  export type CreditNoteCreateManyTenantInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyTenantInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyTenantInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type PartCreateManyTenantInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
  }

  export type PaymentCreateManyTenantInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    receivedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSSaleCreateManyTenantInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSQuotationCreateManyTenantInput = {
    id?: string
    quotationNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyTenantInput = {
    id?: string
    supplier: string
    status?: $Enums.PurchaseStatus
    orderDate?: Date | string
    receivedDate?: Date | string | null
    totalCost?: Decimal | DecimalJsLike | number | string
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTemplateCreateManyTenantInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyTenantInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutSessionLogsNestedInput
  }

  export type SessionLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPresenceNestedInput
    currentTicket?: TicketUpdateOneWithoutViewedByUsersNestedInput
  }

  export type UserPresenceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    currentTicketId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    currentTicketId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CashRegisterUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedBy?: UserUpdateOneWithoutClosedCashRegistersNestedInput
    openedBy?: UserUpdateOneWithoutOpenedCashRegistersNestedInput
    posSales?: POSSaleUpdateManyWithoutCashRegisterNestedInput
    transactions?: CashTransactionUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posSales?: POSSaleUncheckedUpdateManyWithoutCashRegisterNestedInput
    transactions?: CashTransactionUncheckedUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: NullableStringFieldUpdateOperationsInput | string | null
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashRegisterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashRegisterId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreditNotesCreatedNestedInput
    processedBy?: UserUpdateOneWithoutCreditNotesProcessedNestedInput
    customer?: CustomerUpdateOneWithoutCreditNotesNestedInput
    items?: CreditNoteItemUpdateManyWithoutCreditNoteNestedInput
    posSale?: POSSaleUpdateOneRequiredWithoutCreditNotesNestedInput
  }

  export type CreditNoteUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CreditNoteItemUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type CreditNoteUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedCustomersNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    history?: InvoiceHistoryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    ticket?: TicketUpdateOneRequiredWithoutInvoiceNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: InvoiceHistoryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutReceivedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSaleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneWithoutPosSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPosSalesNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutPosSaleNestedInput
    customer?: CustomerUpdateOneWithoutPosSalesNestedInput
    items?: POSSaleItemUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUpdateManyWithoutSaleNestedInput
    quotation?: POSQuotationUpdateOneWithoutConvertedToSaleNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput
    items?: POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type POSSaleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSQuotationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPosQuotationsNestedInput
    customer?: CustomerUpdateOneWithoutPosQuotationsNestedInput
    items?: POSQuotationItemUpdateManyWithoutQuotationNestedInput
    convertedToSale?: POSSaleUpdateOneWithoutQuotationNestedInput
  }

  export type POSQuotationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: POSQuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    convertedToSale?: POSSaleUncheckedUpdateOneWithoutQuotationNestedInput
  }

  export type POSQuotationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedTemplatesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTemplatesNestedInput
    defaultParts?: TemplateDefaultPartUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUpdateManyWithoutServiceNestedInput
    tickets?: TicketUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUncheckedUpdateManyWithoutServiceNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyCreatedByInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
  }

  export type UserCreateManyUpdatedByInput = {
    id?: string
    email: string
    password: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    role?: $Enums.UserRole
    tenantId: string
    isActive?: boolean
    passwordMustChange?: boolean
    lastLoginAt?: Date | string | null
    failedLoginAttempts?: number
    lockedUntil?: Date | string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.TechnicianStatus
    maxConcurrentTickets?: number
    statusReason?: string | null
    availableFrom?: Date | string | null
    availableUntil?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    details?: string | null
    tenantId: string
    createdAt?: Date | string
    action: $Enums.AuditAction
    module: $Enums.AuditModule
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
  }

  export type SessionLogCreateManyUserInput = {
    id?: string
    tenantId: string
    sessionToken: string
    ipAddress?: string | null
    userAgent?: string | null
    loginAt?: Date | string
    lastActivityAt?: Date | string
    logoutAt?: Date | string | null
    status?: $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CashRegisterCreateManyClosedByInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    tenantId: string
    openedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashRegisterCreateManyOpenedByInput = {
    id?: string
    name: string
    isOpen?: boolean
    openedAt?: Date | string | null
    closedAt?: Date | string | null
    openingBalance?: Decimal | DecimalJsLike | number | string
    closingBalance?: Decimal | DecimalJsLike | number | string
    expectedBalance?: Decimal | DecimalJsLike | number | string
    difference?: Decimal | DecimalJsLike | number | string
    closingNotes?: string | null
    tenantId: string
    closedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashTransactionCreateManyCreatedByInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    cashRegisterId: string
    tenantId: string
    createdAt?: Date | string
  }

  export type CreditNoteCreateManyCreatedByInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditNoteCreateManyProcessedByInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyCreatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    dpi?: string | null
    nit?: string | null
  }

  export type CustomerCreateManyUpdatedByInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    dpi?: string | null
    nit?: string | null
  }

  export type InvoiceCreateManyCreatedByInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyUpdatedByInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    customerId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceHistoryCreateManyUserInput = {
    id?: string
    invoiceId: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    link?: string | null
    isRead?: boolean
    tenantId: string
    createdAt?: Date | string
  }

  export type PartCreateManyCreatedByInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
  }

  export type PartCreateManyUpdatedByInput = {
    id?: string
    name: string
    sku?: string | null
    quantity?: number
    cost: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    category?: string | null
    location?: string | null
    minStock?: number
  }

  export type POSSaleCreateManyCreatedByInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSQuotationCreateManyCreatedByInput = {
    id?: string
    quotationNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyReceivedByInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    updatedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTemplateCreateManyUpdatedByInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    defaultTitle: string
    defaultDescription: string
    defaultPriority?: string
    estimatedDuration?: number | null
    laborCost?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    color?: string | null
    icon?: string | null
    tenantId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicianSpecializationCreateManyUserInput = {
    id?: string
    specialization: $Enums.Specialization
    createdAt?: Date | string
  }

  export type TechnicianUnavailabilityCreateManyUserInput = {
    id?: string
    reason?: $Enums.TechnicianStatus
    notes?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketNoteCreateManyAuthorInput = {
    id?: string
    content: string
    isInternal?: boolean
    ticketId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyAssignedToInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
  }

  export type TicketCreateManyCreatedByInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
  }

  export type TicketCreateManyUpdatedByInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
  }

  export type TicketAttachmentCreateManyUploadedByInput = {
    id?: string
    ticketId: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: UserUpdateOneWithoutUsersUpdatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneWithoutUsersCreatedNestedInput
    usersCreated?: UserUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdParts?: PartUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUpdateManyWithoutUploadedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usersCreated?: UserUncheckedUpdateManyWithoutCreatedByNestedInput
    usersUpdated?: UserUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    sessionLogs?: SessionLogUncheckedUpdateManyWithoutUserNestedInput
    presence?: UserPresenceUncheckedUpdateOneWithoutUserNestedInput
    closedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutClosedByNestedInput
    openedCashRegisters?: CashRegisterUncheckedUpdateManyWithoutOpenedByNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesCreated?: CreditNoteUncheckedUpdateManyWithoutCreatedByNestedInput
    creditNotesProcessed?: CreditNoteUncheckedUpdateManyWithoutProcessedByNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedCustomers?: CustomerUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdInvoices?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedInvoices?: InvoiceUncheckedUpdateManyWithoutUpdatedByNestedInput
    invoiceHistory?: InvoiceHistoryUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdParts?: PartUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedParts?: PartUncheckedUpdateManyWithoutUpdatedByNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCreatedByNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    receivedPayments?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    createdTemplates?: ServiceTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTemplates?: ServiceTemplateUncheckedUpdateManyWithoutUpdatedByNestedInput
    specializations?: TechnicianSpecializationUncheckedUpdateManyWithoutUserNestedInput
    unavailabilities?: TechnicianUnavailabilityUncheckedUpdateManyWithoutUserNestedInput
    ticketNotes?: TicketNoteUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: TicketUncheckedUpdateManyWithoutAssignedToNestedInput
    createdTickets?: TicketUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedTickets?: TicketUncheckedUpdateManyWithoutUpdatedByNestedInput
    uploadedAttachments?: TicketAttachmentUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    tenantId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordMustChange?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    maxConcurrentTickets?: IntFieldUpdateOperationsInput | number
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    availableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    module?: EnumAuditModuleFieldUpdateOperationsInput | $Enums.AuditModule
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tenant?: TenantUpdateOneRequiredWithoutSessionLogsNestedInput
  }

  export type SessionLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    loginAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CashRegisterUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openedBy?: UserUpdateOneWithoutOpenedCashRegistersNestedInput
    posSales?: POSSaleUpdateManyWithoutCashRegisterNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashRegistersNestedInput
    transactions?: CashTransactionUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    openedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posSales?: POSSaleUncheckedUpdateManyWithoutCashRegisterNestedInput
    transactions?: CashTransactionUncheckedUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateManyWithoutClosedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    openedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashRegisterUpdateWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedBy?: UserUpdateOneWithoutClosedCashRegistersNestedInput
    posSales?: POSSaleUpdateManyWithoutCashRegisterNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashRegistersNestedInput
    transactions?: CashTransactionUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posSales?: POSSaleUncheckedUpdateManyWithoutCashRegisterNestedInput
    transactions?: CashTransactionUncheckedUpdateManyWithoutCashRegisterNestedInput
  }

  export type CashRegisterUncheckedUpdateManyWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    openingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expectedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difference?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closingNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    closedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneRequiredWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashRegisterId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cashRegisterId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedBy?: UserUpdateOneWithoutCreditNotesProcessedNestedInput
    customer?: CustomerUpdateOneWithoutCreditNotesNestedInput
    items?: CreditNoteItemUpdateManyWithoutCreditNoteNestedInput
    posSale?: POSSaleUpdateOneRequiredWithoutCreditNotesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCreditNotesNestedInput
  }

  export type CreditNoteUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CreditNoteItemUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type CreditNoteUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreditNotesCreatedNestedInput
    customer?: CustomerUpdateOneWithoutCreditNotesNestedInput
    items?: CreditNoteItemUpdateManyWithoutCreditNoteNestedInput
    posSale?: POSSaleUpdateOneRequiredWithoutCreditNotesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCreditNotesNestedInput
  }

  export type CreditNoteUncheckedUpdateWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CreditNoteItemUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type CreditNoteUncheckedUpdateManyWithoutProcessedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCustomerNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: UserUpdateOneWithoutCreatedCustomersNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUpdateManyWithoutCustomerNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    tickets?: TicketUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    posSales?: POSSaleUncheckedUpdateManyWithoutCustomerNestedInput
    posQuotations?: POSQuotationUncheckedUpdateManyWithoutCustomerNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    dpi?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    history?: InvoiceHistoryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutInvoiceNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: InvoiceHistoryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    history?: InvoiceHistoryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: InvoiceHistoryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type InvoiceHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
  }

  export type PartUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUpdateManyWithoutPartNestedInput
    createdBy?: UserUpdateOneWithoutCreatedPartsNestedInput
    posQuotationItems?: POSQuotationItemUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUpdateManyWithoutPartNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPartsNestedInput
    usages?: PartUsageUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
    creditNoteItems?: CreditNoteItemUncheckedUpdateManyWithoutPartNestedInput
    posQuotationItems?: POSQuotationItemUncheckedUpdateManyWithoutPartNestedInput
    posSaleItems?: POSSaleItemUncheckedUpdateManyWithoutPartNestedInput
    purchaseItems?: PurchaseItemUncheckedUpdateManyWithoutPartNestedInput
    templateDefaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutPartNestedInput
    usages?: PartUsageUncheckedUpdateManyWithoutPartNestedInput
  }

  export type PartUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minStock?: IntFieldUpdateOperationsInput | number
  }

  export type POSSaleUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneWithoutPosSalesNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutPosSaleNestedInput
    customer?: CustomerUpdateOneWithoutPosSalesNestedInput
    items?: POSSaleItemUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUpdateManyWithoutSaleNestedInput
    quotation?: POSQuotationUpdateOneWithoutConvertedToSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput
    items?: POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type POSSaleUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSQuotationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutPosQuotationsNestedInput
    items?: POSQuotationItemUpdateManyWithoutQuotationNestedInput
    convertedToSale?: POSSaleUpdateOneWithoutQuotationNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosQuotationsNestedInput
  }

  export type POSQuotationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: POSQuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    convertedToSale?: POSSaleUncheckedUpdateOneWithoutQuotationNestedInput
  }

  export type POSQuotationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutServiceTemplatesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTemplatesNestedInput
    defaultParts?: TemplateDefaultPartUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUpdateManyWithoutServiceNestedInput
    tickets?: TicketUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUncheckedUpdateManyWithoutServiceNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTemplateUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedTemplatesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutServiceTemplatesNestedInput
    defaultParts?: TemplateDefaultPartUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUpdateManyWithoutServiceNestedInput
    tickets?: TicketUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultParts?: TemplateDefaultPartUncheckedUpdateManyWithoutTemplateNestedInput
    usages?: TicketServiceUncheckedUpdateManyWithoutServiceNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutServiceTemplateNestedInput
  }

  export type ServiceTemplateUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    defaultTitle?: StringFieldUpdateOperationsInput | string
    defaultDescription?: StringFieldUpdateOperationsInput | string
    defaultPriority?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    laborCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianSpecializationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: EnumSpecializationFieldUpdateOperationsInput | $Enums.Specialization
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianSpecializationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: EnumSpecializationFieldUpdateOperationsInput | $Enums.Specialization
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianSpecializationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialization?: EnumSpecializationFieldUpdateOperationsInput | $Enums.Specialization
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianUnavailabilityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianUnavailabilityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicianUnavailabilityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumTechnicianStatusFieldUpdateOperationsInput | $Enums.TechnicianStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutNotesNestedInput
  }

  export type TicketNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketAttachmentUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type TicketAttachmentUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteCreateManyCustomerInput = {
    id?: string
    creditNoteNumber: string
    posSaleId: string
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: string
    invoiceNumber: string
    status?: $Enums.InvoiceStatus
    ticketId: string
    laborCost?: Decimal | DecimalJsLike | number | string
    partsCost?: Decimal | DecimalJsLike | number | string
    partsMarkup?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    customerName: string
    customerNIT?: string | null
    customerDPI?: string | null
    customerAddress?: string | null
    notes?: string | null
    paymentTerms?: string | null
    issuedAt?: Date | string
    dueAt?: Date | string | null
    paidAt?: Date | string | null
    tenantId: string
    createdById: string
    updatedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSSaleCreateManyCustomerInput = {
    id?: string
    saleNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    cashRegisterId?: string | null
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSQuotationCreateManyCustomerInput = {
    id?: string
    quotationNumber: string
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.QuotationStatus
    validUntil?: Date | string | null
    notes?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyCustomerInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    serviceTemplateId?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
  }

  export type CreditNoteUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreditNotesCreatedNestedInput
    processedBy?: UserUpdateOneWithoutCreditNotesProcessedNestedInput
    items?: CreditNoteItemUpdateManyWithoutCreditNoteNestedInput
    posSale?: POSSaleUpdateOneRequiredWithoutCreditNotesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCreditNotesNestedInput
  }

  export type CreditNoteUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CreditNoteItemUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type CreditNoteUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    posSaleId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedInvoicesNestedInput
    history?: InvoiceHistoryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    ticket?: TicketUpdateOneRequiredWithoutInvoiceNestedInput
    updatedBy?: UserUpdateOneRequiredWithoutUpdatedInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: InvoiceHistoryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    ticketId?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partsMarkup?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerNIT?: NullableStringFieldUpdateOperationsInput | string | null
    customerDPI?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashRegister?: CashRegisterUpdateOneWithoutPosSalesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPosSalesNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutPosSaleNestedInput
    items?: POSSaleItemUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUpdateManyWithoutSaleNestedInput
    quotation?: POSQuotationUpdateOneWithoutConvertedToSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput
    items?: POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type POSSaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    cashRegisterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSQuotationUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPosQuotationsNestedInput
    items?: POSQuotationItemUpdateManyWithoutQuotationNestedInput
    convertedToSale?: POSSaleUpdateOneWithoutQuotationNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosQuotationsNestedInput
  }

  export type POSQuotationUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: POSQuotationItemUncheckedUpdateManyWithoutQuotationNestedInput
    convertedToSale?: POSSaleUncheckedUpdateOneWithoutQuotationNestedInput
  }

  export type POSQuotationUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    serviceTemplate?: ServiceTemplateUpdateOneWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketAttachmentCreateManyTicketInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    uploadedById: string
    createdAt?: Date | string
  }

  export type PartUsageCreateManyTicketInput = {
    id?: string
    quantity: number
    partId: string
    createdAt?: Date | string
  }

  export type TicketNoteCreateManyTicketInput = {
    id?: string
    content: string
    isInternal?: boolean
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketServiceCreateManyTicketInput = {
    id?: string
    serviceId: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type UserPresenceCreateManyCurrentTicketInput = {
    id?: string
    userId: string
    tenantId: string
    status?: $Enums.PresenceStatus
    currentRoute?: string | null
    currentPage?: string | null
    lastSeenAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TicketAttachmentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedAttachmentsNestedInput
  }

  export type TicketAttachmentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketAttachmentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUsageUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    part?: PartUpdateOneRequiredWithoutUsagesNestedInput
  }

  export type PartUsageUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    partId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUsageUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    partId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutTicketNotesNestedInput
  }

  export type TicketNoteUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketNoteUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketServiceUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceTemplateUpdateOneRequiredWithoutUsagesNestedInput
  }

  export type TicketServiceUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketServiceUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPresenceUpdateWithoutCurrentTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPresenceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUserPresencesNestedInput
  }

  export type UserPresenceUncheckedUpdateWithoutCurrentTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPresenceUncheckedUpdateManyWithoutCurrentTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    currentRoute?: NullableStringFieldUpdateOperationsInput | string | null
    currentPage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CreditNoteItemCreateManyPartInput = {
    id?: string
    creditNoteId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
  }

  export type POSQuotationItemCreateManyPartInput = {
    id?: string
    quotationId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemCreateManyPartInput = {
    id?: string
    saleId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseItemCreateManyPartInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    purchaseOrderId: string
  }

  export type TemplateDefaultPartCreateManyPartInput = {
    id?: string
    quantity?: number
    required?: boolean
    templateId: string
    createdAt?: Date | string
  }

  export type PartUsageCreateManyPartInput = {
    id?: string
    quantity: number
    ticketId: string
    createdAt?: Date | string
  }

  export type CreditNoteItemUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    creditNote?: CreditNoteUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CreditNoteItemUncheckedUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditNoteItemUncheckedUpdateManyWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type POSQuotationItemUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    quotation?: POSQuotationUpdateOneRequiredWithoutItemsNestedInput
  }

  export type POSQuotationItemUncheckedUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemUncheckedUpdateManyWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale?: POSSaleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type POSSaleItemUncheckedUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemUncheckedUpdateManyWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseItemUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateDefaultPartUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ServiceTemplateUpdateOneRequiredWithoutDefaultPartsNestedInput
  }

  export type TemplateDefaultPartUncheckedUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateDefaultPartUncheckedUpdateManyWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUsageUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutPartsUsedNestedInput
  }

  export type PartUsageUncheckedUpdateWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartUsageUncheckedUpdateManyWithoutPartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseItemCreateManyPurchaseOrderInput = {
    id?: string
    quantity: number
    unitCost: Decimal | DecimalJsLike | number | string
    partId: string
  }

  export type PurchaseItemUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    part?: PartUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type PurchaseItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateDefaultPartCreateManyTemplateInput = {
    id?: string
    quantity?: number
    required?: boolean
    partId: string
    createdAt?: Date | string
  }

  export type TicketServiceCreateManyServiceInput = {
    id?: string
    ticketId: string
    name: string
    laborCost: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TicketCreateManyServiceTemplateInput = {
    id?: string
    ticketNumber?: string | null
    title: string
    description: string
    status?: $Enums.TicketStatus
    tenantId: string
    customerId: string
    assignedToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accessories?: string | null
    cancellationReason?: string | null
    checkInNotes?: string | null
    deviceModel?: string | null
    deviceType?: string | null
    serialNumber?: string | null
    createdById?: string | null
    updatedById?: string | null
    priority?: $Enums.TicketPriority
    dueDate?: Date | string | null
    estimatedCompletionDate?: Date | string | null
  }

  export type TemplateDefaultPartUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    part?: PartUpdateOneRequiredWithoutTemplateDefaultPartsNestedInput
  }

  export type TemplateDefaultPartUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    partId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateDefaultPartUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    required?: BoolFieldUpdateOperationsInput | boolean
    partId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutServicesNestedInput
  }

  export type TicketServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    laborCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutServiceTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUpdateManyWithoutTicketNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedTicketsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutTicketsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedTicketsNestedInput
    viewedByUsers?: UserPresenceUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutServiceTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: TicketAttachmentUncheckedUpdateManyWithoutTicketNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTicketNestedInput
    partsUsed?: PartUsageUncheckedUpdateManyWithoutTicketNestedInput
    notes?: TicketNoteUncheckedUpdateManyWithoutTicketNestedInput
    services?: TicketServiceUncheckedUpdateManyWithoutTicketNestedInput
    viewedByUsers?: UserPresenceUncheckedUpdateManyWithoutCurrentTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutServiceTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessories?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    checkInNotes?: NullableStringFieldUpdateOperationsInput | string | null
    deviceModel?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceHistoryCreateManyInvoiceInput = {
    id?: string
    action: string
    oldValue?: string | null
    newValue?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    paymentNumber: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.PaymentMethod
    transactionRef?: string | null
    notes?: string | null
    paidAt?: Date | string
    tenantId: string
    receivedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceHistoryUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoiceHistoryNestedInput
  }

  export type InvoiceHistoryUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceHistoryUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedBy?: UserUpdateOneRequiredWithoutReceivedPaymentsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSaleCreateManyCashRegisterInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    customerName?: string
    customerPhone?: string | null
    customerEmail?: string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    amountPaid?: Decimal | DecimalJsLike | number | string
    changeGiven?: Decimal | DecimalJsLike | number | string
    status?: $Enums.POSSaleStatus
    notes?: string | null
    tenantId: string
    createdById: string
    quotationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CashTransactionCreateManyCashRegisterInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    reference?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
  }

  export type POSSaleUpdateWithoutCashRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPosSalesNestedInput
    creditNotes?: CreditNoteUpdateManyWithoutPosSaleNestedInput
    customer?: CustomerUpdateOneWithoutPosSalesNestedInput
    items?: POSSaleItemUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUpdateManyWithoutSaleNestedInput
    quotation?: POSQuotationUpdateOneWithoutConvertedToSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPosSalesNestedInput
  }

  export type POSSaleUncheckedUpdateWithoutCashRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNotes?: CreditNoteUncheckedUpdateManyWithoutPosSaleNestedInput
    items?: POSSaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: POSSalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type POSSaleUncheckedUpdateManyWithoutCashRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeGiven?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPOSSaleStatusFieldUpdateOperationsInput | $Enums.POSSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUpdateWithoutCashRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCashTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutCashRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUncheckedUpdateManyWithoutCashRegisterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteCreateManyPosSaleInput = {
    id?: string
    creditNoteNumber: string
    customerId?: string | null
    reason: string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    status?: $Enums.CreditNoteStatus
    refundMethod?: $Enums.PaymentMethod | null
    refundReference?: string | null
    notes?: string | null
    processedAt?: Date | string | null
    processedById?: string | null
    tenantId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type POSSaleItemCreateManySaleInput = {
    id?: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSSalePaymentCreateManySaleInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    reference?: string | null
    createdAt?: Date | string
  }

  export type CreditNoteUpdateWithoutPosSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreditNotesCreatedNestedInput
    processedBy?: UserUpdateOneWithoutCreditNotesProcessedNestedInput
    customer?: CustomerUpdateOneWithoutCreditNotesNestedInput
    items?: CreditNoteItemUpdateManyWithoutCreditNoteNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCreditNotesNestedInput
  }

  export type CreditNoteUncheckedUpdateWithoutPosSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CreditNoteItemUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type CreditNoteUncheckedUpdateManyWithoutPosSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    creditNoteNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    refundMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    refundReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedById?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSaleItemUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    part?: PartUpdateOneRequiredWithoutPosSaleItemsNestedInput
  }

  export type POSSaleItemUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSSaleItemUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSSalePaymentUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSalePaymentUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSSalePaymentUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type POSQuotationItemCreateManyQuotationInput = {
    id?: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    part?: PartUpdateOneRequiredWithoutPosQuotationItemsNestedInput
  }

  export type POSQuotationItemUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type POSQuotationItemUncheckedUpdateManyWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CreditNoteItemCreateManyCreditNoteInput = {
    id?: string
    partId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    reason?: string | null
  }

  export type CreditNoteItemUpdateWithoutCreditNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    part?: PartUpdateOneRequiredWithoutCreditNoteItemsNestedInput
  }

  export type CreditNoteItemUncheckedUpdateWithoutCreditNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CreditNoteItemUncheckedUpdateManyWithoutCreditNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    partId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}