import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log('Setting up Audit Triggers...');
  
  const createFunction = `
    CREATE OR REPLACE FUNCTION log_audit() RETURNS TRIGGER AS $$
    DECLARE
      audit_action "AuditAction";
      audit_module "AuditModule";
      metadata JSONB;
      entity_type TEXT;
      tenant_id_val TEXT;
      user_id_val TEXT;
    BEGIN
      -- Determine Action
      IF (TG_OP = 'INSERT') THEN
        audit_action := 'USER_CREATED'; -- Default fallback
        metadata := jsonb_build_object('new', row_to_json(NEW));
      ELSIF (TG_OP = 'UPDATE') THEN
        audit_action := 'USER_UPDATED';
        metadata := jsonb_build_object('old', row_to_json(OLD), 'new', row_to_json(NEW), 'changes', hstore_to_jsonb(hstore(NEW) - hstore(OLD)));
      ELSIF (TG_OP = 'DELETE') THEN
        audit_action := 'USER_DEACTIVATED'; -- Or DELETE
        metadata := jsonb_build_object('old', row_to_json(OLD));
      END IF;

      -- Determine Module & Entity
      IF (TG_TABLE_NAME = 'users') THEN
        audit_module := 'USERS';
        entity_type := 'User';
        tenant_id_val := COALESCE(NEW."tenantId", OLD."tenantId");
        user_id_val := NULL; -- System trigger
      ELSIF (TG_TABLE_NAME = 'tickets') THEN
        audit_module := 'TICKETS';
        entity_type := 'Ticket';
        tenant_id_val := COALESCE(NEW."tenantId", OLD."tenantId");
        
        IF (TG_OP = 'INSERT') THEN audit_action := 'TICKET_CREATED'; END IF;
        IF (TG_OP = 'UPDATE') THEN audit_action := 'TICKET_UPDATED'; END IF;
        IF (TG_OP = 'DELETE') THEN audit_action := 'TICKET_DELETED'; END IF;
      END IF;

      -- Insert into AuditLog
      -- Note: UUID generation for ID requires pgcrypto or uuid-ossp if not auto-generated by Prisma defaults (gen_random_uuid() is standard in pg13+)
      INSERT INTO "audit_logs" ("id", "action", "module", "entityType", "entityId", "metadata", "tenantId", "userId", "createdAt", "success")
      VALUES (
        gen_random_uuid(),
        audit_action,
        audit_module,
        entity_type,
        COALESCE(NEW.id, OLD.id),
        metadata,
        tenant_id_val,
        user_id_val, -- System user or NULL
        NOW(),
        true
      );
      
      RETURN NULL;
    END;
    $$ LANGUAGE plpgsql;
  `;

  // We need the hstore extension for diffing
  const createExtension = `CREATE EXTENSION IF NOT EXISTS hstore;`;

  const triggerUser = `
    DROP TRIGGER IF EXISTS trigger_audit_users ON "users";
    CREATE TRIGGER trigger_audit_users
    AFTER INSERT OR UPDATE OR DELETE ON "users"
    FOR EACH ROW EXECUTE FUNCTION log_audit();
  `;

  const triggerTicket = `
    DROP TRIGGER IF EXISTS trigger_audit_tickets ON "tickets";
    CREATE TRIGGER trigger_audit_tickets
    AFTER INSERT OR UPDATE OR DELETE ON "tickets"
    FOR EACH ROW EXECUTE FUNCTION log_audit();
  `;

  try {
    await prisma.$executeRawUnsafe(createExtension);
    await prisma.$executeRawUnsafe(createFunction);
    
    await prisma.$executeRawUnsafe(`DROP TRIGGER IF EXISTS trigger_audit_users ON "users";`);
    await prisma.$executeRawUnsafe(`
        CREATE TRIGGER trigger_audit_users
        AFTER INSERT OR UPDATE OR DELETE ON "users"
        FOR EACH ROW EXECUTE FUNCTION log_audit();
    `);

    await prisma.$executeRawUnsafe(`DROP TRIGGER IF EXISTS trigger_audit_tickets ON "tickets";`);
    await prisma.$executeRawUnsafe(`
        CREATE TRIGGER trigger_audit_tickets
        AFTER INSERT OR UPDATE OR DELETE ON "tickets"
        FOR EACH ROW EXECUTE FUNCTION log_audit();
    `);
    
    console.log('Triggers set up successfully.');
  } catch (e) {
    console.error('Error setting up triggers:', e);
  } finally {
    await prisma.$disconnect();
  }
}

main();
